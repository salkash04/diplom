<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="../../../../../../../../Users/Салават/Downloads/Multithreading_/resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s1{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s2{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#cfe2f3;text-align:center;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s12{background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:9pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s5{background-color:#ffffff;text-align:left;color:#000000;font-family:docs-Calibri,Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s14{background-color:#ffffff;text-align:left;color:#000000;font-family:Verdana;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s13{background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:docs-Calibri,Arial;font-size:14pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s11{background-color:#ffffff;text-align:left;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;font-family:Arial;font-size:9pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s8{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#cfe2f3;text-align:center;font-weight:bold;color:#002060;font-family:Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s3{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s10{background-color:#ffffff;text-align:left;color:#000000;font-family:Verdana;font-size:8pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s6{background-color:#ffffff;text-align:left;color:#151f33;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s16{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#8b8948;font-family:Arial;font-size:9pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s15{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:9pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s7{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s0{border-bottom:1px SOLID transparent;border-right:1px SOLID transparent;background-color:#3d85c6;text-align:center;font-weight:bold;color:#ffffff;font-family:Arial;font-size:14pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s4{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s9{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:9pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-origin-ltr"></th><th id="0C0" style="width:159px;" class="column-headers-background">A</th><th id="0C1" style="width:841px;" class="column-headers-background">B</th><th id="0C2" style="width:459px;" class="column-headers-background">C</th></tr></thead><tbody><tr style="height: 20px"><th id="0R0" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">1</div></th><td class="s0" colspan="2">Multithreading</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R1" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">2</div></th><td class="s2">Чем процесс отличается от потока?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#3e5656;">Процесс</span><span style="font-size:9pt;font-family:Arial;color:#3e5656;">— </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#3e5656;">экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы </span><span style="font-size:9pt;font-family:Arial;color:#3e5656;">(например, процессорное время и память). </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#3e5656;">Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого</span><span style="font-size:9pt;font-family:Arial;color:#3e5656;">.<br>Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.<br>Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#3e5656;">Поток</span><span style="font-size:9pt;font-family:Arial;color:#3e5656;">(thread) — </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#3e5656;">способ выполнения процесса, определяющий последовательность исполнения кода в процессе</span><span style="font-size:9pt;font-family:Arial;color:#3e5656;">. </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#3e5656;">Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах</span><span style="font-size:9pt;font-family:Arial;color:#3e5656;">. <br>Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах. Так как потоки расходуют существенно меньше ресурсов, чем процессы, в процессе выполнения работы выгоднее создавать дополнительные потоки и избегать создания новых процессов.</span></td><td class="s4">Состояния потока <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">THREAD - NEW – Runnable</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> (после вызова start) </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">(ready</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - ждет пока ОС запустит поток т.к могут в очереди быть еще потоки) – </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">running</span><span style="font-size:10pt;font-family:Arial;color:#000000;">-когда ОС запустила поток – </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Terminated</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> (когда поток завершен)<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">thread.getState()</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> – вывод состояния потока (если поток быстрый информация о состоянии может быть не актуальной при выводе в консоль)<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">join - </span><span style="font-size:10pt;font-family:Arial;color:#000000;">подождать пока оппонент закончит работу (main подождет окончания какого – то потока и только потом выполнит свой метод)<br></span></td></tr><tr style="height: 20px"><th id="0R2" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">3</div></th><td class="s2">Чем Thread отличается от Runnable? Когда нужно использовать Thread, а когда Runnable? (Ответ что тред - это класс,  а ранбл интерфейс - считается не полным, нужно рассказать подробно)</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Thread - это класс, некоторая надстройка над физическим потоком. Runnable - это интерфейс, представляющий абстракцию над выполняемой задачей</span><span style="font-size:9pt;font-family:Arial;color:#000000;">. Помимо того, что </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Runnable помогает разрешить проблему множественного наследования</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, несомненный плюс от его использования состоит в том, что он позволяет логически отделить логику выполнения задачи от непосредственного управления потоком. В классе Thread имеется несколько методов, которые можно переопределить в порожденном классе. Из них обязательному переопределению подлежит только метод run(). Этот же метод, безусловно, должен быть определен и при реализации интерфейса Runnable. Некоторые программисты считают,</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"> что создавать подкласс, порожденный от класса Thread, следует только в том случае, если нужно дополнить его новыми функциями. Так, если переопределять любые другие методы из класса Thread не нужно, то можно ограничиться только реализацией интерфейса Runnable</span><span style="font-size:9pt;font-family:Arial;color:#000000;">. Кроме того, реализация интерфейса Runnable позволяет создаваемому потоку наследовать класс, отличающийся от Thread</span></td><td class="s4">Если тебе нужно больше гибкости и ты хочешь создавать потоки с кастомным поведением — используй Thread.<br>Если тебе нужно просто передать задачу в уже существующий поток — используй Runnable.</td></tr><tr style="height: 20px"><th id="0R3" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">4</div></th><td class="s2">Что такое монитор? Как монитор реализован в java?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Монитор</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> - </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"> это сщуность/механизм благодаря которому достигается корректная работа при синхронизации.В Java у каждого класса и объекта есть привязанный к нему монитор.</span><span style="font-size:9pt;font-family:Arial;color:#000000;">(средство обеспечения контроля за доступом к ресурсу)механизм синхронизации потоков, обеспечивающий доступ к неразделяемым ресурсам. Частью монитора является mutex, который встроен в класс Object и имеется у каждого объекта.<br>Удобно представлять mutex как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. Если не 0 – ресурс занят. Можно встать в очередь и ждать его освобождения.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">В Java монитор</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">реализован с помощью ключевого слова synchronized.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R4" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">5</div></th><td class="s2">Что такое синхронизация? Какие способы синхронизации существуют в java?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Синхронизация это процесс, который позволяет выполнять потоки параллельно.</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"><br></span><span style="font-size:9pt;font-family:Arial;color:#000000;">В Java все объекты имеют блокировку, благодаря которой только один поток одновременно может получить доступ к критическому коду в объекте. Такая синхронизация помогает предотвратить повреждение состояния объекта.<br><br>Способы синхронизации в Java:<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Системная синхронизация с использованием wait()/notify().</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> <br>Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait(), предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify() (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток «просыпается» и продолжает свое выполнение. В обоих случаях монитор надо захватывать в явном виде, через synchronized-блок, потому как методы wait()/notify() не синхронизированы!<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Системная синхронизация с использованием join()</span><span style="font-size:9pt;font-family:Arial;color:#000000;">.<br>Метод join(), вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Использование классов из пакета java.util.concurrent.Locks - </span><span style="font-size:9pt;font-family:Arial;color:#000000;">механизмы синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll: </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Lock, Condition, ReadWriteLock.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br></span></td><td class="s5">Блок синхронизации удобен если у нас есть несколько методов и несколько потоков каждый из которых обрабатывает свой отдельный метод но нужна последовательность между этими методами, тогда мы создаем объект для монитора и в 1 монитор помещаем все эти синхр.блоки. Работа под капотом 1 поток занимает монитор он ставит статус (закрыт) выполняет метод, после завершения метода монитор ставит статус(открыт) и входит 2 поток и т.д. Но опять же последовательности в методах не будет какой поток пришел 1 такой и будет работать</td></tr><tr style="height: 20px"><th id="0R5" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">6</div></th><td class="s2">Как работают методы wait(), notify() и notifyAll()?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()/notifyAll();<br>notify(): Не освобождает монитор и будит поток у которого ранее был вызван метод waiit();<br>notifyAll(): Не освобождает монитор и будит все потоки у которых ранее был выван метод  waiit();</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br>Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в состояние Ожидания (Waiting). Метод </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">notify()</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">подаёт сигнал</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> одному из </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">потоков</span><span style="font-size:9pt;font-family:Arial;color:#000000;">,</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"> ожидающих на объекте</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">чтобы перейти в состояние Работоспособный (Runnable)</span><span style="font-size:9pt;font-family:Arial;color:#000000;">. При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным. Метод notifyAll() заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable).</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"> Если ни один поток не находится в ожидании на методе wait(),</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> т</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">о при вызове notify() или notifyAll() ничего не происходит.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br>wait(), notify() и notifyAll() </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">должны</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> вызываться </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">только из синхронизированного кода.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R6" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">7</div></th><td class="s2">В каких состояниях может находиться поток?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">New </span><span style="font-size:9pt;font-family:Arial;color:#000000;">- объект класса Thread создан, но еще не запущен. Он еще не является потоком выполнения и естественно не выполняется.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Runnable </span><span style="font-size:9pt;font-family:Arial;color:#000000;">- поток готов к выполнению, но планировщик еще не выбрал его.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Running </span><span style="font-size:9pt;font-family:Arial;color:#000000;">– поток выполняется.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Waiting/blocked/sleeping</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> - поток блокирован или поток ждет окончания работы другого потока.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Dead </span><span style="font-size:9pt;font-family:Arial;color:#000000;">- поток завершен. Будет выброшено исключение при попытке вызвать метод start() для dead потока.<br> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">public enum State</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> (У класса Thread есть внутренний класс State - состояние, а также метод public State getState().)<br>{<br> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">NEW</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, — поток создан, но еще не запущен;<br> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">RUNNABLE</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, — поток выполняется;<br> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">BLOCKED</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, — поток блокирован;<br> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">WAITING</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, — поток ждет окончания работы другого потока;<br> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">TIMED_WAITING</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, — поток некоторое время ждет окончания другого потока;<br> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">TERMINATED</span><span style="font-size:9pt;font-family:Arial;color:#000000;">; — поток завершен.<br>}</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R7" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">8</div></th><td class="s2">Что такое семафор? Как он реализован в Java?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Semaphore – это синхронизатор позволяющий ограничить доступ к каждому ресурсу .В конструктор Симофор нужна передавать количество потоков, которым Симофор будет разрешать одновременно использовать этот ресурс.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> Доступ управляется с помощью счётчика: изначальное значение счетчика задается в конструкторе при создании синхронизатора, когда поток заходит в заданный блок кода, то значение счетчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счетчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока. </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле.</span></td><td class="s6">Методы <span style="font-size:10pt;font-family:Consolas,Arial;font-weight:bold;color:#000000;">acquire()</span><span style="font-size:10pt;font-family:Arial;color:#151f33;"> и </span><span style="font-size:10pt;font-family:Consolas,Arial;font-weight:bold;color:#000000;">release()</span><span style="font-size:10pt;font-family:Arial;color:#151f33;"> класса </span><span style="font-size:10pt;font-family:Consolas,Arial;color:#000000;">Semaphore</span><span style="font-size:10pt;font-family:Arial;color:#151f33;"> управляют его счетчиком разрешений. Метод </span><span style="font-size:10pt;font-family:Consolas,Arial;color:#000000;">acquire()</span><span style="font-size:10pt;font-family:Arial;color:#151f33;"> запрашивает разрешение на доступ к ресурсу у семафора. Если счетчик &gt; 0, разрешение предоставляется, а счетчик уменьшается на 1. Метод </span><span style="font-size:10pt;font-family:Consolas,Arial;color:#000000;">release()</span><span style="font-size:10pt;font-family:Arial;color:#151f33;"> «освобождает» выданное ранее разрешение и возвращает его в счетчик (увеличивает счетчик разрешений семафора на 1).</span></td></tr><tr style="height: 20px"><th id="0R8" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">9</div></th><td class="s2">Что означает ключевое слово volatile? Почему операции над volatile переменными не атомарны?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Volatile - используется для пометки переменной как хранящейся только в основной памяти Main Memory(куча) !!! ИСПОЛЬЗУЕТСЯ ТОЛЬКО ТОГДА КОГДА ТОЛЬКО ОДИН ПОТОК МОЖЕТ ИЗМЕНЯТЬ ЗНАЧЕНИЕ ПЕРМЕННОЙ А ОСТАЛЬНЫЕ ПОТОКИ МОГУТ ЕЕ ТОЛЬКО ЧИТАТЬ!!! . Переменная volatile является атомарной для чтения, но операции над переменной НЕ являются атомарными. Поля, для которых неприемлемо увидеть «несвежее» (stale) значение в результате кэширования или переупорядочения.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br>Если происходит какая-то операция, например, инкримент, то атомарность уже не обеспечивается, потому что сначала выполняется чтение(1), потом изменение(2) в локальной памяти, а затем запись(3). Такая операция не является атомарной и в неё может вклиниться поток по середине.<br>Атомарная операция выглядит единой и неделимой командой процессора.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Переменная volatile находится в хипе, а не в кэше стека . </span></td><td class="s7"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Атомарная операция</span><span style="font-size:10pt;font-family:Arial;"> — операция, которая либо выполняется целиком, либо не выполняется вовсе;</span></td></tr><tr style="height: 20px"><th id="0R9" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">10</div></th><td class="s8">    Для чего нужны Atomic типы данных? Чем отличаются от volatile?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">volatile не гарантирует атомарность.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> </span><span style="font-size:9pt;font-family:Arial;color:#000000;">Например, операция count++ не станет атомарной просто потому что count объявлена volatile. C другой стороны class AtomicInteger предоставляет атомарный метод для выполнения таких комплексных операций атомарно над int</span><span style="font-size:9pt;font-family:Arial;color:#000000;">,– </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Atomic</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> - </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">это семейство классов из java.util.concurrent. Они предоставляют набор атомарных операций для соответствующих типов. Например с помощью методов getAndIncrement/incrementAndGet класса AtomicInteger можно делать неатомарный в обычных условиях инкремент (i++)</span><span style="font-size:9pt;font-family:Arial;color:#000000;">.</span></td><td class="s4">новные отличия:<br><br>    Atomic гарантирует атомарные операции, т.е. они выполняются без прерываний и вмешательства других потоков. Это для операций с изменением данных, таких как увеличение счетчика или обновление состояния.<br>    volatile просто гарантирует, что данные будут синхронизироваться между потоками, но не атомарно. То есть если два потока одновременно читают/пишут в одну и ту же переменную, это может привести к гонке данных.</td></tr><tr style="height: 20px"><th id="0R10" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">11</div></th><td class="s2">Что такое потоки демоны? Для чего они нужны? Как создать поток-демон?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Потоки Демоны - потоки предназначены для выполнения фоновых задач и оказания различных сервисов USER потокам ( При завершении работы последнего USER потока программа завершает свое выполнеие не дожидаясь оконачание работы Демон потоков</span><span style="font-size:9pt;font-family:Arial;color:#000000;">) . Такой процесс может быть запущен как поток-демон с помощью метода</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"> setDaemon(boolean value)</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, вызванного у потока до его запуска. Метод boolean isDaemon() позволяет определить, является ли указанный поток демоном или нет. </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Основной поток приложения может завершить выполнение потока-демона </span><span style="font-size:9pt;font-family:Arial;color:#000000;">(в отличие от обычных потоков)</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"> с окончанием кода метода main(), не обращая внимания</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">что</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">поток-демон еще работает.<br></span><span style="font-size:9pt;font-family:Arial;color:#000000;">Поток демон можно сделать только если он еще не запущен. </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Пример демона - GC.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R11" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">12</div></th><td class="s2">Что такое приоритет потока? На что он влияет? Какой приоритет у потоков по умолчанию?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Приоритеты потоков используются планировщиком потоков для принятия решений о том, когда какому из потоков будет разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, чем низкоприоритетные</span><span style="font-size:9pt;font-family:Arial;color:#000000;">. Практически объем времени процессора, который получает поток, часто зависит от нескольких факторов помимо его приоритета(является ли поток демоном).<br>Чтобы установить приоритет потока, используется метод класса Thread: final void setPriority(int level). Значение level изменяется в пределах от Thread.MIN_PRIORITY = 1 до Thread.MAX_PRIORITY = 10. </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Приоритет по умолчанию - Thread.NORM_PRlORITY = 5.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br>Получить текущее значение приоритета потока можно вызвав метод: final int getPriority() у экземпляра класса Thread.<br>Метод yield() можно использовать для того чтобы принудить планировщик выполнить другой поток, который ожидает своей очереди.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R12" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">13</div></th><td class="s2">Как работает Thread.join()? Для чего он нужен?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">join - подождать пока оппонент закончит работу (main подождет окончания какого – то потока и только потом выполнит свой метод)</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br>void join()        <br>void join(long millis) - с временем ожидания<br>void join(long millis, int nanos)<br>Применение: при распараллелили вычисления, вам надо дождаться результатов, чтобы собрать их в кучу и продолжить выполнение.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R13" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">14</div></th><td class="s2">Чем отличаются методы wait() и sleep()?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">метод sleep() - приостанавливает поток на указанное время. Состояние меняется на WAITING, по истечению - RUNNABLE. </span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">метод wait() - меняет состояние потока на WAITING. Может быть вызван только у объекта владеющего блокировкой, в противном случае выкинется исключение IllegalMonitorStateException</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R14" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">15</div></th><td class="s2">Можно ли вызвать start() для одного потока дважды?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Нельзя</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> стартовать поток больше, чем единожды. В частности, поток не может быть перезапущен, если он уже завершил выполнение.<br>Выдает: IllegalThreadStateException</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R15" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">16</div></th><td class="s2" rowspan="5">Как правильно остановить поток? Для чего нужны методы .stop(), .interrupt(), .interrupted(), .isInterrupted().</td><td class="s9">Как остановить поток?<br>На данный момент в Java принят уведомительный порядок остановки потока (хотя JDK 1.0 и имеет несколько управляющих выполнением потока методов, например stop(), suspend() и resume() - в следующих версиях JDK все они были помечены как deprecated из-за потенциальных угроз взаимной блокировки).<br><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Для корректной остановки потока</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> можно использовать метод класса Thread - </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">interrupt().</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> Этот метод выставляет внутренний флаг-статус прерывания. В дальнейшем состояние этого флага можно проверить с помощью метода isInterrupted() или Thread.interrupted() (для текущего потока). </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Метод interrupt() также способен вывести поток из состояния ожидания или спячки</span><span style="font-size:9pt;font-family:Arial;color:#000000;">. Т.е. если у потока были вызваны методы sleep() или wait() – текущее состояние прервется и будет выброшено исключение InterruptedException. Флаг в этом случае не выставляется.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Схема действия</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> при этом получается следующей:</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R16" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">17</div></th><td class="s9"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Реализовать поток.<br>В потоке периодически проводить проверку статуса прерывания через вызов isInterrupted().<br></span><span style="font-size:9pt;font-family:Arial;color:#000000;">Если состояние флага изменилось или было выброшено исключение во время ожидания/спячки, следовательно поток пытаются остановить извне.<br>Принять решение – продолжить работу (если по каким-то причинам остановиться невозможно) или освободить заблокированные потоком ресурсы и закончить выполнение.<br>Возможная проблема, которая присутствует в этом подходе – блокировки на потоковом вводе-выводе. Если поток заблокирован на чтении данных - вызов interrupt() из этого состояния его не выведет. Решения тут различаются в зависимости от типа источника данных. Если чтение идет из файла – долговременная блокировка крайне маловероятна и тогда можно просто дождаться выхода из метода read(). Если же чтение каким-то образом связано с сетью – стоит использовать неблокирующий ввод-вывод из Java NIO.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R17" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">18</div></th><td class="s9"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Второй вариант реализации метода остановки (а также и приостановки) – сделать собственный аналог interrupt().</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> Т.е. объявить в классе потока флаги – на остановку и/или приостановку и выставлять их путем вызова заранее определённых методов извне. Методика действия при этом остаётся прежней – проверять установку флагов и принимать решения при их изменении. Недостатки такого подхода. Во-первых, потоки в состоянии ожидания таким способом не «оживить». Во-вторых, выставление флага одним потоком совсем не означает, что второй поток тут же его увидит. Для увеличения производительности виртуальная машина использует кеш данных потока, в результате чего обновление переменной у второго потока может произойти через неопределенный промежуток времени (хотя допустимым решением будет объявить переменную-флаг как volatile).</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R18" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">19</div></th><td class="s9"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Почему не рекомендуется использовать метод Thread.stop()?<br>При принудительной остановке (приостановке) потока, stop() прерывает поток в недетерменированном(неопределенный) месте выполнения, в результате становится совершенно непонятно, что делать с принадлежащими ему ресурсами. Поток может открыть сетевое соединение - что в таком случае делать с данными, которые еще не вычитаны?</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> Где гарантия, что после дальнейшего запуска потока (в случае приостановки) он сможет их дочитать? Если поток блокировал разделяемый ресурс, то как снять эту блокировку и не переведёт ли принудительное снятие к нарушению консистентности системы? То же самое можно расширить и на случай соединения с базой данных: если поток остановят посередине транзакции, то кто ее будет закрывать? Кто и как будет разблокировать ресурсы?</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R19" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">20</div></th><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">В чем разница между interrupted() и isInterrupted()?<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Механизм прерывания работы потока в Java реализован с использованием внутреннего флага, известного как статус прерывания. Прерывание потока вызовом Thread.interrupt() устанавливает этот флаг. Методы Thread.interrupted() и isInterrupted() позволяют проверить, является ли поток прерванным.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br>Когда прерванный поток проверяет статус прерывания, вызывая </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">статический метод Thread.interrupted(), статус прерывания сбрасывается.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Нестатический метод isInterrupted() используется одним потоком для проверки статуса прерывания у другого потока, не изменяя флаг прерывания.</span></td><td class="s10">В классе, который унаследован от Thread, мы можем получить статус текущего потока с помощью метода <span style="font-size:8pt;font-family:Verdana;font-weight:bold;color:#000000;">isInterrupted()</span><span style="font-size:8pt;font-family:Verdana;color:#000000;">. И пока этот метод возвращает false, мы можем выполнять цикл. А после того, как будет вызван метод interrupt, </span><span style="font-size:8pt;font-family:&quot;Courier New&quot;;color:#000000;">isInterrupted()</span><span style="font-size:8pt;font-family:Verdana;color:#000000;"> возвратит true, и соответственно произойдет выход из цикла.</span></td></tr><tr style="height: 20px"><th id="0R20" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">21</div></th><td class="s2">Чем Runnable отличается от Callable?</td><td class="s3">Интерфейс <span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Runnable</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> появился в Java 1.0, а интерфейс </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Callable</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> был введен в Java 5.0 в составе библиотеки java.util.concurrent;<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Классы, реализующие</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> интерфейс </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Runnable</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> для выполнения задачи </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">должны реализовывать метод run(). Классы, реализующие интерфейс Callable - метод call();</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br>Метод Runnable.</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">run() не возвращает</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> никакого значения, <br>Callable - это параметризованный функциональный интерфейс. Callable.</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">call() возвращает Object, если он не параметризован, иначе указанный тип.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br>Метод</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"> run() НЕ может выбрасывать проверяемые исключения, в то время как метод call() может.</span></td><td class="s4"><span style="font-size:10pt;font-family:Arial;">Callable: </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Метод submit </span><span style="font-size:10pt;font-family:Arial;">передает наше значение (task) в thread pool для выполнения его одним из потоков и возвращает тип Future в котором и хранится результат выполнения нашего задания.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;"> Метод get</span><span style="font-size:10pt;font-family:Arial;"> - позволяет получить результат нашего задания из объекта Future</span></td></tr><tr style="height: 20px"><th id="0R21" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">22</div></th><td class="s2">Что такое FutureTask?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Интерфейс java.util.concurrent.Future описывает API для работы с задачами, результат которых мы планируем получить в будущем: методы получения результата, методы проверки статуса.</span><span style="font-size:9pt;font-family:Arial;color:#000000;">FutureTask представляет собой </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">отменяемое</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">асинхронное</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">вычисление</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> в </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">параллельном</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">потоке</span><span style="font-size:9pt;font-family:Arial;color:#000000;">. Этот </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">класс</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> предоставляет </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">базовую реализацию Future</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Результат может быть получен только когда вычисление завершено</span><span style="font-size:9pt;font-family:Arial;color:#000000;">,</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"> метод получения будет заблокирован, если вычисление ещё не завершено</span><span style="font-size:9pt;font-family:Arial;color:#000000;">. Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">FutureTask помимо Future реализует Runnable</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, его можно передать в Executor на выполнение.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R22" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">23</div></th><td class="s2">Что такое deadlock?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;">Взаимная блокировка (deadlock) - ситуация когда 2 и более потоков залочены навсегда, ожидают друг друга и ничего не делают.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Deadlock происходит, когда достигаются эти 4 состояния</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">взаимного исключения: </span><span style="font-size:9pt;font-family:Arial;color:#000000;">по крайней мере </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">один </span><span style="font-size:9pt;font-family:Arial;color:#000000;">ресурс занят в режиме неделимости и следовательно только один поток может использовать ресурс в данный момент времени.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">удержания и ожидания: </span><span style="font-size:9pt;font-family:Arial;color:#000000;">поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсы, которые удерживаются другими потоками.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">отсутствия предочистки:</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> операционная система не переназначает ресурсы: если они уже заняты, они должны отдаваться удерживающим потокам сразу же.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">цикличного ожидания: </span><span style="font-size:9pt;font-family:Arial;color:#000000;">поток ждет освобождения ресурса другим потоком, который в свою очередь ждёт освобождения ресурса заблокированного первым потоком.<br><br>Простейший способ </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">избежать взаимной блокировки</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> – </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">не допускать цикличного ожидания.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> Этого </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">можно достичь</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">получая мониторы разделяемых ресурсов в определенном порядке и освобождая их в обратном порядке.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R23" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">24</div></th><td class="s2">Что такое livelock?</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;">livelock – ситуация когда 2 или более потоков залочены навсегда, ожидают друг друга, проделывают какую-то работу, но без какого-либо прогресса.</span><span style="font-size:9pt;font-family:Arial;color:#000000;">. При этом </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">их состояния</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> постоянно </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">изменяются</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> в </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">зависимости друг от друга.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> Фактической </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">ошибки не возникает</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, но КПД системы падает до 0. Часто возникает в результате попыток предотвращения deadlock.<br>Реальный </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">пример</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> livelock, – когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону, абсолютно не продвигаясь в нужном им направлении.</span></td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Lock Starvation</span><span style="font-size:10pt;font-family:Arial;"> - ситуация когда менее приоритетные потоки ждут долгое время или все время для того чтобы могли запуститься.</span></td></tr><tr style="height: 20px"><th id="0R24" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">25</div></th><td class="s2">Что такое race condition?</td><td class="s3">Состояние гонки (race condition) - <span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">ошибка проектирования многопоточной системы или приложения</span><span style="font-size:9pt;font-family:Arial;color:#000000;">,</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"> при которой работа</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">зависит </span><span style="font-size:9pt;font-family:Arial;color:#000000;">от того</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">, в каком порядке выполняются потоки. </span><span style="font-size:9pt;font-family:Arial;color:#000000;">Состояние гонки </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">возникает когда поток, который должен исполнится в начале, проиграл гонку и первым исполняется другой поток: </span><span style="font-size:9pt;font-family:Arial;color:#000000;">поведение кода изменяется, из-за чего возникают недетерменированные ошибки.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">DataRace - это проблема которая может возникнуть когда два и более потоков обращаются к одной и той же переменной и как минимум 1 поток ее изменяет</span><span style="font-size:9pt;font-family:Arial;color:#000000;">. свойство выполнения программы. Согласно JMM, выполнение считается содержащим гонку данных, если оно содержит по крайней мере два конфликтующих доступа (чтение или запись в одну и ту же переменную), которые не упорядочены отношениями «happens before».<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Lock Starvation - ситуация когда менее приоритетные потоки ждут долгое время или все время для того чтобы могли запуститься.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br><br>Самый простой способ решения — копирование переменной в локальную переменную. Или просто синхронизация потоков методами и sync-блоками.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R25" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">26</div></th><td class="s2">Что такое Фреймворк fork/join? Для чего он нужен?</td><td class="s3">Фреймворк Fork/Join, представленный в JDK 7, - это набор классов и интерфейсов позволяющих использовать преимущества многопроцессорной архитектуры современных компьютеров.<span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"> Он разработан для выполнения задач, которые можно рекурсивно разбить на маленькие подзадачи, которые можно решать параллельно.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Этап Fork</span><span style="font-size:9pt;font-family:Arial;color:#000000;">:</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"> большая задача разделяется</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> на</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"> несколько меньших подзадач, </span><span style="font-size:9pt;font-family:Arial;color:#000000;">которые в свою очередь также разбиваются на меньшие.</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"> И так до тех пор, пока задача не становится тривиальной и решаемой последовательным способом.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Этап Join:</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> далее (опционально) идёт процесс «свёртки» - </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">решения подзадач некоторым образом объединяются пока не получится решение всей задачи.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br>Решение всех подзадач (в т.ч. и само разбиение на подзадачи) происходит параллельно.<br>Для </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">решения</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">некоторых </span><span style="font-size:9pt;font-family:Arial;color:#000000;">задач </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">этап Join не требуется. Например</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, для параллельного QuickSort — массив рекурсивно делится на всё меньшие и меньшие диапазоны, пока не вырождается в тривиальный случай из 1 элемента. Хотя в некотором смысле Join будет необходим и тут, т.к. всё равно остаётся необходимость дождаться пока не закончится выполнение всех подзадач.<br>Ещё одно </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">преимущество</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> этого фреймворка заключается в том, что он</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"> использует work-stealing алгоритм</span><span style="font-size:9pt;font-family:Arial;color:#000000;">: </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">потоки</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, которые </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">завершили</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> выполнение </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">собственных подзадач</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, могут «</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">украсть</span><span style="font-size:9pt;font-family:Arial;color:#000000;">» </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">подзадачи</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">у </span><span style="font-size:9pt;font-family:Arial;color:#000000;">других </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">потоков</span><span style="font-size:9pt;font-family:Arial;color:#000000;">, </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">которые</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">всё ещё заняты.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R26" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">27</div></th><td class="s2">Что означает ключевое слово synchronized? Где и для чего может использоваться?</td><td class="s3"><span style="color:#3e5656;">Зарезервированное слово позволяет добиваться синхронизации в помеченных им методах или блоках кода. </span><span style="font-weight:bold;color:#3e5656;">Synchronized – лочит доступ к выполнению метода «условно» для всех потоков кроме 1, как 1 закончит работу может приступить 2 для этого метода. Переменные и конструкторы не могут быть Synchronized</span><span style="color:#3e5656;"><br>Блокировка любая идет на классе или объекте а не на коде т.к синхронизируемся с помощью монитора на каком либо объекте или классе<br></span><span style="font-weight:bold;color:#3e5656;">Synchronized(this)</span><span style="color:#3e5656;"> – помогает пометить блок кода в методе чтобы не помечать весь метод<br>Synchronized блоки используем только тогда когда нужно избежать Data Race (гонка). Статик методы синхронизируются не по методу а по классу<br></span></td><td class="s5">Блок синхронизации удобен если у нас есть несколько методов и несколько потоков каждый из которых обрабатывает свой отдельный метод но нужна последовательность между этими методами, тогда мы создаем объект для монитора и в 1 монитор помещаем все эти синхр.блоки. Работа под капотом 1 поток занимает монитор он ставит статус (закрыт) выполняет метод, после завершения метода монитор ставит статус(открыт) и входит 2 поток и т.д. Но опять же последовательности в методах не будет какой поток пришел 1 такой и будет работать</td></tr><tr style="height: 20px"><th id="0R27" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">28</div></th><td class="s2">Что является монитором у статического synchronized-метода?</td><td class="s3">Объект типа Class, соответствующий классу, в котором определен метод.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R28" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">29</div></th><td class="s2">Что является монитором у нестатического synchronized-метода?</td><td class="s3">Объект this</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R29" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">30</div></th><td class="s2" rowspan="10">util. Concurrent поверхностно.</td><td class="s11"><a target="_blank" href="http://java-online.ru/concurrent.xhtml">http://java-online.ru/concurrent.xhtml</a></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R30" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">31</div></th><td class="s9">Классы и интерфейсы пакета java.util.concurrent объедининены в несколько групп по функциональному признаку:<br><br><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">collections - Набор эффективно работающих в многопоточной среде коллекций. CopyOnWriteArrayList(Set), ConcurrentHashMap.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br>Итераторы классов данного пакета представляют данные на определенный момент времени. Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии внутреннего массива. Этим гарантируется, что при проходе итератором по коллекции не будет ConcurrentModificationException.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R31" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">32</div></th><td class="s9">Отличие <span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">ConcurrentHashMap </span><span style="font-size:9pt;font-family:Arial;color:#000000;">связано с внутренней структурой хранения пар key-value. СoncurrentHashMap использует несколько сегментов, и данный класс нужно рассматривать как группу HashMap’ов. Количество сегментов по умолчанию равно 16. Если пара key-value хранится в 10-ом сегменте, то ConcurrentHashMap заблокирует, при необходимости, только 10-й сегмент, и не будет блокировать остальные 15.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R32" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">33</div></th><td class="s9"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">CopyOnWriteArrayList:<br></span><span style="font-size:9pt;font-family:Arial;color:#000000;">-volatile массив внутри<br>-lock только при модификации списка, поэтому операции чтения очень быстрые<br>-новая копия массива при модификации<br>-fail-fast итератор<br>-модификация через iterator невозможна - UnsupportedOperationException</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R33" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">34</div></th><td class="s12">synchronizers - Объекты синхронизации, позволяющие разработчику управлять и/или ограничивать работу нескольких потоков. Cодержит пять объектов синхронизации: semaphore, countDownLatch, ciclycBarrier, exchanger, phaser.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R34" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">35</div></th><td class="s9"> <span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">CountDownLatch</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> - объект синхронизации потоков, блокирующий один или несколько потоков до тех пор, пока не будут выполнены определенные условия. Количество условий задается счетчиком. При обнулении счетчика, т.е. при выполнении всех условий, блокировки выполняемых потоков будут сняты и они продолжат выполнение кода. Одноразовый.<br> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">CyclicBarrier</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> — барьерная синхронизация останавливает поток в определенном месте в ожидании прихода остальных потоков группы. Как только все потоки достигнут барьера, барьер снимается и выполнение потоков продолжается. Как и CountDownLatch, использует счетчик и похож на него. Отличие связано с тем, барьер можно использовать повторно(в цикле).<br> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Exchanger</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> — объект синхронизации, используемый для двустороннего обмена данными между двумя потоками. При обмене данными допускается null значения, что позволяет использовать класс для односторонней передачи объекта или же просто, как синхронизатор двух потоков. Обмен данными выполняется вызовом метода exchange, сопровождаемый самоблокировкой потока. Как только второй поток вызовет метод exchange, то синхронизатор Exchanger выполнит обмен данными между потоками.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Phaser</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> — объект синхронизации типа «Барьер», но, в отличие от CyclicBarrier, может иметь несколько барьеров (фаз), и количество участников на каждой фазе может быть разным.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R35" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">36</div></th><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">atomic - Набор атомарных классов для выполнения атомарных операций</span><span style="font-size:9pt;font-family:Arial;color:#000000;">. Операция является атомарной, если её можно безопасно выполнять при параллельных вычислениях в нескольких потоках, не используя при этом ни блокировок, ни синхронизацию </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">synchronized</span><span style="font-size:9pt;font-family:Arial;color:#000000;">.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Queues - содержит классы формирования неблокирующих и блокирующих очередей для многопоточных приложений.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> Неблокирующие очереди «заточены» на скорость выполнения, блокирующие очереди приостанавливают потоки при работе с очередью.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Locks - Механизмы синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll: Lock, Condition, ReadWriteLock.</span></td><td class="s13">ExecuterServise  thread pools мы всегда создаем с помощью класса Executors и вызываем метод newFixedThredPool то есть создаем не с помощью конструктора return ThreadPoolExecuter </td></tr><tr style="height: 20px"><th id="0R36" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">37</div></th><td class="s3">Lock — базовый интерфейс, предоставляющий более гибкий подход при ограничении доступа к ресурсам/блокам по сравнению с использованием synchronized. Так, при использовании нескольких блокировок, порядок их освобождения может быть произвольный. Имеется возможность перехода к альтернативному сценарию, если блокировка уже захвачена.<br><br>Condition — интерфейсное условие в сочетании с блокировкой Lock позволяет заменить методы монитора/мьютекса (wait, notify и notifyAll) объектом, управляющим ожиданием событий. Объект с условием чаще всего получается из блокировок с использованием метода lock.newCondition(). Таким образом можно получить несколько комплектов wait/notify для одного объекта. Блокировка Lock заменяет использование synchronized, а Condition — объектные методы монитора.<br><br>ReadWriteLock — интерфейс создания read/write блокировок, который реализует один единственный класс ReentrantReadWriteLock. Блокировку чтение-запись следует использовать при длительных и частых операциях чтения и редких операциях записи. Тогда при доступе к защищенному ресурсу используются разные методы блокировки, как показано ниже :<br><br>ReadWriteLock rwl = new ReentrantReadWriteLock();<br>Lock  readLock    = rwl.readLock();<br>Lock  writeLock   = rwl.writeLock();</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R37" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">38</div></th><td class="s12">Executors - включает средства, называемые сервисами исполнения, позволяющие управлять потоковыми задачами с возможностью получения результатов через интерфейсы Future и Callable.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R38" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">39</div></th><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">ExecutorService </span><span style="font-size:9pt;font-family:Arial;color:#000000;">служит альтернативой классу Thread, предназначенному для управления потоками. В основу сервиса исполнения положен интерфейс Executor, в котором определен один метод :<br>void execute(Runnable thread);<br>При вызове метода execute исполняется поток thread.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R39" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">40</div></th><td class="s2">Stream API &amp; ForkJoinPool. Как связаны, что это такое.</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">В Stream API есть простой способ распараллеливания потока метедом parallel() или parallelStream(), чтобы получить выигрыш в производительности на многоядерных машинах.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br>По-умолчанию parallel stream используют ForkJoinPool.commonPool. Этот пул создается статически и живет пока не будет вызван System::exit. Если задачам не указывать конкретный пул, то они будут исполняться в рамках commonPool.<br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">По-умолчанию, размер пула равен на 1 меньше, чем количество доступных ядер.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br>Когда некий тред отправляет задачу в common pool, то пул может использовать вызывающий тред (caller-thread) в качестве воркера. ForkJoinPool пытается загрузить своими задачами и вызывающий тред.</span></td><td class="s4">Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта Stream метод parallel(внутри потока). А обратный метод - sequential(). Кроме того, можно также использовать блокирующий метод parallelStream() интерфейса Collection для создания параллельного потока из коллекции. В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный.<br>Работает на фреймворке fork/join(под капотом).Кроме того, можно также использовать метод parallelStream() (над стримами потока) интерфейса Collection для создания параллельного потока из коллекции. - сразу создается параллельнй стрим</td></tr><tr style="height: 20px"><th id="0R40" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">41</div></th><td class="s2" rowspan="8">Java Memory Model</td><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Описывает как потоки должны взаимнодействовать через общую память.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> Определяет набор действий межпоточного взаимодействия. В частности, чтение и запись переменной, захват и освобождений монитора, чтение и запись volatile переменной, запуск нового потока. <br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">JMM определяет отношение между этими действиями &quot;happens-before&quot; - абстракцей обозначающей, что если операция X связана отношением happens-before с операцией Y, то весь код следуемый за операцией Y, выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции X.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br></span></td><td class="s14">Модификатор <span style="font-size:10pt;font-family:Verdana;font-style:italic;color:#000000;">volatile</span><span style="font-size:10pt;font-family:Verdana;color:#000000;"> гарантирует выполнение отношения happens-before, что ведет к тому, что измененное значение этой переменной увидят все потоки.</span></td></tr><tr style="height: 20px"><th id="0R41" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">42</div></th><td class="s9"><span style="font-size:9pt;font-family:Arial;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#000000;">Можно выделить несколько основных областей, имеющих отношение к модели памяти:</span><span style="font-size:9pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#ff0000;">Видимость</span><span style="font-size:9pt;font-family:Arial;color:#ff0000;"> (visibility</span><span style="font-size:9pt;font-family:Arial;color:#000000;">). </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Один поток может временно сохранить значения некоторых полей не в основную память, а в регистры или локальный кэш процессора, </span><span style="font-size:9pt;font-family:Arial;color:#000000;">таким образом второй поток, читая из основной памяти, может не увидеть последних изменений поля. И наоборот, если поток на протяжении какого-то времени работает с регистрами и локальными кэшами, читая данные оттуда, он может сразу не увидеть изменений, сделанных другим потоком в основную память.<br>К вопросу видимости имеют отношение следующие ключевые слов языка Java: synchronized, volatile, final.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R42" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">43</div></th><td class="s9">С точки зрения Java все переменные (за исключением локальных переменных, объявленных внутри метода) хранятся в heap памяти, которая доступна всем потокам. Кроме этого, каждый поток имеет локальную—рабочую—память, где он хранит копии переменных, с которыми он работает, и при выполнении программы поток работает только с этими копиями.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R43" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">44</div></th><td class="s12"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#ff0000;">synchronized</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"> - При входе в synchronized метод или блок поток обновляет содержимое локальной памяти, а при выходе из synchronized метода или блока поток записывает изменения, сделанные в локальной памяти, в главную. </span><span style="font-size:9pt;font-family:Arial;font-weight:normal;color:#000000;">Такое поведение synchronized методов и блоков следует из правил для отношения «происходит раньше»</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R44" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">45</div></th><td class="s12"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#ff0000;">volatile </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">- запись volatile-переменных производится в основную память, минуя локальную. и чтение volatile переменной производится также из основной памяти</span><span style="font-size:9pt;font-family:Arial;font-weight:normal;color:#000000;">, то есть значение переменной не может сохраняться в регистрах или локальной памяти потока и операция чтения этой переменной гарантированно вернёт последнее записанное в неё значение.</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"><br></span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R45" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">46</div></th><td class="s15">final - <span style="font-size:9pt;font-family:Arial;font-weight:normal;color:#000000;">после того как объект был корректно создан, </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">любой поток может видеть значения его final полей без дополнительной синхронизации</span><span style="font-size:9pt;font-family:Arial;font-weight:normal;color:#000000;">. «Корректно создан» означает, что ссылка на создающийся объект не должна использоваться до тех пор, пока не завершился конструктор объекта. <br>Рекомендуется изменять final поля объекта только внутри конструктора, в противном случае поведение не специфицировано.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R46" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">47</div></th><td class="s3"><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#ff0000;">Переупорядочивание </span><span style="font-size:9pt;font-family:Arial;color:#ff0000;">(Reordering)</span><span style="font-size:9pt;font-family:Arial;color:#000000;">. Для увеличения производительности процессор/компилятор </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">могут переставлять местами некоторые инструкции/операции.</span><span style="font-size:9pt;font-family:Arial;color:#000000;"> </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Процессор может решить поменять порядок выполнения операций, если, например, сочтет что такая последовательность выполнится быстрее</span><span style="font-size:9pt;font-family:Arial;color:#000000;">. Эффект может наблюдаться, когда один поток кладет результаты первой операции в регистр или локальный кэш, а результат второй операции попадает непосредственно в основную память. Тогда второй поток, обращаясь к основной памяти может сначала увидеть результат второй операции, и только потом первой, когда все регистры или кэши синхронизируются с основной памятью. <br>Также регулируется набором правил «happens-before»: операции чтения и записи volatile переменных не могут быть переупорядочены с операциями чтения и записи других volatile и не-volatile переменных.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R47" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">48</div></th><td class="s16"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/">https://habr.com/ru/company/golovachcourses/blog/221133/</a></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R48" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">49</div></th><td class="s1"></td><td class="s7"><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">CountDownLatch - </span><span style="font-size:10pt;font-family:Arial;color:#000000;">объект синхронизации потоков, блокирующий один или несколько потоков до тех пор, пока не будут выполнены определенные условия. Количество условий задается счетчиком. При обнулении счетчика, т.е. при выполнении всех условий, блокировки выполняемых потоков будут сняты и они продолжат выполнение кода. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Одноразовый</span><span style="font-size:10pt;font-family:Arial;color:#000000;">.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> CyclicBarrier</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — барьерная синхронизация останавливает поток в определенном месте в ожидании прихода остальных потоков группы. Как только все потоки достигнут барьера, барьер снимается и выполнение потоков продолжается. Как и CountDownLatch, использует счетчик и похож на него. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Отличие связано с тем, барьер можно использовать повторно(в цикле)</span><span style="font-size:10pt;font-family:Arial;color:#000000;">.<br> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Exchanger — </span><span style="font-size:10pt;font-family:Arial;color:#000000;">объект синхронизации, используемый для двустороннего обмена данными между двумя потоками. При обмене данными допускается null значения, что позволяет использовать класс для односторонней передачи объекта или же просто, как синхронизатор двух потоков. Обмен данными выполняется вызовом метода exchange, сопровождаемый самоблокировкой потока. Как только второй поток вызовет метод exchange, то синхронизатор Exchanger выполнит обмен данными между потоками.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Phaser — </span><span style="font-size:10pt;font-family:Arial;color:#000000;">объект синхронизации типа «Барьер», но, в отличие от CyclicBarrier, может иметь несколько барьеров (фаз), и количество участников на каждой фазе может быть разным.</span></td><td class="s1"></td></tr></tbody></table></div>