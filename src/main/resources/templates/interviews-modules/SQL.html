<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="../../../../../../../../Users/Салават/Downloads/SQL/resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s1{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s12{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s0{border-bottom:1px SOLID transparent;border-right:1px SOLID transparent;background-color:#3d85c6;text-align:left;font-weight:bold;color:#ffffff;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s4{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s16{border-bottom:1px SOLID transparent;border-right:1px SOLID transparent;background-color:#ffff00;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s21{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s19{background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s18{background-color:#ffffff;text-align:left;color:#111111;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s6{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s14{border-bottom:1px SOLID transparent;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s5{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s9{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#0000ff;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s13{border-right:1px SOLID transparent;background-color:#c9daf8;text-align:left;font-weight:bold;color:#1c4587;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s17{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#c9daf8;text-align:left;font-weight:bold;color:#1c4587;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s15{border-right:1px SOLID transparent;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s11{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s22{background-color:#ffffff;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s23{background-color:#ffffff;text-align:left;color:#111111;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s2{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#3d85c6;text-align:center;font-weight:bold;color:#ffffff;font-family:Arial;font-size:14pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s8{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s3{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#c9daf8;text-align:center;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s7{background-color:#ffffff;text-align:right;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s10{background-color:#ffffff;text-align:left;color:#111111;font-family:Arial;font-size:12pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s20{background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-origin-ltr"></th><th id="0C0" style="width:159px;" class="column-headers-background">A</th><th id="0C1" style="width:841px;" class="column-headers-background">B</th><th id="0C2" style="width:459px;" class="column-headers-background">C</th><th id="0C3" style="width:100px;" class="column-headers-background">D</th></tr></thead><tbody><tr style="height: 20px"><th id="0R0" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">1</div></th><td class="s0" colspan="2"> </td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R1" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">2</div></th><td class="s2" colspan="2"> SQL</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R2" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">3</div></th><td class="s3">Что такое DDL? Какие операции в него входят? Рассказать про них.</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">DDL</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> (Data Definition Language) -  операторы определения данных (Data Definition Language, DDL):<br>CREATE создает объект БД (базу, таблицу, представление, пользователя и т. д.),<br>ALTER изменяет объект,<br>DROP удаляет объект;<br>TRUNCATE удаляет таблицу и создает её пустую заново, но если в таблице были foreigh key, то создать таблицу не получится. rollback после TRUNCATE невозможен</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R3" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">4</div></th><td class="s3">Что такое DML? Какие операции в него входят? Рассказать про них.</td><td class="s4">операторы манипуляции данными (Data Manipulation Language, DML):<br>SELECT выбирает данные, удовлетворяющие заданным условиям,<br>INSERT добавляет новые данные,<br>UPDATE изменяет существующие данные,<br>DELETE удаляет данные при выполнении условия WHERE;</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R4" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">5</div></th><td class="s3">Что такое TCL? Какие операции в него входят? Рассказать про них.</td><td class="s4">операторы управления транзакциями (Transaction Control Language, TCL):<br>BEGIN служит для определения начала транзакции<br>COMMIT применяет транзакцию,<br>ROLLBACK откатывает все изменения, сделанные в контексте текущей транзакции,<br>SAVEPOINT разбивает транзакцию на более мелкие.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R5" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">6</div></th><td class="s3">Что такое DCL? Какие операции в него входят? Рассказать про них.</td><td class="s4">операторы определения доступа к данным (Data Control Language, DCL):<br>GRANT предоставляет пользователю (группе) разрешения на определенные операции с объектом,<br>REVOKE отзывает ранее выданные разрешения,<br>DENY задает запрет, имеющий приоритет над разрешением;</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R6" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">7</div></th><td class="s3">Нюансы работы с NULL в SQL. Как проверить поле на NULL?</td><td class="s4">NULL - <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">специальное значение</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> (псевдозначение), которое может быть записано в поле таблицы базы данных. NULL соответствует понятию «пустое поле», то есть «поле, не содержащее никакого значения».<br>NULL </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">означает отсутствие</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, неизвестность </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">информации</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Значение NULL не является значением в полном смысле слова: по определению оно означает отсутствие значения и не принадлежит ни одному типу данных. Поэтому NULL не равно ни логическому значению FALSE, ни пустой строке, ни 0. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">При сравнении NULL с любым значением будет получен результат NULL</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, а не FALSE и не 0. Более того, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">NULL не равно NULL</span><span style="font-size:10pt;font-family:Arial;color:#000000;">!<br>команды: IS NULL, IS NOT NULL</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R7" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">8</div></th><td class="s3" rowspan="2">Виды Join’ов?</td><td class="s4">JOIN - оператор языка SQL, который является реализацией операции соединения реляционной алгебры. <br>        <span style="font-size:10pt;font-family:Arial;color:#ff0000;">Предназначен для обеспечения выборки данных из двух таблиц и включения этих данных в один <br>        результирующий набор.<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>        Особенностями операции соединения являются следующее:<br><br>        - в схему таблицы-результата входят столбцы обеих исходных таблиц (таблиц-операндов), <br>        то есть схема результата является «сцеплением» схем операндов;<br>        - каждая строка таблицы-результата является «сцеплением» строки из одной таблицы-операнда со <br>        строкой второй таблицы-операнда;<br>        - при необходимости соединения не двух, а нескольких таблиц, операция соединения применяется <br>        несколько раз (последовательно).</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R8" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">9</div></th><td class="s5">Какие существуют типы JOIN?<br><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">(INNER) JOIN Предполагает что в результирующий запрос попадают только те строки которые являются пересичением двух таблиц, которые по условию прописаны в дерективе ON Результатом объединения таблиц являются записи, общие для левой и правой таблиц. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><br>      </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">  Порядок таблиц для оператора не важен, поскольку оператор является симметричным. Дефолт - INNER<br><br>       </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#ff0000;"> LEFT (OUTER) JOIN Объединение которое предполагает что в результирующий запрос попадают все строки из таблицы A(левой таблицы) и те строки из таблицы B у которых есть пресечения с А недостоищие строки заполняются NULL.</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;">Кортежи из внутреннего соединения, и не вошедшие во внутреннее соединение <br>        кортежи из левого источника. Атрибуты в кортежах, которые не имеют совпадений по общим столбцам<br>        заполняются неопределенными значениями. Порядок таблиц для оператора важен, поскольку оператор <br>        не является симметричным.<br><br>        </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#ff0000;">RIGHT (OUTER) JOIN Объединение которое предполагает что в результирующий запрос попадают все строки из таблицы B(правой таблицы) и те строки из таблицы А у которых есть пресечения с B недостоищие строки заполняются NULL</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"><br><br>        </span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#ff0000;">FULL (OUTER) JOIN Результатом объединения таблиц являются все записи, которые присутствуют в<br>        таблицах. Порядок таблиц для оператора не важен, поскольку оператор является симметричным. Сочетание IINER - LEFT - RIGHT</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#000000;"><br></span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#ff0000;"><br>        CROSS JOIN (декартово произведение) - полное соединение двух таблиц (Все - Со всем) Перекрестное соединение создает декартовое произведение между двумя таблицами, возвращая</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;">все возможные комбинации всех строк</span><span style="font-size:9pt;font-family:Arial;font-weight:bold;color:#ff0000;">. Он не имеет предложения on, потому что вы просто соединяете все со всем. A full outer join представляет собой комбинацию a left outer и right outer join. Он возвращает все строки в обеих таблицах, которые соответствуют запросу where, и в тех случаях, когда условие on не может быть выполнено для этих строк, оно помещает значения null для незапущенных полей.<br>        NATURAL JOIN  - может работать без ON</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><br>      <br>        Обратите внимание, в этом запросе нет необходимости указывать какие-либо критерии объединения,<br>        поскольку предложение NATURAL JOIN автоматически определяет столбцы, имеющие одинаковые имена <br>        в обеих объединяемых таблицах, и помещает их в «скрытое» предложение USING. Если  первичные и <br>        внешние ключи имеют одинаковые имена, этот подход может показаться полезным, однако это не так.     </span></td><td class="s6"></td><td class="s7">ON представляет собой одно или несколько условий JOIN благодаря которым мы можем сопоставлять записи из одной таблицы в другую.Это не оператор - это часть JOIN, которая является частью предложения FROM Он очень похож на предложение WHERE - за исключением того, что он предназначен только для фильтрации объединения двух таблиц (или наборов строк). В этом случае это условие, при котором строки из A и B сопоставляются. Если у вас были те же условия в WHERE, это повлияло бы на соединение - LEFT JOIN (здесь) разрешено находить несоответствующую строку в B но все равно будет вносить эту строку из A в результат (при этом столбцы B равны NULL). Если вы помещаете такое же условие в WHERE, это заставляет соединение стать INNER JOIN вместо LEFT JOIN.                                                                                                                                   NATURAL JOIN  - может работать без ON<br>        SELECT *<br>                FROM actor<br>        NATURAL JOIN film_actor<br>        NATURAL JOIN film</td></tr><tr style="height: 20px"><th id="0R9" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">10</div></th><td class="s3">Что лучше использовать join или подзапросы? Почему?</td><td class="s4">Обычно лучше использовать JOIN, поскольку в большинстве случаев он более понятен и лучше оптимизируется СУБД (но 100% этого гарантировать нельзя). Так же JOIN имеет заметное преимущество над подзапросами в случае, когда список выбора SELECT содержит столбцы более чем из одной таблицы.<br><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Подзапросы лучше использовать в случаях, когда нужно вычислять агрегатные значения и использовать их для сравнений во внешних запросах.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R10" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">11</div></th><td class="s3">Что делает UNION?</td><td class="s4">В языке SQL ключевое слово<span style="font-size:10pt;font-family:Arial;color:#ff0000;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">UNION применяется для объединения результатов двух SQL-запросов в единую таблицу</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">,</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> состоящую из схожих записей. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Оба запроса должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Необходимо отметить, что UNION сам по себе не гарантирует порядок записей. Записи из второго запроса могут оказаться в начале, в конце или вообще перемешаться с записями из первого запроса. В случаях, когда требуется определенный порядок, необходимо использовать ORDER BY.<br>Разница между UNION и UNION ALL заключается в том, что UNION будет пропускать дубликаты записей, тогда как UNION ALL будет включать дубликаты записей.</span></td><td class="s8">SELECT FirstName, LastName FROM Customers UNION SELECT FirstName, LastName FROM Employees</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R11" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">12</div></th><td class="s3">Чем WHERE отличается от HAVING ( ответа про то что используются в разных частях запроса - недостаточно)?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#ff0000;">WHERE нельзя использовать с агрегатными функциями, HAVING можно (предикаты тоже)</span><span style="font-size:10pt;font-family:Arial;color:#000000;">.<br>В HAVING можно использовать псевдонимы только если они используются для наименования результата агрегатной функции, в WHERE можно всегда.<br>HAVING стоит после GROUP BY, но может использоваться и без него. При отсутствии предложения GROUP BY агрегатные функции применяются ко всему выходному набору строк запроса, т.е. в результате мы получим всего одну строку, если выходной набор не пуст.<br></span></td><td class="s8">Во-первых, в HAVING и только в нём можно писать условия по агрегатным функциям (SUM, COUNT, MAX, MIN и т. д.). То есть если вы хотите сделать что-то вроде COUNT(*) &gt; 10, то это возможно сделать только в HAVING. &quot;Почему бы не оставить только HAVING?&quot; - спросите вы. Всё кроется в том, как SQL Server выполняет запрос, в каком порядке происходит его разбор и работа с данными. WHERE выполняется до формирования групп GROUP BY. Это нужно для того, чтобы можно было оперировать как можно меньшим количеством данных и сэкономить ресурсы сервера и время пользователя. Следующим этапом формируются группы, которые указаны в GROUP BY. После того как сформированы группы, можно накладывать условия на результаты агрегатных функций. И тут как раз наступает очередь HAVING: выполняются условия, которые вы задали.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R12" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">13</div></th><td class="s3">Что такое ORDER BY?</td><td class="s4">ORDER BY <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">(сортировка по выбранному столбцу)</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> упорядочивает вывод запроса согласно значениям в том или ином количестве выбранных столбцов.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Многочисленные столбцы упорядочиваются один внутри другого. Возможно определять возрастание ASC или убывание DESC для каждого столбца. По умолчанию установлено - возрастание.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R13" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">14</div></th><td class="s3">Что такое DISTINCT?</td><td class="s4">DISTINCT <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">(исключает дублирование строк)</span><span style="font-size:10pt;font-family:Arial;color:#000000;">  указывает, что </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">для вычислений используются только уникальные значения столбца. После SELECT и перед FROM. </span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R14" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">15</div></th><td class="s3">Что такое GROUP BY?</td><td class="s4">GROUP BY<span style="color:#ff0000;"> </span><span style="font-weight:bold;color:#ff0000;">(группировка данных)</span><span style="color:#ff0000;"> используется для агрегации записей результата по заданным атрибутам.</span><br>Cоздает отдельную группу для всех возможных значений (включая значение NULL)<br>При использовании GROUP BY все значения NULL считаются равными.<br><br><br><br><span style="color:#00ff00;">Объединяет строки с одинаковыми значениями в указанных колонках.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R15" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">16</div></th><td class="s3">Что такое LIMIT?</td><td class="s5">Позволяет ограничить количество выводимых записей. После FROM</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R16" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">17</div></th><td class="s3">Что такое EXISTS?</td><td class="s4">EXISTS берет подзапрос, как аргумент, и оценивает его как TRUE, если подзапрос возвращает какие-либо записи и FALSE, если нет.</td><td class="s8">SELECT DepartmentID, Name FROM HumanResources.Department WHERE EXISTS (SELECT NULL) ORDER BY Name ASC ;</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R17" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">18</div></th><td class="s3">Расскажите про операторы IN, BETWEEN, LIKE.</td><td class="s4">•       <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> IN - определяет наличие данных в масиве.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>SELECT * FROM Persons WHERE name IN (&#39;Ivan&#39;,&#39;Petr&#39;,&#39;Pavel&#39;);<br>•       </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> BETWEEN определяет диапазон значений. В отличие от IN, BETWEEN чувствителен к порядку, и первое значение в предложении должно быть первым по алфавитному или числовому порядку.<br>SELECT * FROM Persons WHERE age BETWEEN 20 AND 25;</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>•        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">LIKE применим только к полям типа CHAR или VARCHAR, с которыми он используется </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">чтобы находить подстроки</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">. В качестве условия используются символы шаблонизации (wildkards) - специальные символы, которые могут соответствовать чему-нибудь: % Любая строка, содержащая ноль или более символов _ (подчеркивание) Любой одиночный символ</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>_ замещает любой одиночный символ. Например, &#39;b_t&#39; будет соответствовать словам &#39;bat&#39; или &#39;bit&#39;, но не будет соответствовать &#39;brat&#39;.<br>% замещает последовательность любого числа символов. Например &#39;%p%t&#39; будет соответствовать словам &#39;put&#39;, &#39;posit&#39;, или &#39;opt&#39;, но не &#39;spite&#39;.<br>SELECT * FROM UNIVERSITY WHERE NAME LIKE &#39;%o&#39;;</span></td><td class="s8">SELECT  * FROM developers <br>          WHERE ID IN (SELECT ID <br>                       FROM developers <br>                       WHERE SALARY &gt; 2000); <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Пример вложенного запроса</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R18" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">19</div></th><td class="s3">Что делает оператор MERGE? Какие у него есть ограничения?</td><td class="s4">MERGE позволяет осуществить слияние данных одной таблицы с данными другой таблицы. При слиянии таблиц проверяется условие, и если оно истинно, то выполняется UPDATE, а если нет - INSERT. При этом изменять поля таблицы в секции UPDATE, по которым идет связывание двух таблиц, нельзя.<br><br><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">MERGE Ships AS t</span><span style="font-size:10pt;font-family:Arial;color:#000000;">  -- таблица, которая будет меняться<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">USING (SELECT запрос ) AS s ON (t.name = s.ship)  </span><span style="font-size:10pt;font-family:Arial;color:#000000;">-- условие слияния</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><br>    THEN UPDATE SET t.launched = s.year </span><span style="font-size:10pt;font-family:Arial;color:#000000;">-- обновление</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><br>WHEN NOT MATCHED </span><span style="font-size:10pt;font-family:Arial;color:#000000;">-- если условие не выполняется</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><br>    THEN INSERT VALUES(s.ship, s.year)</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> -- вставка</span></td><td class="s8"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">MERGE dbo.TestTable AS T_Base</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> --Целевая таблица </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">USING dbo.TestTableDop AS T_Source </span><span style="font-size:10pt;font-family:Arial;color:#000000;">--Таблица источник </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ON (T_Base.ProductId = T_Source.ProductId)</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> --Условие объединения </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">WHEN MATCHED THEN</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> --Если истина (UPDATE) UPDATE SET ProductName = T_Source.ProductName, Summa = T_Source.Summa </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">WHEN NOT MATCHED THEN</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> --Если НЕ истина (INSERT) INSERT (ProductId, ProductName, Summa) VALUES (T_Source.ProductId, T_Source.ProductName, T_Source.Summa) </span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R19" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">20</div></th><td class="s3">Какие агрегатные функции вы знаете?</td><td class="s4">Агрегатных функции - функции, которые берут группы значений и сводят их к одиночному значению.<br>Несколько агрегатных функций:<br>COUNT - производит подсчет записей, удовлетворяющих условию запроса;<br>CONCAT - соединяет строки;<br>SUM - вычисляет арифметическую сумму всех значений колонки;<br>AVG - вычисляет среднее арифметическое всех значений;<br>MAX - определяет наибольшее из всех выбранных значений;<br>MIN - определяет наименьшее из всех выбранных значений.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R20" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">21</div></th><td class="s3">Что такое ограничения (constraints)? Какие вы знаете?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Ограничения - это ключевае слова, которые помогают установить правила размещения данных в базе.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Используются при создании БД.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">NOT NULL</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> указывает, что значение не может быть пустым.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">UNIQUE </span><span style="font-size:10pt;font-family:Arial;color:#000000;">обеспечивает отсутствие дубликатов.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">PRIMARY KEY</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - комбинация NOT NULL и UNIQUE. Помечает каждую запись в базе данных уникальным значением.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">CHECK </span><span style="font-size:10pt;font-family:Arial;color:#000000;">проверяет вписывается ли значение в заданный диапазон ( s_id int CHECK(s_id &gt; 0) )<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">FOREIGN KEY</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> создает связь между двумя таблицами и защищает от действий, которые могут нарушить связи между таблицами. FOREIGN KEY в одной таблице указывает на PRIMARY KEY в другой.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">DEFAULT </span><span style="font-size:10pt;font-family:Arial;color:#000000;">устанавливает значение по умолчанию, если значения не предоствлено (name VARCHAR(20) DEFAULT &#39;noname&#39;).<br><br>Какие отличия между PRIMARY и UNIQUE?<br>По умолчанию PRIMARY создает кластерный индекс на столбце, а UNIQUE - некластерный. PRIMARY не разрешает NULL записей, в то время как UNIQUE разрешает одну (а в некоторых СУБД несколько) NULL запись.<br>Таблица может иметь один PRIMARY KEY и много UNIQUE.<br><br>Может ли значение в столбце, на который наложено ограничение FOREIGN KEY, равняться NULL?<br>Может, если на данный столбец не наложено ограничение NOT NULL.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R21" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">22</div></th><td class="s3">Что такое суррогатные ключи?</td><td class="s4">Суррога́тный ключ — это дополнительное служебное поле, автоматически добавленное к уже имеющимся информационным полям таблицы, предназначение которого — служить первичным ключом.</td><td class="s6">IDENTITY</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R22" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">23</div></th><td class="s3" rowspan="4">Что такое индексы? Какие они бывают?</td><td class="s4">Индекс в базе данных — это специальная структура данных, которая позволяет ускорить поиск информации в таблицах. Можно сравнить его с указателем в книге: он помогает быстро найти нужную страницу, не просматривая всю книгу от начала до конца. Индексы значительно ускоряют операции поиска, сортировки и поиска по диапазону (например, поиск значений между 10 и 20). Однако их создание и поддержка также требуют ресурсов.<br>2. Типы индексов<br>a) Кластеризованный (кластерный) индекс<br><br>    Это индекс, который определяет порядок хранения данных в таблице. То есть строки в таблице физически упорядочены так, как указано в кластеризованном индексе.<br>    В PostgreSQL и MySQL по умолчанию первичный ключ (primary key) создаёт кластеризованный индекс.<br>    Важно: таблица может иметь только один кластеризованный индекс, потому что строки в таблице можно упорядочить только один раз.<br><br>b) Некластеризованный (некластерный) индекс<br><br>    Этот индекс хранится отдельно от данных таблицы. Он указывает на строки данных, но не изменяет их физический порядок.<br>    Это значит, что таблица может иметь несколько некластеризованных индексов. Обычно такие индексы быстрее создаются и занимают меньше места, но поиск по ним может быть немного медленнее, так как требуется дополнительный доступ к данным.<br>    Пример: индекс по полю, которое не является частью первичного ключа.<br><br>c) Уникальный индекс<br><br>    Этот индекс гарантирует, что все значения в индексируемом столбце уникальны.<br>    Он используется для обеспечения целостности данных. Например, уникальный индекс нужен для полей, которые должны содержать уникальные значения, как Email в таблице пользователей.<br>    В PostgreSQL и MySQL создание первичного ключа автоматически создаёт уникальный индекс.<br><br>d) Составной индекс<br><br>    Это индекс, который создаётся по нескольким столбцам (полям) таблицы.<br>    Например, если часто делаются запросы, которые фильтруют данные по полям first_name и last_name, можно создать составной индекс по этим двум полям.<br>    Составные индексы полезны, когда запросы включают в себе несколько столбцов. Однако, если запрос использует только один из этих столбцов, то составной индекс может не дать большого выигрыша в скорости.<br><br>3. Как выглядит B-tree индекс?<br><br>B-tree (сбалансированное дерево) — это самый распространённый тип индекса. Он организует данные в виде дерева, где:<br><br>    Каждый узел может иметь несколько «детей».<br>    Структура дерева сбалансирована, т.е. каждый путь от корня дерева до листа имеет одинаковую длину.<br>    Это даёт быстрый доступ к данным — поиск, вставка и удаление элементов происходят за логарифмическое время, что делает этот индекс очень быстрым для работы с большими объёмами данных.<br><br>Пример: допустим, у вас есть индекс по полю name в таблице пользователей. В B-tree индекс будет устроен так, что имена будут располагаться по порядку, и поиск имени &quot;Иван&quot; будет происходить быстро, так как дерево будет всегда сбалансировано.<br>4. Когда индекс полезен, а когда нет?<br><br>Индекс может быть полезен в следующих случаях:<br><br>    Частые поисковые запросы: если вы часто ищете записи по какому-то полю (например, по полю email в таблице пользователей), то индекс на этом поле ускорит такие запросы.<br>    Поиск по диапазону: если нужно искать данные, которые попадают в определённый диапазон (например, все заказы с ценой от 100 до 200), индекс поможет ускорить поиск.<br>    Сортировка данных: если запросы часто требуют сортировки данных, то индекс может ускорить этот процесс.<br><br>Однако индексы могут быть не полезны (или даже вредны) в следующих случаях:<br><br>    Малое количество данных: если таблица маленькая, то индекс не даст значительного ускорения, а наоборот, будет требовать дополнительных ресурсов для своей поддержки.<br>    Частые операции вставки, обновления или удаления: индексы нужно обновлять при каждой вставке или изменении данных. Если в таблице часто происходят изменения, поддержка индекса может замедлить работу.<br>    Избыточные индексы: если вы создадите слишком много индексов, то это приведёт к избыточному расходу памяти и времени на обновление индексов при изменении данных.</td><td class="s1">Содержит структуры бинарных деревьев</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R23" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">24</div></th><td class="s4">Как создать индекс? b3<br>Индекс можно создать либо с помощью выражения CREATE INDEX:<br>CREATE INDEX index_name ON table_name (column_name)<br>либо указав ограничение целостности в виде уникального UNIQUE или первичного PRIMARY ключа в операторе создания таблицы CREATE TABLE.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R24" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">25</div></th><td class="s4">Имеет ли смысл индексировать данные, имеющие небольшое количество возможных значений?<br>Примерное правило, которым можно руководствоваться при создании индекса - если объем информации (в байтах) НЕ удовлетворяющей условию выборки меньше, чем размер индекса (в байтах) по данному условию выборки, то в общем случае оптимизация приведет к замедлению выборки.Часто выполняем запросы тогда имеет смысл индексировать. <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Но потеряем скорость в UPDATE в INSERT и DELETE</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R25" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">26</div></th><td class="s4">Когда полное сканирование набора данных выгоднее доступа по индексу?<br>Полное сканирование производится многоблочным чтением. Сканирование по индексу - одноблочным. Также, при доступе по индексу сначала идет сканирование самого индекса, а затем чтение блоков из набора данных. Число блоков, которые надо при этом прочитать из набора зависит от фактора кластеризации. <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Если суммарная стоимость всех необходимых одноблочных чтений больше стоимости полного сканирования многоблочным чтением, то полное сканирование выгоднее и оно выбирается оптимизатором.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Таким образом, полное сканирование выбирается при слабой селективности предикатов зароса и/или слабой кластеризации данных, либо в случае очень маленьких наборов данных.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R26" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">27</div></th><td class="s3">Чем TRUNCATE отличается от DELETE?</td><td class="s4">DELETE - оператор DML, удаляет записи из таблицы, которые удовлетворяют условиям WHERE. <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Медленнее, чем TRUNCATE. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Есть возможность восстановить данные.<br>TRUNCATE - DDL оператор, удаляет все строки из таблицы. Нет возможность восстановить данные - сделать ROLLBACK.<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R27" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">28</div></th><td class="s3">Что такое хранимые процедуры? Для чего они нужны?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Хранимая процедура — объект базы данных, представляющий собой набор SQL-инструкций, который хранится на сервере.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Плюс в том что компилируются только 1 раз что увеличивает производительность</span><span style="font-size:10pt;font-family:Arial;color:#000000;">.Хранимые процедуры очень похожи на обыкновенные методы языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения.<br>Хранимые процедуры позволяют повысить производительность, расширяют возможности программирования и поддерживают функции безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее.<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R28" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">29</div></th><td class="s3">Что такое представления (VIEW)? Для чего они нужны?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#000000;">View -</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">(Псевдонимы для запросов SELECT) виртуальная таблица, представляющая данные одной или более таблиц альтернативным образом. Нужны для ограничения доступа к данным и также для сокрытия реализации</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>В действительности представление – всего лишь результат выполнения оператора SELECT, который хранится в структуре памяти, напоминающей SQL таблицу. Они работают в запросах и операторах DML точно также как и основные таблицы, но не содержат никаких собственных данных. Представления значительно расширяют возможности управления данными. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Это способ дать публичный доступ к некоторой (но не всей) информации в таблице.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Представления могут основываться как на таблицах, так и на других представлениях,</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> т.е. могут быть вложенными (до 32 уровней вложенности).</span></td><td class="s8">Материализованные представления  - содержат данные, повышают скорость выполнения запросов, требуют переодического обновления командоый REFRESH  M.V. <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">DROV VIEV </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- удаление представления </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">DROP M.V</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. - удаление м.п.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R29" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">30</div></th><td class="s3">Что такое временные таблицы? Для чего они нужны?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#ff0000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml">Подобные таблицы удобны для каких-то временных промежуточных выборок из нескольких таблиц.</a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml"><br>Создание временной таблицы начинается со знака решетки #. Если используется один</a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml"> знак #, то создается локальная таблица</a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml">, которая </a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml">доступна в течение текущей сессии</a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml">. Ели используются </a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml">два знака ##, то создается глобальная временная таблица(живет пока открыт SQL Management )</a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml">. </a></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml">В отличие от локальной глобальная временная таблица доступна всем открытым сессиям базы данных.</a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml"><br><br>CREATE TABLE #ProductSummary<br>(ProdId INT IDENTITY,<br>ProdName NVARCHAR(20),<br>Price MONEY)</a></span></td><td class="s8">Создавать таблицы с помощиью # не рекомендуется т.к они хранятся в temp и несут нагрузку на систему</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R30" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">31</div></th><td class="s3">Что такое транзакции? Расскажите про принципы ACID.</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Транзакция</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">(совокупность операций над данными как чтения так и записи)</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> это воздействие на базу данных, переводящее её из одного целостного состояния в другое и выражаемое в изменении данных, хранящихся в базе данных.<br><br>ACID-принципы транзакций:<br>•        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Атомарность </span><span style="font-size:10pt;font-family:Arial;color:#000000;">(atomicity)</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> гарантирует, что транзакция будет полностью выполнена или потерпит неудачу</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, где транзакция представляет одну логическую операцию данных. Это означает, что при сбое одной части любой транзакции происходит сбой всей транзакции и состояние базы данных остается неизменным.<br>•        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Согласованность </span><span style="font-size:10pt;font-family:Arial;color:#000000;">(consistency). </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Транзакция, достигающая своего завершения и фиксирующая свои результаты, сохраняет согласованность базы данных</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>•        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Изолированность</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> (isolation). </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на ее результат.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>•        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Долговечность </span><span style="font-size:10pt;font-family:Arial;color:#000000;">(durability). </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Независимо от проблем (к примеру, потеря питания, сбой или ошибки любого рода) изменения, сделанные успешно завершённой транзакцией, должны остаться сохраненными после возвращения системы в работу.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R31" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">32</div></th><td class="s3" rowspan="2">Расскажите про уровни изолированности транзакций.</td><td class="s9"><span style="font-size:11pt;font-family:Arial;font-weight:bold;color:#0000ff;">Read uncommitted</span><span style="font-size:10pt;font-family:Arial;color:#0000ff;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#0000ff;">Уровень, имеющий самую плохую согласованность данных, но самую высокую скорость выполнения транзакций. Название уровня говорит само за себя — каждая транзакция видит незафиксированные изменения другой транзакции (феномен грязного чтения).</span><span style="font-size:10pt;font-family:Arial;color:#0000ff;"> Посмотрим какое влияние оказывают друг на друга такие транзакции. Т2 видит данные другой транзакции, которые еще не были зафиксированы. При откате изменений Т1, данные полученные Т2 окажутся ошибочными.                                                                                                                                                              </span><span style="font-size:11pt;font-family:Arial;font-weight:bold;color:#0000ff;">Read committed</span><span style="font-size:10pt;font-family:Arial;color:#0000ff;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#0000ff;">Для этого уровня параллельно исполняющиеся транзакции видят только зафиксированные изменения из других транзакций. Таким образом, данный уровень обеспечивает защиту от грязного чтения.</span><span style="font-size:10pt;font-family:Arial;color:#0000ff;"> Теперь Т2 видит все, что сделала Т1. Это так называемые феномен неповторяющегося чтения, когда мы видим обновленные и удаленные строки (UPDATE, DELETE), и феномен чтения фантомов, когда мы видим добавленные записи (INSERT).                                           </span><span style="font-size:11pt;font-family:Arial;font-weight:bold;color:#0000ff;">Repeatable read </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#0000ff;">Уровень, позволяющий предотвратить феномен неповторяющегося чтения. Т.е. мы не видим в исполняющейся транзакции измененные и удаленные записи другой транзакцией. Но все еще видим вставленные записи из другой транзакции.</span><span style="font-size:10pt;font-family:Arial;color:#0000ff;"> Чтение фантомов никуда не уходит. В Т1 выполняем запросы INSERT, UPDATE и DELETE. После, в Т2 пытаемся обновить ту же самую строку, которую обновили в Т1. И получаем lock: T2 будет ждать, пока T1 не зафиксирует изменения или не откатится. На самом деле в MySQL отсутствует эффект чтения фантомов для уровня repeatable read. И в PostgreSQL от него тоже избавились для этого уровня. Хотя в классическом представлении этого уровня, мы должны наблюдать этот эффект.                                                                                                                                                                                                  </span><span style="font-size:11pt;font-family:Arial;font-weight:bold;color:#0000ff;">Serializable</span><span style="font-size:10pt;font-family:Arial;color:#0000ff;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#0000ff;">Уровень, при котором транзакции ведут себя как будто ничего более не существует, никакого влияния друг на друга нет. В классическом представлении этот уровень избавляет от эффекта чтения фантомов. </span><span style="font-size:10pt;font-family:Arial;color:#0000ff;">Т2 читаем таблицу accounts, затем Т1 пытаемся обновить данные прочитанные Т2. Получаем lock: мы не можем изменить данные в одной транзакции, прочитанные в другой.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R32" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">33</div></th><td class="s4">При параллельном выполнении транзакций возможны следующие проблемы:<br>Потерянное обновление (lost update) — при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется;(изменения, сделанные одной транзакцией, затираются другой.)<br>«Грязное» чтение (dirty read) — чтение данных, добавленных или измененных транзакцией, которая впоследствии не подтвердится (откатится);<br>Неповторяющееся чтение (non-repeatable read) — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются измененными;<br>Фантомное чтение (phantom reads) — одна транзакция в ходе своего выполнения несколько раз выбирает множество записей по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет записи или изменяет столбцы некоторых записей, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества записей.<br></td><td class="s10">Самую высокую скорость выполнения и самую низкую согласованность имеет уровень <span style="font-size:12pt;font-family:Arial;font-weight:bold;color:#111111;">read uncommitted</span><span style="font-size:12pt;font-family:Arial;color:#111111;">. Самую низкую скорость выполнения и самую высокую согласованность — </span><span style="font-size:12pt;font-family:Arial;font-weight:bold;color:#111111;">serializable</span><span style="font-size:12pt;font-family:Arial;color:#111111;">.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R33" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">34</div></th><td class="s3">Что такое нормализация и денормализация? Расскажите про 3 нормальные формы?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Нормализация</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">это процесс организации, структуризации данных в базе, который обеспечивает большую гибкость базы данных за счет исключения избыточности и несогласованности зависимостей.</span><span style="font-size:10pt;font-family:Arial;"><br></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Целью является уменьшение потенциальной противоречивости хранимой в базе данных информации.</span><span style="font-size:10pt;font-family:Arial;"><br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Денормализация</span><span style="font-size:10pt;font-family:Arial;"> базы данных — </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">намеренное снижение или нарушение форм  нормализации базы данных, обычно — чтобы ускорить чтение из базы за счет добавления избыточных данных. В общем, это процесс, обратный к нормализации.<br>Так происходит потому, что теория нормальных форм не всегда применима на практике.</span><span style="font-size:10pt;font-family:Arial;"><br><br>Каждая нормальная форма включает в себя предыдущую. Типы форм:<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">- Первая нормальная форма (1NF) - значения всех полей атомарны (неделимы), нет множества значений в одном поле.<br>- Вторая нормальная форма (2NF) - все неключевые поля зависят только от ключа целиком, а не от какой-то его части.<br>- Третья нормальная форма (3NF) - все неключевые поля не зависят друг от друга.</span><span style="font-size:10pt;font-family:Arial;"><br>- Нормальная форма Бойса-Кодда, усиленная 3 нормальная форма (BCNF) - когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.<br>- Четвёртая нормальная форма (4NF) - не содержатся независимые группы полей, между которыми существует отношение «многие-ко-многим».<br>- Пятая нормальная форма (5NF) - каждая нетривиальная зависимость соединения в ней определяется потенциальным ключом (ключами) этого отношения.<br>- Доменно-ключевая нормальная форма (DKNF) - каждое наложенное на нее ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данное отношение.<br>- Шестая нормальная форма (6NF) - удовлетворяет всем нетривиальным зависимостям соединения, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. Введена как обобщение пятой нормальной формы для хронологической базы данных.</span></td><td class="s11"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Первая нормальная форма:</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Все атрибуты простые (то есть атомарные и неделимые); Все данные скалярные (то есть положительные); Нет повторяющихся строк (для этого для каждой строки создается первичный ключ)</span><span style="font-size:10pt;font-family:Arial;color:#000000;">.                                                                                                                                                                      </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Вторая нормальная форма:</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Соблюдены условия первой нормальной формы; Каждый неключевой атрибут ссылается на первичный ключ.</span><span style="font-size:10pt;font-family:Arial;color:#000000;">                                                                                                                                                                                                                                      </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Третья нормальная форма:</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> Соблюдены условия второй нормальной группы; Неключевые поля не зависят от других неключевых полей: они могут быть связаны лишь с первичным ключом.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R34" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">35</div></th><td class="s3">Что такое TIMESTAMP?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">DATETIME </span><span style="font-size:10pt;font-family:Arial;color:#000000;">предназначен для хранения целого числа: YYYYMMDDHHMMSS. И это время не зависит от временной зоны настроенной на сервере. Размер: 8 байт<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">TIMESTAMP </span><span style="font-size:10pt;font-family:Arial;color:#000000;">хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича. Тогда была создана Unix. При получении из базы отображается с учётом часового пояса. Размер: 4 байта</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R35" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">36</div></th><td class="s3" rowspan="6">Шардирование БД</td><td class="s4">При большом количестве данных запросы начинают долго выполняться, и сервер начинает не справляться с нагрузкой. <span style="font-size:10pt;font-family:Arial;color:#ff0000;">Одно из решений, что с этими данными делать — это масштабирование базы данных</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Например, шардинг или репликация.           </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Суть Шардинга заключается в разделении БД на отедльные части так чтобы каждую из них можно было вынести на отдельный сервер</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Шардинг бывает вертикальным(партицирование) и горизонтальным.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>У нас есть большая таблица, например, с пользователями. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Вертикальный шардинг - это выделение таблицы или группы таблиц на отдельный сервер. Горизонтальный - это разделение одной таблицы на разные сервера.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Единственное отличие горизонтального масштабирования от вертикального в том, что горизонтальное будет разносить данные по разным инстансам в других базах.</span></td><td class="s8">Репликация - позволяет создать полный думбликат БД. Так вместо 1 сервера у нас будет их несколько</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R36" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">37</div></th><td class="s1"></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R37" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">38</div></th><td class="s8">Есть таблица news<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">, </span><span style="font-size:10pt;font-family:Arial;color:#000000;">в которой есть</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">идентификатор, есть категория, в которой эта новость расположена, есть автор новости...<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Нужно сделать 2 действия над табличкой</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — это поставить у нашего шарда, например, news_1, то, что она будет наследоваться от news.<br>Наследованная таблица будет иметь все колонки родителя, а также она может иметь свои колонки, которые мы дополнительно туда добавим. Там не будет ограничений, индексов и триггеров от родителя — это важно.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">2-ое действие</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — это поставить ограничения. Это будет проверка, что в эту таблицу будут попадать данные только с нужным признаком.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R38" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">39</div></th><td class="s1"></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R39" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">40</div></th><td class="s8">Т.е. только записи с category_id=1 будут попадать в эту таблицу.<br>На базовую таблицу надо добавить правило. Когда мы будем работать с таблицей news, вставка на запись с category_id = 1 должна попасть именно в партицию news_1. Правило называем как хотим.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R40" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">41</div></th><td class="s12"></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R41" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">42</div></th><td class="s3">EXPLAIN</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Когда вы выполняете какой-нибудь запрос, оптимизатор</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> запросов MySQL </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">пытается придумать оптимальный план выполнения этого запроса</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Можно посмотреть этот план используя запрос с ключевым словом EXPLAIN перед оператором SELECT.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">EXPLAIN SELECT * FROM categories</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>После EXPLAIN в запросе вы можете использовать ключевое слово EXTENDED и MySQL покажет вам дополнительную информацию о том, как выполняется запрос. Чтобы увидеть эту информацию, вам нужно сразу после запроса с EXTENDED выполнить запрос SHOW WARNINGS.<br>EXPLAIN </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">EXTENDED </span><span style="font-size:10pt;font-family:Arial;color:#000000;">SELECT City.Name FROM City<br>Затем<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">SHOW WARNINGS</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R42" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">43</div></th><td class="s3">Как сделать запрос из двух баз?</td><td class="s4">Если в запросе таблица указывается с именем базы данных database1.table1, то таблица выбирается из database1, если просто table1, то - из активной базы данных.<br>Надо, чтобы базы были на одном сервере.<br>SELECT t1.*, t2.*<br>FROM database1.table1 AS t1<br>INNER JOIN database2.table2 AS t2 ON t1.field1 = t2.field1</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R43" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">44</div></th><td class="s3">Что быстрее убирает дубликаты distinct или group by?</td><td class="s4"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth">Если нужны уникальные значения - DISTINCT.<br>Если нужно группировать значения - GROUP BY.<br><br>Если задача заключается именно в поиске дубликатов - </a><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth">GROUP BY будет лучше.</a></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R44" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">45</div></th><td class="s3">Механизмы оптимизации запросов в БД</td><td class="s4">Например, добавить индекс по нужной колонке.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R45" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">46</div></th><td class="s3">Что такое «триггер»?</td><td class="s4">Триггер (trigger) — <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">это хранимая процедура, которая не вызывается непосредственно, а исполняется при наступлении определенного события ( вставка, удаление, обновление строки</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> / </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">это хранимая процедура особого типа, исполнение которой обусловлено действием по модификации данных: добавлением, удалением или изменением данных в заданной таблице реляционной базы данных. Триггер запускается сервером автоматически и все производимые им модификации данных рассматриваются как выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Момент запуска триггера определяется с помощью ключевых слов BEFORE (триггер запускается до выполнения связанного с ним события) или AFTER (после события).</span></td><td class="s8">CREATE TRIGGER trigger_name trigger_time trigger_event<br>ON tbl_name FOR EACH ROW trigger_stmt* This source code was highlighted with Source Code Highlighter.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R46" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">47</div></th><td class="s13"></td><td class="s11"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Остальные атрибуты:</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">rollbackFor</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">= Exception.class - если какой-либо метод выбрасывает указанное исключение, контейнер всегда откатывает текущую транзакцию. По умолчанию отлавливает RuntimeException<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">noRollbackFor</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">= Exception.class - указание того, что любое исключение, кроме заданных, должно приводить к откату транзакции.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">rollbackForClassName </span><span style="font-size:10pt;font-family:Arial;color:#000000;">и </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">noRollbackForClassName </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- для задания имен исключений в строковом виде.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">readOnly</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- разрешает только операции чтения.<br>В свойстве </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">transactionManager </span><span style="font-size:10pt;font-family:Arial;color:#000000;">хранится ссылка на менеджер транзакций, определенный в конфигурации Spring.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">timeOut</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- По умолчанию используется таймаут, установленный по умолчанию для базовой транзакционной системы. Сообщает менеджеру tx о продолжительности времени, чтобы дождаться простоя tx, прежде чем принять решение об откате не отвечающих транзакций.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">isolation </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">- </span><span style="font-size:10pt;font-family:Arial;color:#000000;">уровень изолированности транзакций<br><br></span></td><td class="s14"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R47" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">48</div></th><td class="s13"></td><td class="s15"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/">Подробно:</a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/"><br></a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/">Для работы с транзакциями Spring Framework использует AOP-прокси:</a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/"><br>Для включения возможности управления транзакциями нужно разместить аннотацию </a></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/">@EnableTransactionManagement у класса конфигурации @Configuration.<br>Она означает, что классы, помеченные @Transactional, должны быть обернуты аспектом транзакций. Отвечает за регистрацию необходимых компонентов Spring, таких как TransactionInterceptor и советы прокси. </a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/">Регистрируемые компоненты помещают перехватчик в стек вызовов при вызове методов @Transactional. Если мы используем Spring Boot и имеем зависимости spring-data-* или spring-tx, то управление транзакциями будет включено по умолчанию.<br>Пропагейшн работает только если метод вызывает другой метод в другом сервисе. Если метод вызывает другой метод в этом же сервисе, то используется this и вызов проходит мимо прокси. Это ограничение можно обойти при помощи self-injection.</a></span></td><td class="s16"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R48" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">49</div></th><td class="s13"></td><td class="s8">Слой логики(Service) - лучшее место для @Transactional.<br>Помечая @Transactional класс @Service, то все его методы станут транзакционными. Так, при вызове, например, метода save() произойдет примерно следующее:<br><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">1. Вначале мы имеем:</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>❖        класс </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">TransactionInterceptor, у которого вызывается метод invoke(...)</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, внутри которого вызывается метод класса-родителя TransactionAspectSupport: invokeWithinTransaction(...), в рамках которого происходит магия транзакций.<br>❖        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">TransactionManager: решает, создавать ли новый EntityManager и/или транзакцию.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>❖        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">EntityManager proxy: EntityManager - это интерфейс, и то, что внедряется в бин в слое DAO на самом деле не является реализацией EntityManager. В это поле внедряется EntityManager proxy, который будет перехватывать обращение к полю EntityManager и  делегировать выполнение  конкретному EntityManager в рантайме. Обычно EntityManager proxy представлен классом SharedEntityManagerInvocationHandler.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R49" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">50</div></th><td class="s13"></td><td class="s8"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">2. Transaction  Interceptor</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">В TransactionInterceptor отработает код до работы метода save(), в котором будет определено, выполнить ли метод save() в пределах уже существующей транзакции БД или должна стартовать новая отдельная транзакция.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">TransactionInterceptor сам не содержит логики по принятию решения, решение начать новую транзакцию, если это нужно, делегируется TransactionManager.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Грубо говоря, на данном этапе наш метод будет обёрнут в try-catch и будет добавлена логика до его вызова и после:<br>     try {<br>        transaction.begin();         // логика до<br>        service.save();         <br>        transaction.commit();      // логика после<br>      } catch(Exception ex) {<br>       transaction.rollback();<br>       throw ex;<br>      }</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R50" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">51</div></th><td class="s13"></td><td class="s8"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">3. TransactionManager</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Менеджер транзакций должен предоставить ответ на два вопроса:<br>❖        Должен ли создаться новый EntityManager?<br>❖        Должна ли стартовать новая транзакция БД?<br>Решение принимается, основываясь на следующих фактах:<br>❖        выполняется ли хоть одна транзакция в текущий момент или нет;<br>❖        атрибута «propagation» в @Transactional.<br>Если TransactionManager решил создать новую транзакцию, тогда:<br>❖        Создается новый EntityManager;<br>❖        EntityManager «привязывается» к текущему потоку (Thread);<br>❖        «Получается» соединение из пула соединений БД; <br>❖        Соединение «привязывается» к текущему потоку.<br>И EntityManager и это соединение привязываются к текущему потоку, используя  переменные ThreadLocal.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R51" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">52</div></th><td class="s13"></td><td class="s8"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">4. EntityManager proxy</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Когда метод save() слоя Service делает вызов метода save() слоя DAO, внутри которого вызывается, например, entityManager.persist(), то не происходит вызов метода persist() напрямую у EntityManager, записанного в поле класса DAO. Вместо этого метод вызывает EntityManager proxy, который достает текущий EntityManager для нашего потока, и у него вызывается метод persist().<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">5. Отрабатывает DAO-метод save().</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R52" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">53</div></th><td class="s13"></td><td class="s8"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">6. TransactionInterceptor</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Отработает код после работы метода save(), а именно будет принято решение по коммиту/откату транзакции.<br><br>Кроме того, если мы в рамках одного метода сервиса обращаемся не только к методу save(), а к разным методам Service и DAO, то все они буду работать в рамках одной транзакции, которая оборачивает этот метод сервиса.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R53" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">54</div></th><td class="s17"></td><td class="s4">Вся работа происходит через прокси-объекты разных классов. Представим, что у нас в классе сервиса только один метод с аннотацией @Transactional, а остальные нет. Если мы вызовем метод с @Transactional, из которого вызовем метод без @Transactional, то оба будут отработаны в рамках прокси и будут обернуты в нашу транзакционную логику. Однако, если мы вызовем метод без @Transactional, из которого вызовем метод с @Transactional, то они уже не будут работать в рамках прокси и не будут обернуты в нашу транзакционную логику.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R54" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">55</div></th><td class="s17">Расскажите про аннотации @Controller и @RestController. Чем они отличаются? Как вернуть ответ со своим статусом (например 213)?</td><td class="s4">@<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Controller </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- специальный тип класса, обрабатывает HTTP-запросы и часто используется с аннотацией @RequestMapping.<br>@</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">RestController </span><span style="font-size:10pt;font-family:Arial;color:#000000;">ставится на класс-контроллер вместо @Controller. Она указывает, что этот класс оперирует не моделями, а данными. Она состоит из аннотаций @Controller и @ResponseBody. Была введена в Spring 4.0 для упрощения создания RESTful веб-сервисов.<br><br>@</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ResponseBody </span><span style="font-size:10pt;font-family:Arial;color:#000000;">сообщает контроллеру, что возвращаемый объект автоматически сериализуется (используя Jackson message converter) в json или xml и передается обратно в объект HttpResponse.<br><br>ResponseEntity используется для формирования кастомизированного HTTP-ответа с пользовательскими параметрами (заголовки, код статуса и тело ответа). Во всех остальных случаях достаточно использовать @ResponseBody.<br>Если мы хотим использовать ResponseEntity, то просто должны вернуть его из метода, Spring позаботится обо всем остальном.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">return ResponseEntity.status(213);</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R55" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">56</div></th><td class="s17">Что такое ViewResolver?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ViewResolver</span><span style="font-size:10pt;font-family:Arial;color:#000000;">  - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">распознаватель представлений</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">это способ работы с представлениями(html-файлы), который поддерживает их распознавание на основе имени, возвращаемого контроллером.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Spring Framework поставляется с большим количеством реализаций ViewResolver. Например, класс UrlBasedViewResolver поддерживает прямое преобразование логических имен в URL.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">InternalResourceViewResolver — реализация ViewResolver по умолчанию</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, которая позволяет находить представления, которые возвращает контроллер для последующего перехода к ним. Ищет по заданному пути, префиксу, суффиксу и имени.<br>Любым реализациям ViewResolver желательно поддерживать интернационализацию, то есть множество языков.<br>Существует также несколько реализаций для интеграции с различными технологиями представлений, такими как FreeMarker (FreeMarkerViewResolver), Velocity (VelocityViewResolver) и JasperReports (JasperReportsViewResolver).</span></td><td class="s18">При помощи интерфейса <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#111111;">ViewResolver</span><span style="font-size:10pt;font-family:Arial;color:#111111;"> DispatcherServlet определяет, какой Вид нужно использовать на основании полученного имени, возвращаемого контроллером.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R56" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">57</div></th><td class="s17">Чем отличаются Model, ModelMap и ModelAndView?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Model</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Интерфейс, лежит в пакете spring-context. В методах контроллера мы можем<br>использовать объекты Model для того, чтобы складывать туда данные, предназначенные для<br>формирования представлений. Кроме того, в Model мы можем передать даже Map с<br>атрибутами</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Содержимое модели используется для отображения данных во View.<br>Например, если View выводит информацию об объекте Customer, то она может ссылаться к ключам модели, например customerName, customerPhone, и получать значения для этих ключей.<br>Объекты-значения из модели также могут содержать бизнес-логику.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ModelMap - Этот класс наследуется от LinkedHashMap&lt;String, Object&gt; и по сути служит общим<br>контейнером модели для Servlet MVC, но не привязан к нему, и лежит в пакете spring-context.<br>Имеет все преимущества LinkedHashMap плюс несколько удобных методов</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ModelAndView </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Этот класс лежит в пакете spring-webmvc и может одновременно хранить модели и<br>представление, чтобы контроллер мог отдавать их в одном возвращаемом значении. Внутри<br>содержит поле private Object view, куда записывает нужное представление, а также поле private<br>ModelMap model, куда и складывает все атрибуты модели</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">View </span><span style="font-size:10pt;font-family:Arial;color:#000000;">используется для отображения данных приложения пользователю.<br>Spring MVC поддерживает несколько поставщиков View(они называются шаблонизаторы) — JSP, JSF, Thymeleaf, и т.п.<br>Интерфейс View преобразует объекты в обычные сервлеты.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R57" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">58</div></th><td class="s17">Расскажите про паттерн Front Controller, как он реализован в Spring?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Front controller - паттерн, где центральный сервлет, DispatcherServlet, принимает все запросы и распределяет их между контроллерами, обрабатывающими разные URL.</span><span style="font-size:10pt;font-family:Arial;color:#000000;">обеспечивает единую точку входа для всех входящих запросов. Все запросы обрабатываются одним обработчиком – DispatcherServlet с маппингом “/”. Этот обработчик может выполнить аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем распределяет их между контроллерами, обрабатывающими разные URL. Это и есть реализация паттерна Front Controller.<br>Веб-приложение может определять любое количество DispatcherServlet-ов. Каждый из них будет работать в своем собственном пространстве имен, загружая свой собственный дочерний WebApplicationContext с вьюшками, контроллерами и т.д.<br>❖        Один из контекстов будет корневым, а все остальные контексты будут дочерними.<br>❖        Все дочерние контексты могут получить доступ к бинам, определенным в корневом контексте, но не наоборот. <br>❖        Каждый дочерний контекст внутри себя может переопределить бины из корневого контекста</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">.<br>WebApplicationContext </span><span style="font-size:10pt;font-family:Arial;color:#000000;">расширяет ApplicationContext (создаёт и управляет бинами и т.д.), но помимо этого он имеет дополнительный метод getServletContext(), через который у него есть возможность получать доступ</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">к</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">ServletContext-у.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><br>ContextLoaderListener </span><span style="font-size:10pt;font-family:Arial;color:#000000;">создает корневой контекст приложения и будет использоваться всеми дочерними контекстами, созданными всеми DispatcherServlet.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R58" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">59</div></th><td class="s17" rowspan="7">Расскажите про паттерн MVC, как он реализован в Spring?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">MVC — это шаблон проектирования, делящий программу на 3 вида компонентов:</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Model </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— модель отвечает за хранение данных.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">View </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— отвечает за вывод данных на фронтенде.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Controller </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— оперирует моделями и отвечает за обмен данными model с view.<br>Основная цель следования принципам MVC — отделить реализацию бизнес-логики приложения (модели) от ее визуализации (view).<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Spring MVC</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - это веб-фреймворк, основанный на Servlet API, с использованием двух шаблонов проектирования - Front controller и MVC.<br>Spring MVC реализует четкое разделение задач, что позволяет нам легко разрабатывать и тестировать наши приложения. Данные задачи разбиты между разными компонентами: Dispatcher Servlet, Controllers, View Resolvers, Views, Models, ModelAndView, Model and Session Attributes, которые полностью независимы друг от друга, и отвечают только за одно направление. Поэтому MVC дает нам довольно большую гибкость. Он основан на интерфейсах (с предоставленными классами реализации), и мы можем настраивать каждую часть фреймворка с помощью пользовательских интерфейсов.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R59" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">60</div></th><td class="s5">Основные интерфейсы для обработки запросов:</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R60" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">61</div></th><td class="s8"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">DispatcherServlet </span><span style="font-size:10pt;font-family:Arial;color:#000000;">является главным контроллером, который получает запросы и распределяет их между другими контроллерами. @RequestsMapping указывает, какие именно запросы будут обрабатываться в конкретном контроллере. Может быть несколько экземпляров DispatcherServlet, отвечающих за разные задачи (обработка запросов пользовательского интерфейса, REST служб и т.д.). Каждый экземпляр DispatcherServlet имеет собственную конфигурацию WebApplicationContext.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">HandlerMapping</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Выбор класса и его метода, которые должны обработать данный входящий запрос на основе любого внутреннего или внешнего для этого запроса атрибута или состояния.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Controller </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— оперирует моделями и отвечает за обмен данными model с view.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ViewResolver</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Выбор, какое именно View должно быть показано клиенту на основе имени, полученного от контроллера.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R61" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">62</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">View</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Отвечает за возвращение ответа клиенту в виде текстов и изображений. Используются встраиваемые шаблонизаторы (Thymeleaf, FreeMarker и т.д.), так как у Spring нет родных. Некоторые запросы могут идти прямо во View, не заходя в Model, другие проходят через все слои.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">HandlerAdapter</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Помогает DispatcherServlet вызвать и выполнить метод для обработки входящего запроса.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ContextLoaderListener </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- слушатель при старте и завершении корневого класса Spring WebApplicationContext. Основным назначением является связывание жизненного цикла ApplicationContext и ServletContext, а также автоматического создания ApplicationContext. Можно использовать этот класс для доступа к бинам из различных контекстов спринг.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R62" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">63</div></th><td class="s5">Ниже приведена последовательность событий, соответствующая входящему HTTP-запросу:</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R63" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">64</div></th><td class="s12"></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R64" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">65</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">❖        После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет, какой Контроллер (Controller) должен быть вызван, после чего HandlerAdapter, отправляет запрос в нужный метод Контроллера.<br>❖        Контроллер принимает запрос и вызывает соответствующий метод. Вызванный метод формирует данные Model и возвращает их в DispatcherServlet вместе с именем View (как правило имя html-файла).<br>❖        При помощи интерфейса ViewResolver DispatcherServlet определяет, какое View нужно использовать на основании имени, полученного от контроллера.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>➢        если это REST-запрос на сырые данные (JSON/XML), то<br>DispatcherServlet сам его отправляет, минуя ViewResolver;<br>➢        если обычный запрос, то DispatcherServlet отправляет данные Model в виде атрибутов во View - шаблонизаторы Thymeleaf, FreeMarker и т.д., которые сами отправляют ответ.<br> <br>Как видим, все действия происходят через один DispatcherServlet.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R65" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">66</div></th><td class="s17">Что такое АОП? Как реализовано в спринге?</td><td class="s4"><span style="font-weight:bold;color:#3e5656;">Аспектно-ориентированное программирование (АОП) — это парадигма программирования, целью которой является разделениее основного и служебного функционала, служебный функционал записывается в Аспект-классы(в основе Аспект заключается сквозная логика) Примеры Аспекта - логирование, проверка прав, обработка транзакций, обработка исключений, кэширование и т.д. </span><span style="color:#ff0000;">Это достигается путем добавления дополнительного поведения к существующему коду без изменения самого кода.</span><span style="color:#3e5656;"><br></span><span style="font-weight:bold;color:#ff0000;">АОП предоставляет возможность реализации сквозной логики в одном месте - т.е. логики, которая применяется к множеству частей приложения - и обеспечения автоматического применения этой логики по всему приложению.</span><span style="color:#3e5656;"><br></span><span style="font-weight:bold;color:#3e5656;">Аспект </span><span style="color:#3e5656;">в АОП - это модуль или класс, реализующий сквозную функциональность. Аспект изменяет поведение остального кода, применяя совет в точках соединения, определённых некоторым срезом.<br></span><span style="font-weight:bold;color:#3e5656;">Совет </span><span style="color:#3e5656;">(advice) – дополнительная логика — код, который должен быть вызван из точки соединения.<br></span><span style="font-weight:bold;color:#3e5656;">Точка соединения</span><span style="color:#3e5656;"> (join point) — место в выполняемой программе (вызов метода, создание объекта, обращение к переменной), где следует применить совет;<br></span><span style="font-weight:bold;color:#3e5656;">Срез </span><span style="color:#3e5656;">(pointcut) — набор точек соединения.<br></span><span style="font-weight:bold;color:#3e5656;">Подход Spring к АОП заключается в создании &quot;динамических прокси&quot; для целевых объектов и &quot;привязывании&quot; объектов к конфигурированному совету для выполнения сквозной логики.<br></span><span style="color:#3e5656;">Есть два варианта создания прокси-класса:<br>1. либо он должен наследоваться от оригинального класса (</span><span style="font-weight:bold;color:#3e5656;">CGLIB</span><span style="color:#3e5656;">) и переопределять его методы, добавляя нужную логику;<br>2. либо он должен имплементировать те же самые интерфейсы, что и первый класс (</span><span style="font-weight:bold;color:#3e5656;">Dynamic Proxy</span><span style="color:#3e5656;">).</span></td><td class="s8"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Прокси</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — это класс-декорация над бином. Например, мы хотим добавить логику нашему бину, но джава-код уже скомпилирован, поэтому нам нужно на лету сгенерировать новый класс. Этим классом мы должны заменить оригинальный класс так, чтобы никто не заметил подмены. Есть два варианта создания этого класса: 1. либо он должен наследоваться от оригинального класса (CGLIB) и переопределять его методы, добавляя нужную логику; 2. либо он должен имплементировать те же самые интерфейсы, что и первый класс (Dynamic Proxy). По конвенции спринга, если какой-то из BeanPostProcessor-ов меняет что-то в классе, то он должен это делать на этапе postProcessAfterInitialization(). Таким образом мы уверены, что initMethod у данного бина, работает на оригинальный метод, до того, как на него накрутился прокси.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R66" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">67</div></th><td class="s17" rowspan="4">В чем разница между Filters, Listeners and Interceptors?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Filter выполняет задачи фильтрации либо по пути запроса к ресурсу, либо по пути ответа от ресурса, либо в обоих направлениях.(Это интерфейс из пакета javax.servlet)</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Фильтры выполняют фильтрацию в методе doFilter. Каждый фильтр имеет доступ к объекту FilterConfig, из которого он может получить параметры инициализации, и ссылку на ServletContext. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Фильтры настраиваются в дескрипторе развертывания веб-приложения.<br>При создании цепочки фильтров, веб-сервер решает, какой фильтр вызывать первым, в соответствии с порядком регистрации фильтров.<br>Когда вызывается метод doFilter(ServletRequest request, ServletResponse response,<br>FilterChain chain) первого фильтра, веб-сервер создает объект FilterChain, представляющий цепочку фильтров, и передаёт её в метод.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Зависят от контейнера сервлетов. Могут работать с js, css.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R67" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">68</div></th><td class="s8"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Interceptor </span><span style="font-size:10pt;font-family:Arial;color:#000000;">являются аналогом Filter в Spring. Перехватить запрос клиента можно в трех местах: preHandle, postHandle и afterCompletion.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Перехватчики работают с HandlerMapping и поэтому должны реализовывать интерфейс HandlerInterceptor</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> или наследоваться от готового класса HandlerInterceptorAdapter, после чего переопределить указанные методы.<br>Чтобы добавить наши перехватчики в конфигурацию Spring, нам нужно переопределить метод addInterceptors () внутри класса, который реализует WebMvcConfigurer.<br>Interceptor основан на механизме Reflection, а фильтр основан на обратном вызове функции.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R68" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">69</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">preHandle </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— метод используется для обработки запросов, которые еще не были переданы в метод контроллера. Должен вернуть true для передачи следующему перехватчику или в handler method. False укажет на обработку запроса самим обработчиком и отсутствию необходимости передавать его дальше. Метод имеет возможность выкидывать исключения и пересылать ошибки к представлению.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">postHandle </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— вызывается после handler method, но до обработки DispatcherServlet для передачи представлению. Может использоваться для добавления параметров в объект ModelAndView. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Вы можете<br>добавить больше объектов модели в представление, но вы не можете изменить<br>HttpServletResponse, так как он уже зафиксирован.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">afterCompletion </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— вызывается после отрисовки представления.</span></td><td class="s8"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">public boolean preHandle</span><span style="font-size:10pt;font-family:Arial;color:#000000;">(HttpServletRequest request, HttpServletResponse response,<br>Object handler) </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">public void postHandle</span><span style="font-size:10pt;font-family:Arial;color:#000000;">(HttpServletRequest request, HttpServletResponse response, Object<br>handler, ModelAndView modelAndView) </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">public void afterCompletion</span><span style="font-size:10pt;font-family:Arial;color:#000000;">(HttpServletRequest request, HttpServletResponse response,<br>Object handler, Exception ex)  Следует знать, что HandlerInterceptor связан с бином DefaultAnnotationHandlerMapping,<br>который отвечает за применение перехватчиков к любому классу, помеченному аннотацией<br>@Controller.<br></span></td><td class="s11">Filter vs. Interceptor ❖ Перехватчик основан на механизме Reflection, а фильтр основан на обратном вызове функции. ❖ Фильтр зависит от контейнера сервлета, тогда как перехватчик не зависит от него. ❖ Перехватчики могут работать только с запросами к контроллерам, в то время как фильтры могут работать почти со всеми запросами (например, js, .css и т.д.). ❖ Перехватчики в отличии от фильтров могут обращаться к объектам в контейнере Spring, что даёт им более изощренный функционал</td></tr><tr style="height: 20px"><th id="0R69" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">70</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Listener </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">это класс, имплементирующий интерфейс ServletContextListener с аннотацией @WebListener. Listener ждет когда произойдет указанное событие, затем «перехватывает» событие и запускает собственное событие.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Он инициализируется только один раз при запуске веб-приложения и уничтожается при остановке веб-приложения. Все ServletContextListeners уведомляются об инициализации контекста до инициализации любых фильтров или сервлетов в вебприложении и об уничтожении контекста после того, как все сервлеты и фильтры уничтожены</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">.Основным назначением является связывание жизненного цикла ApplicationContext и ServletContext, а также автоматического создания ApplicationContext.</span></td><td class="s19">Концептуально всё просто, фильтры сервлетов могут перехватывать только HTTPServlets. Listeners могут перехватывать специфические события. Как перехватить события которые относятся ни к тем не другим? Фильтры и перехватчики делают по сути одно и тоже: они перехватывают какое-то событие, и делают что-то до или после. Java EE использует термин Filter, Spring называет их Interceptors. Именно здесь AOP используется в полную силу, благодаря чему возможно перехватывание вызовов любых объектов</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R70" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">71</div></th><td class="s17">Можно ли передать в запросе один и тот же параметр несколько раз? Как?</td><td class="s4">Да, можно принять все значения, используя массив в методе контроллера:<br><br>http://localhost:8080/login?name=Ranga&amp;name=Ravi&amp;name=Sathish<br>public String method(@RequestParam(value=&quot;name&quot;) <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">String[] names</span><span style="font-size:10pt;font-family:Arial;color:#000000;">){...}<br><br>http://localhost:8080/api/foos?id=1,2,3<br>public String getFoos(@RequestParam </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">List&lt;String&gt; id</span><span style="font-size:10pt;font-family:Arial;color:#000000;">){...}</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R71" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">72</div></th><td class="s17" rowspan="5">Как работает Spring Security? Как сконфигурировать? Какие интерфейсы используются?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">В кратце</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, основными блоками Spring Security являются:<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">SecurityContextHolder</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, чтобы обеспечить доступ к SecurityContext.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">SecurityContext</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, содержит объект Authentication и в случае необходимости информацию системы безопасности, связанную с запросом.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Authentication</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> представляет принципала с точки зрения Spring Security.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">GrantedAuthority</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> отражает разрешения выданные доверителю в масштабе всего приложения.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">UserDetails</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> предоставляет необходимую информацию для построения объекта Authentication из DAO объектов приложения или других источника данных системы безопасности.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">UserDetailsService</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, чтобы создать UserDetails, когда передано имя пользователя в виде String (или идентификатор сертификата или что-то подобное).<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Подробно</span><span style="font-size:10pt;font-family:Arial;color:#000000;">:</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R72" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">73</div></th><td class="s8">Самым фундаментальным явлется <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">SecurityContextHolder</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. В нем мы храним информацию о текущем контексте безопасности приложения, который включает в себя подробную информацию о пользователе, работающем с приложением. По умолчанию SecurityContextHolder использует </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">MODE_THREADLOCAL </span><span style="font-size:10pt;font-family:Arial;color:#000000;">для хранения такой информации, что означает, что контекст безопасности всегда доступен для методов исполняющихся в том же самом потоке, даже если контекст безопасности явно не передается в качестве аргумента этих методов:<br><br>SecurityContextHolder.getContext().getAuthentication().getPrincipal();<br>UserDetails выступает в качестве принципала.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R73" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">74</div></th><td class="s8"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">MODE_GLOBAL </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- все потоки Java-машины используют один контекст безопасности.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">MODE_INHERITABLETHREADLOCAL </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- потоки порожденные от одного защищенного потока, наличие аналогичной безопасности.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R74" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">75</div></th><td class="s8">Интерфейс <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">UserDetailsService </span><span style="font-size:10pt;font-family:Arial;color:#000000;">-</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">подход к загрузке информации о пользователе в Spring Security. Единственный метод этого интерфейса принимает имя пользователя в виде String и возвращает </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">UserDetails.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Он представляет собой принципала, но в расширенном виде и с учетом специфики приложения.<br>В случае успешной аутентификации, UserDetails используется для создания Authentication объекта, который хранится в SecurityContextHolder.<br>Ещё одним важным методом Authentication явлется getAuthorities() - предоставляет массив объектов GrantedAuthority(роли).<br>Credentials - под ними понимаются пароль пользователя, но им может быть и отпечаток пальца, фото сетчатки и т.п.</span></td><td class="s20">AuthenticationManager - основной стратегический интерфейс для аутентификации.ProviderManager, который содержит поле private List&lt;AuthenticationProvider&gt;.AuthenticationProvider - интерфейс объекта, выполняющего аутентификацию. Имеет<br>массу готовых реализаций. Т<br>providers со списком AuthenticationProvider-ов и итерирует запрос аутентификации по этому<br>списку AuthenticationProvider-ов.<br><br>https://habr.com/ru/company/otus/blog/453664/</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R75" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">76</div></th><td class="s21">❖ Пользователь вводит в форму и отправляет логин и пароль. ❖ UsernamePasswordAuthenticationFilter создает объект Authentication - UsernamePasswordAuthenticationToken, где в качестве Principal - логин, а в качестве Credentials - пароль. ❖ Затем UsernamePasswordAuthenticationToken передаёт объект Authentication с логином и паролем AuthenticationManager-у. ❖ AuthenticationManager в виде конкретного класса ProviderManager внутри своего списка объектов AuthenticationProvider, имеющих разные логики аутентификации, пытается аутентифицировать посетителя, вызывая его метод authenticate(). У каждого AuthenticationProvider-а: ➢ Метод authenticate() принимает в качестве аргумента незаполненный объект Authentication, например только с логином и паролем, полученными в форме логина на сайте. Затем с помощью UserDetailsService метод идёт в БД и ищет такого пользователя. ➢ Если такой пользователь есть в БД, AuthenticationProvider получает его из базы в виде объекта UserDetails. Объект Authentication заполняется данными из UserDetails - в него включаются Authorities, а в Principal записывается сам объект UserDetails, содержащий пользователя. ➢ Затем этот метод возвращает заполненный объект Authentication (прошли аутентификацию). Вызывается AuthenticationSuccessHandler. ➢ Если логин либо пароль неверные, то выбрасывается исключение. Вызывается AuthenticationFailureHandler. ❖ Затем этот объект Authentication передается в AccessDecisionManager и получаем решение на получение доступа к запрашиваемой странице (проходим авторизацию).</td><td class="s19">PasswordEncoder - интерфейс для шифрования/расшифровывания паролей. Одна из популярных реализаций - BCryptPasswordEncoder.                                                                   В случае, если нам необходимо добавить логику при успешной/неудачной аутентификации, мы можем создать класс и имплементировать интерфейсы AuthenticationSuccessHandler и AuthenticationFailureHandler соответственно, переопределив их методы.</td><td class="s8">Процесс аутентификации: 1. UsernamePasswordAuthenticationFilter получают имя пользователя и пароль и создает экземпляр класса UsernamePasswordAuthenticationToken (экземпляр интерфейса Authentication). 2. Токен передается экземпляру AuthenticationManager для проверки. 3. AuthenticationManager возвращает полностью заполненный экземпляр Authentication в случае успешной аутентификации. 4. Устанавливается контекст безопасности путем вызова SecurityContextHolder.getContext().setAuthentication(...), куда передается вернувшийся экземпляр Authentication. 5. При успешной аутентификации можно использовать successHandler</td></tr><tr style="height: 20px"><th id="0R76" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">77</div></th><td class="s17" rowspan="17">Что такое SpringBoot? Какие у него преимущества? Как конфигурируется? Подробно.</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Spring Boot - это модуль Spring-а, который предоставля</span><span style="font-size:10pt;font-family:Arial;color:#000000;">ет функцию RAD для среды Spring (Rapid Application Development - </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Быстрая разработка приложений</span><span style="font-size:10pt;font-family:Arial;color:#000000;">). Он обеспечивает более простой и быстрый способ настройки и запуска как обычных, так и веб-приложений. Он просматривает наши пути к классам и настроенные нами бины, делает разумные предположения о том, чего нам не хватает, и добавляет эти элементы.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Ключевые особенности и преимущества Spring Boot:</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R77" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">78</div></th><td class="s19">1. Простота управления зависимостями (spring-boot-starter-* в pom.xml).</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R78" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">79</div></th><td class="s8">Чтобы ускорить процесс управления зависимостями Spring Boot неявно упаковывает необходимые сторонние зависимости для каждого типа приложения на основе Spring и предоставляет их разработчику в виде так называемых starter-пакетов.<br>Starter-пакеты представляют собой набор удобных дескрипторов зависимостей, которые можно включить в свое приложение. Это позволяет получить универсальное решение для всех технологий, связанных со Spring, избавляя программиста от лишнего поиска необходимых зависимостей, библиотек и решения вопросов, связанных с конфликтом версий различных библиотек.<br>Например, если вы хотите начать использовать Spring Data JPA для доступа к базе данных, просто включите в свой проект зависимость spring-boot-starter-data-jpa.<br>Starter-пакеты можно создавать и свои.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R79" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">80</div></th><td class="s19">2. Автоматическая конфигурация.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R80" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">81</div></th><td class="s8"><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Автоматическая конфигурация включается аннотацией @EnableAutoConfiguration.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> (входит в состав аннотации<br>@SpringBootApplication)<br>После выбора необходимых для приложения starter-пакетов Spring Boot попытается автоматически настроить Spring-приложение на основе выбранных jar-зависимостей, доступных в classpath классов, свойств в application.properties и т.п. Например, если добавим springboot-starter-web, то Spring boot автоматически сконфигурирует такие бины как DispatcherServlet, ResourceHandlers, MessageSource итд<br>Автоматическая конфигурация работает в последнюю очередь, после регистрации пользовательских бинов и всегда отдает им приоритет. Если ваш код уже зарегистрировал бин DataSource — автоконфигурация не будет его переопределять.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R81" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">82</div></th><td class="s19">3. Встроенная поддержка сервера приложений/контейнера сервлетов (Tomcat, Jetty).</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R82" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">83</div></th><td class="s8">Каждое Spring Boot web-приложение включает встроенный web-сервер. Не нужно беспокоиться о настройке контейнера сервлетов и развертывания приложения в нем. Теперь приложение может запускаться само как исполняемый .jar-файл с использованием встроенного сервера.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R83" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">84</div></th><td class="s19">4.        Готовые к работе функции, такие как метрики, проверки работоспособности, security и внешняя конфигурация.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R84" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">85</div></th><td class="s19">5.        Инструмент CLI (command-line interface) для разработки и тестирования приложения Spring Boot.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R85" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">86</div></th><td class="s5">6.        Минимизация boilerplate кода (код, который должен быть включен во многих местах практически без изменений), конфигурации XML и аннотаций.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R86" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">87</div></th><td class="s5">Как происходит автоконфигурация в Spring Boot:</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R87" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">88</div></th><td class="s8">1.        Отмечаем main класс аннотацией @SpringBootApplication (аннотация инкапсулирует в себе: @SpringBootConfiguration, @ComponentScan, @EnableAutoConfiguration), таким образом наличие @SpringBootApplication включает сканирование компонентов, автоконфигурацию и показывает разным компонентам Spring (например, интеграционным тестам), что это Spring Boot приложение.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R88" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">89</div></th><td class="s8">2.        @EnableAutoConfiguration         импортирует         класс EnableAutoConfigurationImportSelector. Этот класс не объявляет бины сам, а использует фабрики.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R89" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">90</div></th><td class="s8">3.        Класс EnableAutoConfigurationImportSelector импортирует ВСЕ (более 150) перечисленные в META-INF/spring.factories конфигурации,  Каждая из этих конфигураций пытается сконфигурировать различные аспекты приложения (web, JPA, AMQP и т.д.), регистрируя нужные бины в контекст приложения.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R90" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">91</div></th><td class="s8">4.        Логика при регистрации бинов управляется набором @ConditionalOn* аннотаций. Можно указать, чтобы бин создавался при наличии класса в classpath (@ConditionalOnClass), наличии существующего бина (@ConditionalOnBean), отсуствии бина (@ConditionalOnMissingBean) и т.п. Таким образом наличие конфигурации не значит, что бин будет создан и зачастую конфигурация ничего делать и создавать не будет.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R91" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">92</div></th><td class="s8">5.        Созданный в итоге <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">AnnotationConfig</span><span style="font-size:10pt;font-family:Arial;color:#000000;">EmbeddedWeb</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ApplicationContext</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> ищет в том же DI контейнере фабрику для запуска embedded servlet container.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R92" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">93</div></th><td class="s4">6.        Servlet container запускается, приложение готово к работе</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R93" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">94</div></th><td class="s17">Расскажите про нововведения Spring 5.</td><td class="s4">●        Используется JDK 8+ (Optional, CompletableFuture, Time API, java.util.function, default methods)<br>●        Поддержка Java 9 (Automatic-Module-Name in 5.0, module-info in 6.0+, ASM 6)<br>●        Поддержка HTTP/2 (TLS, Push), NIO/NIO.2<br>●        Поддержка Kotlin<br>●        Реактивность (веб-инфраструктура с реактивным стеком, «Spring WebFlux»)<br>●        Null-safety аннотации(@Nullable), новая документация<br>●        Совместимость с Java EE 8 (Servlet 4.0, Bean Validation 2.0, JPA 2.2, JSON Binding API 1.0)<br>●        Поддержка JUnit 5 + Testing Improvements (conditional and concurrent)<br>●        Удалена поддержка: Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R94" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">95</div></th><td class="s17"> Расскажите про аннотацию @ComponentScan</td><td class="s8"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Аннотация @ComponentScan используется вместе с аннотацией @Configuration для указания пакетов, которые мы хотим сканировать на наличие компонентов, из которых нужно сделать бины.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@ComponentScan без аргументов указывает Spring по умолчанию сканировать текущий пакет и все его подпакеты.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Текущий пакет - тот, в котором находится файл конфигурации с этой самой аннотацией @ComponentScan. В данном случае в контейнер попадут: ❖ бин конфигурационного класса; ❖ бины, объявленные в конфигурационном классе с помощью @Bean; ❖ все бины из пакета и его подпакетов. Аннотация @SpringBootApplication включает в себя аннотации @ComponentScan, @SpringBootConfiguration и @EnableAutoConfiguration, но это не мешает разместить её ещё раз отдельно для указания конкретного пакета. Если указать @ComponentScan с атрибутом basePackages, то это изменит пакет по умолчанию на указанный</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R95" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">96</div></th><td class="s1"></td><td class="s19">Java Servlet API — стандартизированный API, предназначенный для реализации на сервере и работе с клиентом по схеме запрос-ответ. Сервлет — это класс, который умеет получать запросы от клиента и возвращать ему ответы. Да, сервлеты в Java — именно те элементы, с помощью которых строится клиент-серверная архитектура.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R96" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">97</div></th><td class="s22">Что делает аннотация @RequestMapping?</td><td class="s23"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#111111;">Используется только для указания URI до класса-контроллера.</span><span style="font-size:10pt;font-family:Arial;color:#111111;"> @RestController<br>@RequestMapping(&quot;/api/coupon&quot;)</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R97" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">98</div></th><td class="s22">Аннотация @RequestParam?</td><td class="s8"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Эта аннотация используется для того, чтобы методы обработчики могли получить параметры из http-запроса. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Запрос с параметрами: http://localhost:8080/getByName/name=Ivan. Следующий код поместит в переменную name строку Ivan.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R98" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">99</div></th><td class="s22">Аннотация @PathVariable?</td><td class="s8">Эта <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">аннотация получает определенную часть из URI</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. URI: http://localhost:8080/getById/23 Следующий код поместит в переменную id значение 23.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R99" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">100</div></th><td class="s22">@RequestBody?</td><td class="s8">@RequestBody, Spring на лету попытается преобразовать содержимое тела входящего запроса в ваш объект параметра.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R100" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">101</div></th><td class="s22">Аннотация @ResponseStatus?</td><td class="s23">Она позволяет устанавливать код ответа. Обычно Spring сам устанавливает нужный код ответа, но бывают моменты, когда это нужно переопределить.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R101" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">102</div></th><td class="s22">RestTemplate? Какие у него преимущества?</td><td class="s8">RestTemplate это специальный клиент в Spring для отправки http-запросов. Он предоставляет удобные API для легкого вызова конечных точек REST’а в одну строку.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R102" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">103</div></th><td class="s22">GET_POST_PUT_DELETE_PATCH</td><td class="s8">@GetMapping — Обрабатывает get-запросы(чтение) @PostMapping — Обрабатывает post-запросы (создание)@DeleteMapping — Обрабатывает delete-запросы @PutMapping — Обрабатывает put-запросы(обновление) @PatchMapping — Обрабатывает patch-запросы</td><td class="s8">PUT — изначально существовавший в стандарте метод, предполагающий полную замену изменяемого объекта. Соответственно в методе PUT, как я и писал выше, придётся указать даже те атрибуты объекта, которые не меняются.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R103" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">104</div></th><td class="s22">@GetMapping</td><td class="s8">Аннотация @GetMapping — это просто аннотация которая содержит @RequestMapping(method = RequestMethod.GET). Она также позволяет более глубоко настроить метод-обработчик. Ее параметры(они конвертируются в аналогичные параметры @RequestMapping):<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> path — URI, headers — заголовки, name — имя обработчика params — параметры , produces — тип возвращаемых данных(JSON, XML, текст). Используется в REST, consumes — тип принимаемых данных. Используется в REST</span></td><td class="s1">@ApiOperation — описывает метод контроллера</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R104" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">105</div></th><td class="s22">Что обозначают разные коды для http-ответов?</td><td class="s8">GET — 200 OK POST — 200 OK, 201 Created, 204 No Content PUT — 200 OK, 201 Created, 204 No Content DELETE — 204 No Content, 202 Accepted</td><td class="s1"></td><td class="s1"></td></tr></tbody></table></div>