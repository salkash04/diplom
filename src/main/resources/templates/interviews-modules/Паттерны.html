<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="../../../../../../../../Users/Салават/Downloads/Паттерны_/resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s11{border-right:none;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s18{background-color:#ffffff;text-align:left;color:#008000;font-family:docs-Consolas,Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s9{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s14{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s12{border-left:none;border-right:none;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s13{background-color:#ffffff;text-align:left;font-weight:bold;color:#333333;font-family:Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s16{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s22{border-right:1px SOLID transparent;background-color:#c9daf8;text-align:left;font-weight:bold;color:#1c4587;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s6{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s25{background-color:#ffffff;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s26{background-color:#ffffff;text-align:left;color:#111111;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s3{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#c9daf8;text-align:center;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s2{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#3d85c6;text-align:center;color:#ffffff;font-family:Arial;font-size:14pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s17{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#ff0000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s1{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s19{border-right:none;background-color:#ffffff;text-align:left;color:#333333;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s8{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#d9d2e9;text-align:center;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s0{border-bottom:1px SOLID transparent;border-right:1px SOLID transparent;background-color:#3d85c6;text-align:left;font-weight:bold;color:#ffffff;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s20{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s5{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#c9daf8;text-align:center;font-weight:bold;color:#00ff00;font-family:Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s4{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s24{background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s15{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;font-weight:bold;color:#ff0000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s23{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#c9daf8;text-align:left;font-weight:bold;color:#1c4587;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s21{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s10{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s7{background-color:#ffffff;text-align:right;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-origin-ltr"></th><th id="0C0" style="width:159px;" class="column-headers-background">A</th><th id="0C1" style="width:841px;" class="column-headers-background">B</th><th id="0C2" style="width:459px;" class="column-headers-background">C</th><th id="0C3" style="width:100px;" class="column-headers-background">D</th></tr></thead><tbody><tr style="height: 20px"><th id="0R0" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">1</div></th><td class="s0" colspan="2"> </td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R1" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">2</div></th><td class="s2" colspan="2">Паттерны</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R2" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">3</div></th><td class="s3">Что такое «шаблон проектирования»?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#000000;">Проверенное и готовое к использованию логическое решение, которе может быть реализовано по-разному в разных языках программирования.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Плюсы</span><span style="font-size:10pt;font-family:Arial;color:#000000;">:<br>снижение сложности разработки за счёт готовых абстракций<br>облегчение коммуникации между разработчиками<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Минусы</span><span style="font-size:10pt;font-family:Arial;color:#000000;">:<br>слепое следование некоторому шаблону может привести к усложнению программы.<br>желание попробовать некоторый шаблон в деле без особых на то оснований.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R3" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">4</div></th><td class="s3">Назовите основные характеристики шаблонов.</td><td class="s4">Имя - все шаблоны имеют уникальное имя, служащее для их идентификации;<br>Назначение данного шаблона;<br>Задача, которую шаблон позволяет решить;<br>Способ решения, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден;<br>Участники - сущности, принимающие участие в решении задачи;<br>Следствия от использования шаблона как результат действий, выполняемых в шаблоне;<br>Реализация - возможный вариант реализации шаблона.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R4" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">5</div></th><td class="s3">Назовите три основные группы паттернов.</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Порождающие - </span><span style="font-size:10pt;font-family:Arial;color:#000000;">отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов без внесения в программу лишних зависимостей.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Структурные - </span><span style="font-size:10pt;font-family:Arial;color:#000000;">отвечают за построение удобных в поддержке иерархий классов<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Поведенческие </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- заботятся об эффективной коммуникации между объектами.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Основные</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - основные строительные блоки, используемые для построения других шаблонов. Например, интерфейс.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R5" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">6</div></th><td class="s5" rowspan="4">Расскажите про паттерн Одиночка (Singleton).</td><td class="s6"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.<br></span><span style="font-size:10pt;font-family:Arial;">Конструктор помечается как private, а для создания нового объекта Singleton использует специальный метод getInstance(). Он либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.<br><br>private static Singleton instance;<br><br>public </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">static </span><span style="font-size:10pt;font-family:Arial;">Singleton getInstance() {<br>       if (instance == null) {<br>           instance = new Singleton();<br>                }<br>       return instance;<br>   }<br>+: можно не создавать множество объектов для ресурсоемких задач, а пользоваться одним<br>- : нарушает принцип единой ответственности, так как его могут использовать множество объектов</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R6" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">7</div></th><td class="s6"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Почему считается антипаттерном?</span><span style="font-size:10pt;font-family:Arial;"><br>-Нельзя тестировать с помощью mock, но можно использовать powerMock.<br>-Нарушает принцип единой ответственности<br>-Нарушает Open/Close принцип, его нельзя расширить</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R7" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">8</div></th><td class="s6"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Можно ли его синхронизировать без synchronized у метода?</span><span style="font-size:10pt;font-family:Arial;"><br>-Можно сделать его Enum (eager). Это статический final класс с константами. JVM загружает final и static классы на этапе компиляции, а значит несколько потоков не могут создать несколько инстансов.<br>-C помощью double checked locking (lazy). Synchronized внутри метода:</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R8" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">9</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;">private static </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">volatile </span><span style="font-size:10pt;font-family:Arial;">Singleton instance;<br>public static Singleton getInstance() {<br>                Singleton localInstance = instance;<br>                if (localInstance == null) {                       // first check<br>                        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">synchronized </span><span style="font-size:10pt;font-family:Arial;">(Singleton.class) {<br>                                localInstance = instance;<br>                                if (localInstance == null) {       // second check<br>                                        instance = localInstance = new Singleton();<br>                                }<br>                        }<br>                }<br>                return localInstance;<br>        }</span></td><td class="s1"></td><td class="s7">ON представляет собой одно или несколько условий JOIN благодаря которым мы можем сопоставлять записи из одной таблицы в другую.Это не оператор - это часть JOIN, которая является частью предложения FROM Он очень похож на предложение WHERE - за исключением того, что он предназначен только для фильтрации объединения двух таблиц (или наборов строк). В этом случае это условие, при котором строки из A и B сопоставляются. Если у вас были те же условия в WHERE, это повлияло бы на соединение - LEFT JOIN (здесь) разрешено находить несоответствующую строку в B но все равно будет вносить эту строку из A в результат (при этом столбцы B равны NULL). Если вы помещаете такое же условие в WHERE, это заставляет соединение стать INNER JOIN вместо LEFT JOIN.                                                                                                                                   NATURAL JOIN  - может работать без ON<br>        SELECT *<br>                FROM actor<br>        NATURAL JOIN film_actor<br>        NATURAL JOIN film</td></tr><tr style="height: 20px"><th id="0R9" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">10</div></th><td class="s3">Расскажите про паттерн Строитель (Builder).</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Порождающий паттерн, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений одного объекта.<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;">Паттерн предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, называемым строителями.<br>Процесс конструирования объекта разбить на отдельные шаги (например, построитьСтены, вставитьДвери). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.<br>Можно пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">директором</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. В этом случае директор будет задавать порядок шагов строительства, а строитель — выполнять их.<br><br>+: Позволяет использовать один и тот же код для создания различных объектов. Изолирует сложный код сборки объектов от его основной бизнес-логики.<br>- : Усложняет код программы из-за введения дополнительных классов.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R10" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">11</div></th><td class="s3">Расскажите про паттерн Фабричный метод (Factory Method).</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Порождающий шаблон проектирования, в котором предоставляет интерфейс для создания объектов в родительском классе,  но позволяет подклассам изменять тип создаваемых объектов.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> подклассы имплементируют общий интерфейс с методом для создания объектов. Переопределенный метод в каждом наследнике возвращает нужный вариант объекта.<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;">Объекты всё равно будут создаваться при помощи new, но делать это будет фабричный метод. Таким образом можно переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта.<br>Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.<br><br>+: Выделяет код производства объектов в одно место, упрощая поддержку кода. Реализует принцип открытости/закрытости.<br>- : Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Пример: у нас есть интерфейс &quot;разработичк&quot; и его реализация в виде классов &quot;разработчиков&quot; но под каждую реализацию нужно создать производителя для этого создаем еще один интерфейс который будет имень всего один фабричный метод.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R11" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">12</div></th><td class="s3">Расскажите про паттерн Абстрактная фабрика (Abstract Factory).</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Порождающий паттерн проектирования, Абстрактная фабрика задаёт интерфейс создания всех доступных типов продуктов, а каждая конкретная реализация фабрики порождает продукты одной из вариаций.<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;">Абстрактная фабрика предлагает выделить общие интерфейсы для отдельных продуктов, составляющих семейства. Так, все вариации кресел получат общий интерфейс Кресло, все диваны реализуют интерфейс Диван и так далее.<br>Далее вы создаёте абстрактную фабрику — общий интерфейс, который содержит </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">фабричные методы</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> создания всех продуктов семейства (например, создатьКресло, создатьДиван и создатьСтолик). Эти операции должны возвращать абстрактные типы продуктов, представленные интерфейсами, которые мы выделили ранее — Кресла, Диваны и Столики.<br><br>+: гарантированно будет создаваться тип одного семейства<br>- : Усложняет код программы из-за введения множества дополнительных классов.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R12" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">13</div></th><td class="s3">Расскажите про паттерн Прототип (Prototype).</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;">Паттерн поручает создание копий самим копируемым объектам. Он вводит общий интерфейс с методом clone для всех объектов, поддерживающих клонирование. Реализация этого метода в разных классах очень схожа. Метод создаёт новый объект текущего класса и копирует в него значения всех полей собственного объекта.</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">интерфейс Cloneable - является реализацией шаблона портотип<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>+: Позволяет клонировать объекты, не привязываясь к их конкретным классам.<br>- : Сложно клонировать составные объекты, имеющие ссылки на другие объекты.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R13" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">14</div></th><td class="s3">Расскажите про паттерн Адаптер (Adapter).</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;">Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.<br>При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого.<br><br>+: Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.<br>- : Усложняет код программы из-за введения дополнительных классов.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R14" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">15</div></th><td class="s5">Расскажите про паттерн Декоратор (Decorator).</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Структурный паттерн проектирования, который позволяет добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».(Надстройка когда уже есть готовый функционал(класс) и мы хотим вызывать этот же функционал но с добавлением своей реализации)<br></span><span style="font-size:10pt;font-family:Arial;">Целевой объект помещается в другой объект-обёртку, который запускает базовое поведение обёрнутого объекта, а затем добавляет к результату что-то своё.<br>Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Адаптер не менят состояния объекта, а декоратор может менять.</span><span style="font-size:10pt;font-family:Arial;"><br><br>+: Большая гибкость, чем у наследования.<br>- : Труднее конфигурировать многократно обёрнутые объекты.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R15" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">16</div></th><td class="s3">Расскажите про паттерн Заместитель (Proxy).</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители, которые перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Заместитель предлагает создать новый класс-дублёр, имеющий тот же интерфейс, что и оригинальный служебный объект. При получении запроса от клиента объект-заместитель сам бы создавал экземпляр служебного объекта, выполняя промежуточную логику, которая выполнялась бы до (или после) вызовов этих же методов в настоящем объекте.<br><br>+: Позволяет контролировать сервисный объект незаметно для клиента.<br>- : Увеличивает время отклика от сервиса.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R16" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">17</div></th><td class="s5">Расскажите про паттерн Итератор (Iterator).</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;">Идея состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс.<br><br>Детали: Создается итератор и интерфейс, который возвращает итератор. В классе, в котором надо будет вызывать итератор, имплементируем интерфейс, возвращающий итератор, а сам итератор делаем там нестатическим вложенным классом, так как он нигде использоваться больше не будет.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R17" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">18</div></th><td class="s3">Расскажите про паттерн Шаблонный метод (Template Method).</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Поведенческий паттерн проектирования,это метод, внутренние блоки которого могут переопределяться подклассами для избежания повторного копирования ( который пошагово определяет алгоритм и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом).<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;">Паттерн предлагает разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и вызывать их в одном шаблонном методе друг за другом. Для описания шагов используется абстрактный класс. Общие шаги можно будет описать прямо в абстрактном класе. Это позволит подклассам переопределять некоторые шаги алгоритма, оставляя без изменений его структуру и остальные шаги, которые для этого подкласса не так важны.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R18" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">19</div></th><td class="s3">Расскажите про паттерн Цепочка обязанностей (Chain of Responsibility).</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Поведенческий паттерн проектирования, позволяет передавать запрос по цепочке потенциальных обработчиков, пока один из них не обработает запрос. Каждый обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи  </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Область применения цепочки обязанностей — всевозможные обработчики событий, последовательные проверки доступа и прочее.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;color:#000000;">Базируется на том, чтобы превратить каждую проверку в отдельный класс с единственным методом выполнения. Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы.<br>Каждый из методов будет иметь ссылку на следующий метод-обработчик, что образует цепь. Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке. Может и не передавать, если проверка в одном из методов не прошла, например.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R19" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">20</div></th><td class="s3">Какие паттерны используются в Spring Framework?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Singleton </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Bean scopes<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Factory </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Bean Factory classes<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Prototype </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Bean scopes<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Adapter </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Spring Web and Spring MVC<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Proxy </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Spring Aspect Oriented Programming support<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Template Method </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- JdbcTemplate, HibernateTemplate etc<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Front Controller </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Spring MVC DispatcherServlet<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">DAO</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - Spring Data Access Object support<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Dependency Injection</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R20" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">21</div></th><td class="s3">Какие паттерны используются в Hibernate?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Domain Model</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> – объектная модель предметной области, включающая в себя как поведение так и данные.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Data Mapper</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> – слой мапперов (Mappers), который передает данные между объектами и базой данных, сохраняя их независимыми друг от друга и себя.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Proxy  </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— применяется для ленивой загрузки.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Factory </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— используется в SessionFactory</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R21" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">22</div></th><td class="s8">Шаблоны GRASP: Low Coupling (низкая связанность) и High Cohesion (высокая сплоченность)</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Low Coupling</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - части системы, которые изменяются вместе, должны находиться близко друг к другу. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Необходимо распределить ответственности между классами так, чтобы обеспечить минимальную связанность.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">High Cohesion</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - если возвести Low Coupling в абсолют, то можно прийти к тому, чтобы разместить всю функциональность в одном единственном классе.</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">классы должны содержать связанную бизнес — логику</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. В таком случае связей не будет вообще, но что-то тут явно не так, ведь в этот класс попадет совершенно несвязанная между собой бизнес-логика. Принцип High Cohesion говорит следующее: части системы, которые изменяются параллельно, должны иметь как можно меньше зависимостей друг на друга.<br><br>Low Coupling и High Cohesion представляют из себя два связанных между собой паттерна, рассматривать которые имеет смысл только вместе. Их суть: </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">система должна состоять из слабо связанных классов, которые содержат связанную бизнес-логику.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Соблюдение этих принципов позволяет удобно переиспользовать созданные классы, не теряя понимания о их зоне ответственности.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R22" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">23</div></th><td class="s8">Расскажите про паттерн Saga</td><td class="s9"><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Сага — это механизм, обеспечивающий согласованность данных в микросервисах без применения распределенных транзакций.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br><br>Для каждой системной команды, которой надо обновлять данные в нескольких сервисах, создается некоторая сага. Сага представляет из себя некоторый «чек-лист», состоящий из последовательных локальных ACID-транзакций, каждая из которых обновляет данные в одном сервисе. Для обработки сбоев применяется компенсирующая транзакция. Такие транзакции выполняются в случае сбоя на всех сервисах, на которых локальные транзакции выполнились успешно.<br><br>Типов транзакций в саге четыре:<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Компенсирующая </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— отменяет изменение, сделанное локальной транзакцией.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Компенсируемая </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— это транзакция, которую необходимо компенсировать (отменить) в случае, если последующие транзакции завершаются неудачей.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Поворотная </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— транзакция, опеределяющая успешность всей саги. Если она выполняется успешно, то сага гарантированно дойдет до конца.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Повторяемая </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— идет после поворотной и гарантированно завершается успехом.</span></td><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Существует два способа координации саг: </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Хореография (Choreography) — каждая транзакция публикует события, которые запускают транзакции в других сервисах.<br>Существует два способа координации саг: Оркестровка (Orchestration) — оркестратор говорит участникам, какие транзакции должны быть запущены.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R23" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">24</div></th><td class="s3">Как мапятся даты (до java 8 и после)?</td><td class="s4">Аннотация <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Temporal</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> до Java 8, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">в которой надо было указать какой тип даты мы хотим использовать.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>В Java 8 и далее аннотацию ставить не нужно. java.time Все классы в новом API неизменяемые (immutable) и, как следствие,<br>потоко-безопасные. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Точность представления времени составляет одну наносекунду,</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>что в миллион раз точнее чем в пакете java.util.</span></td><td class="s11 softmerge"><div class="softmerge-inner" style="width:657px;left:-1px">Тип java.util.Date содержит информацию о дате и времени с точностью до миллисекунд.</div></td><td class="s12"></td></tr><tr style="height: 20px"><th id="0R24" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">25</div></th><td class="s3">Как “смапить” коллекцию примитивов?</td><td class="s4"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@ElementCollection<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;"> @OrderBy<br>Если у нашей сущности есть поле с коллекцией, то мы привыкли ставить над ним аннотации @OneToMany либо @ManyToMany. Но данные аннотации применяются в случае, когда это коллекция других сущностей (entities). </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Если у нашей сущности коллекция не других сущностей, а базовых или встраиваемых (embeddable) типов</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> для этих случаев в JPA имеется специальная аннотация </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@ElementCollection, которая указывается в классе сущности над полем коллекции</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">. Все записи коллекции хранятся в отдельной таблице, то есть в итоге получаем две таблицы: одну для сущности, вторую для коллекции элементов.<br>При добавлении новой строки в коллекцию, она полностью очищается и заполняется заново, так как у элементов нет id. Можно решить с помощью @OrderColumn<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;"> @CollectionTable - позволяет редактировать таблицу с коллекцией, прочитать</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R25" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">26</div></th><td class="s3" rowspan="3">Какие есть виды связей?</td><td class="s4">Существуют 4 типа связей:<br>1. OneToOne - когда один экземпляр Entity может быть связан не больше чем с одним экземпляром другого Entity.<br>2. OneToMany - когда один экземпляр Entity может быть связан с несколькими экземплярами других Entity.<br>3. ManyToOne - обратная связь для OneToMany. Несколько экземпляров Entity могут быть связаны с одним экземпляром другого Entity.<br>4. ManyToMany - экземпляры Entity могут быть связаны с несколькими экземплярами друг друга.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R26" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">27</div></th><td class="s4">Каждую из которых можно разделить ещё на два вида:<br><span style="font-size:10pt;font-family:Arial;font-weight:bold;">1. Bidirectional </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Владеемая сторона в двунаправленных отношениях должна ссылаться на владеющую сторону используя элемент mappedBy аннотаций @OneToOne, @OneToMany, или @ManyToMany. Элемент mappedBy определяет поле в объекте, который является владельцем отношения.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">2. Undirectional</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">В однонаправленных отношениях только одна сущность имеет поле, которое ссылается на вторую сущность. Вторая сущность (сторона) не имеет поля первой сущности и не знает об отношениях. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Элемент mappedBy определяет поле в объекте, который является владельцем отношения.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R27" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">28</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Bidirectional (Двунаправленные отношения) </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— ссылка на связь устанавливается у всех Entity, то есть в случае OneToOne A-B в Entity A есть ссылка на Entity B, в Entity B есть ссылка на Entity A. Entity A считается владельцем этой связи (это важно для случаев каскадного удаления данных, тогда при удалении A также будет удалено B, но не наоборот).<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Undirectional</span><span style="font-size:10pt;font-family:Arial;color:#000000;">- ссылка на связь устанавливается только с одной стороны, то есть в случае OneToOne A-B только у Entity A будет ссылка на Entity B, у Entity B ссылки на A не будет.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R28" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">29</div></th><td class="s3">Что такое владелец связи?</td><td class="s4">В отношениях между двумя сущностями всегда есть одна владеющая сторона, а владеемой может и не быть, если это однонаправленные отношения.<br>По сути, <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">у кого есть внешний ключ на другую сущность - тот и владелец связи</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">То есть, если в таблице одной сущности есть колонка, содержащая внешние ключи от другой сущности, то первая сущность признаётся владельцем связи, вторая сущность - владеемой.<br>В однонаправленных отношениях сторона, которая имеет поле с типом другой сущности, является владельцем этой связи по умолчанию.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R29" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">30</div></th><td class="s3" rowspan="2">Что такое каскады?</td><td class="s6"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml">Каскадирование - это когда мы выполняем какое-то действие с целевой Entity, то же самое действие будет применено к связанной Entity.</a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml"><br>JPA CascadeType:<br>ALL -  гарантируют, что все персистентные события, которые происходят на родительском объекте, будут переданы дочернему объекту.<br>PERSIST -  означает, что операции save () или persist () каскадно передаются связанным объектам.<br>MERGE - означает, что связанные entity объединяются, когда объединяется entity-владелец.</a></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R30" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">31</div></th><td class="s4">REMOVE - удаляет все entity, связанные с удаляемой entity.<br>DETACH - отключает все связанные entity, если происходит «ручное отключение».<br>REFRESH - повторно считывают значение данного экземпляра и связанных сущностей из базы данных при вызове refresh().</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R31" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">32</div></th><td class="s3">Разница между PERSIST и MERGE?</td><td class="s4">persist(entity) следует использовать с совершенно новыми объектами, чтобы добавить их в БД (если объект уже существует в БД, будет выброшено исключение EntityExistsException).<br><br>Но в случае merge(entity) сущность, которая уже управляется в контексте персистентности, будет заменена новой сущностью (обновленной), и копия этой обновленной сущности вернется обратно. Но рекомендуется использовать для уже сохраненных сущностей.</td><td class="s13">orphanRemoval. Директива orphanRemoval объявляет, что связанные экземпляры сущностей должны быть удалены, когда они отсоединены от родителя, или эквивалентно, когда родитель удален</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R32" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">33</div></th><td class="s3">Какие два типа fetch стратегии в JPA вы знаете?</td><td class="s4">1) <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">LAZY </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Hibernate может загружать данные не сразу, а при первом обращении к ним</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, но так как это необязательное требование, то Hibernate имеет право изменить это поведение и загружать их сразу. Это поведение по умолчанию для полей, аннотированных @OneToMany, @ManyToMany и @ElementCollection. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">В объект загружается прокси lazy-поля.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>2) </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">EAGER</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">данные поля будут загруженны немедленно</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Это поведение по умолчанию для полей, аннотированных @Basic, @ManyToOne и @OneToOne.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R33" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">34</div></th><td class="s3">Какие четыре статуса жизненного цикла Entity объекта (Entity Instance’s Life Cycle) вы можете перечислить?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Transient (New) — </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">свежесозданная оператором new() сущность не имеет связи с базой данных</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, не имеет данных в базе данных и не имеет сгенерированных первичных ключей.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- объект создан, сохранён в бд, имеет primary key, управляется JPA<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached </span><span style="font-size:10pt;font-family:Arial;color:#000000;">-объект создан, имеет primary key, не является (или больше не является) частью контекста персистентности (не управляется JPA);<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">-</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> </span><span style="font-size:10pt;font-family:Arial;">объект создан, у</span><span style="font-size:10pt;font-family:Arial;color:#000000;">правляется JPA, будет удален при commit-е и статус станет опять detached</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R34" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">35</div></th><td class="s3">Как влияет операция persist на Entity объекты каждого из четырех статусов?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">new </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ managed, и объект будет сохранен в базу при commit-е транзакции или в результате flush операций<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ операция игнорируется, однако зависимые Entity могут поменять статус на managed, если у них есть аннотации каскадных изменений<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ exception сразу или на этапе commit-а транзакции<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ managed, но только в рамках одной транзакции. </span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R35" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">36</div></th><td class="s3">Как влияет операция remove на Entity объекты каждого из четырех статусов?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">new </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ операция игнорируется, однако зависимые Entity могут поменять статус на removed, если у них есть аннотации каскадных изменений и они имели статус managed<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ removed и запись объект в базе данных будет удалена при commit-е транзакции (также произойдут операции remove для всех каскадно зависимых объектов)<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ exception сразу или на этапе commit-а транзакции<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ операция игнорируется</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R36" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">37</div></th><td class="s3">Как влияет операция merge на Entity объекты каждого из четырех статусов?</td><td class="s14">new → <span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#000000;">будет создана новая managed entity, в которую будут скопированы данные<br>объекта.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed → </span><span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#000000;">операция игнорируется, однако операция merge сработает на<br>каскадно зависимых entity, если их статус не managed.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed → </span><span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#000000;">exception сразу или на этапе commit-а транзакции.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached → </span><span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#000000;">либо данные будут скопированы в существующую БД managed entity<br>с тем же пер</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R37" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">38</div></th><td class="s3">Как влияет операция refresh на Entity объекты каждого из четырех статусов?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ будут восстановлены все изменения из базы данных данного Entity, также произойдет refresh всех каскадно зависимых объектов<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">new</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ exception<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R38" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">39</div></th><td class="s3">Как влияет операция detach на Entity объекты каждого из четырех статусов?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ detached.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">new</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ операция игнорируется<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R39" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">40</div></th><td class="s3" rowspan="2">Для чего нужна аннотация Basic?</td><td class="s4"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@Basic - указывает на простейший тип маппинга данных на колонку таблицы базы данных.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет. Может быть применена к полю любого из следующих типов:<br>1. Примитивы и их обертки.<br>2. java.lang.String<br>3. java.math.BigInteger<br>4. java.math.BigDecimal<br>5. java.util.Date<br>6. java.util.Calendar<br>7. java.sql.Date<br>8. java.sql.Time<br>9. java.sql.Timestamp<br>10. byte[] or Byte[]<br>11. char[] or Character[]<br>12. enums<br>13. любые другие типы, которые реализуют Serializable.<br></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Вообще, аннотацию @Basic можно не ставить, как это и происходит по умолчанию.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R40" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">41</div></th><td class="s4"> Аннотация @Basic определяет 2 атрибута:<br><br>1. optional - boolean (по умолчанию true) - определяет, может ли значение поля или свойства быть null. Игнорируется для примитивных типов. Но если тип поля не примитивного типа, то при попытке сохранения сущности будет выброшено исключение.<br><br>2. fetch - FetchType (по умолчанию EAGER) - определяет, должен ли этот атрибут извлекаться незамедлительно (EAGER) или лениво (LAZY). Однако, это необязательное требование JPA, и провайдерам разрешено незамедлительно загружать данные, даже для которых установлена ленивая загрузка.<br><br>Без аннотации @Basic при получении сущности из БД по умолчанию её поля базового типа загружаются принудительно (EAGER) и значения этих полей могут быть null</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R41" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">42</div></th><td class="s3" rowspan="2">Для чего нужна аннотация Column?</td><td class="s15">Через аннотацию @Column можно явно указать поведение столбца. Если откроете ее реализацию, то увидите, что столбцу можно задавать такие свойства, как уникальность, обновляемость и т.д.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R42" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">43</div></th><td class="s4">@Basic vs @Column:<br>1. Атрибуты @Basic применяются к сущностям JPA, тогда как атрибуты @Column применяются к столбцам базы данных.<br>2. @Basic имеет атрибут optional, который говорит о том, может ли поле объекта быть null или нет; с другой стороны атрибут nullable аннотации @Column указывает, может ли соответствующий столбец в таблице быть null.<br>3. Мы можем использовать @Basic, чтобы указать, что поле должно быть загружено лениво.<br>4. Аннотация @Column позволяет нам указать имя столбца в таблице и ряд других свойств:<br> a. insertable/updatable - можно ли добавлять/изменять данные в колонке, по умолчанию true;<br> b. length - длина, для строковых типов данных, по умолчанию 255.<br>Коротко, в Column (колум) мы задаем constraints (констрейнтс), а в Basic (бейсик) - ФЕТЧ ТАЙП</td><td class="s10">    @Column(name=&quot;STUDENT_NAME&quot;, length=50, nullable=false, unique=false)<br>    private String name;</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R43" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">44</div></th><td class="s3" rowspan="2">Для чего нужна аннотация Access?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#000000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth">Она </a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#ff0000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth">определяет</a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#000000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth"> тип доступа (access type) для класса entity, Mapped Superclass, embeddable или отдельных атрибутов, то есть </a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#ff0000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth">как JPA будет обращаться к атрибутам entity, как к полям класса (FIELD) или как к свойствам класса (PROPERTY), имеющие гетеры (getter) и сетеры (setter).</a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#000000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth"><br><br></a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth">Определяет тип доступа к полям сущности. Для чтения и записи этих полей есть два подхода:<br>1. Field access (доступ по полям). При таком способе аннотации маппинга (Id, Column,...) размещаются над полями, и Hibernate напрямую работает с полями сущности, читая и записывая их.<br>2. Property access (доступ по свойствам). При таком способе аннотации размещаются над методами-геттерами, но никак не над сеттерами. Hibernate использует их и сеттеры для чтения и записи полей сущности. </a></span></td><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Но есть требование - у сущности с property access</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> названия методов должны соответствовать требованиям JavaBeans. Например, если у сущности Customer есть поле с именем firstName, то у этой сущности должны быть определены методы getFirstName и setFirstName для чтения и записи поля firstName.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R44" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">45</div></th><td class="s4">По умолчанию тип доступа определяется местом, в котором находится аннотация @Id. Если она будет над полем - это будет AccessType.FIELD, если над геттером - это AccessType.PROPERTY.<br>Чтобы явно определить тип доступа у сущности, нужно использовать аннотацию @Access, которая может быть указана у сущности, Mapped Superclass и Embeddable class, а также над полями или методами.<br>Поля, унаследованные от суперкласса, имеют тип доступа этого суперкласса.<br>Когда у одной сущности определены разные типы доступа, то нужно использовать аннотацию @Transient для избежания дублирования маппинга.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R45" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">46</div></th><td class="s3">Для чего нужна аннотация @Cacheable?</td><td class="s4"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@Cacheable - необязательная аннотация JPA, используется для указания того, должна ли сущность храниться в кэше второго уровня.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> JPA говорит о пяти значениях shared-cache-mode из persistence.xml, который определяет как будет использоваться second-level cache:<br><br>❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ENABLE_SELECTIVE</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: (дефолтное и рекомендуемое значение):только сущности с аннотацией @Cacheable (равносильно значению по умолчанию @Cacheable(value=true)) будут сохраняться в кэше второго уровня.<br>❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">DISABLE_SELECTIVE</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: все сущности будут сохраняться в кэше второго уровня, за исключением сущностей, помеченных @Cacheable(value=false) как некэшируемые.<br>❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ALL</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: сущности всегда кэшируются, даже если они помечены как некэшируемые.<br>❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">NONE</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: ни одна сущность не кэшируется, даже если помечена как кэшируемая. При данной опции имеет смысл вообще отключить кэш второго уровня.<br>❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">UNSPECIFIED</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: применяются значения по умолчанию для кэша второго уровня, определенные Hibernate. Это эквивалентно тому, что вообще не используется shared-cache-mode, так как Hibernate не включает кэш второго уровня, если используется режим UNSPECIFIED.<br><br>Аннотация @Cacheable размещается над классом сущности. Её действие распространяется на эту сущность и её наследников, если они не определили другое поведение.</span></td><td class="s10">Как и большинство других полностью оснащенных платформ ORM, <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Hibernate имеет концепцию кэша первого уровня.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Это кэш с областью действия сеанса, который гарантирует, что каждый экземпляр сущности загружается только один раз в постоянном контексте. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">С другой стороны, кэш второго уровня имеет область SessionFactory </span><span style="font-size:10pt;font-family:Arial;color:#000000;">-, что означает, что он является общим для всех сеансов, созданных с помощью одной и той же фабрики сеансов. </span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R46" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">47</div></th><td class="s3">Для чего нужна аннотация @Cache?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Это аннотация Hibernate, настраивающая тонкости кэширования объекта в кэше второго уровня Hibernate.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> @Cache принимает три параметра:<br>❖        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">include</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - имеет по умолчанию значение </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">all</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> и означающий кэширование всего объекта. Второе возможное значение - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">non-lazy</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, запрещает кэширование лениво загружаемых объектов. Кэш первого уровня не обращает внимания на эту директиву и всегда кэширует лениво загружаемые объекты.<br>❖        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">region</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - позволяет задать имя региона кэша для хранения сущности. Регион можно представить как разные области кэша, имеющие разные настройки на уровне реализации кэша. Например, можно было бы создать в конфигурации ehcache два региона, один с краткосрочным хранением объектов, другой с долгосрочным и отправлять часто изменяющиеся объекты в первый регион, а все остальные - во второй. Ehcache по умолчанию создает регион для каждой сущности с именем класса этой сущности, соответственно в этом регионе хранятся только эти сущности. К примеру, экземпляры Foo хранятся в Ehcache в кэше с именем “com.baeldung.hibernate.cache.model.Foo”.<br>❖        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">usage</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - задаёт стратегию одновременного доступа к объектам.<br>transactional<br>read-write<br>nonstrict-read-write<br>read-only</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R47" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">48</div></th><td class="s3">Для чего нужны аннотации @Embedded и @Embeddable?</td><td class="s4"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/">@Embeddable - аннотация JPA, размещается над классом для указания того, что класс является встраиваемым в другие классы.<br>@Embedded - аннотация JPA, используется для размещения над полем в классе-сущности для указания того, что мы внедряем встраиваемый класс.</a></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R48" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">49</div></th><td class="s3" rowspan="5">Как смапить составной ключ?</td><td class="s4">Составной первичный ключ, также называемый составным ключом, представляет собой комбинацию из двух или более столбцов для формирования первичного ключа таблицы.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R49" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">50</div></th><td class="s4"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@IdClass</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Допустим, у нас есть таблица с именем Account, и она имеет два столбца - accountNumber и accountType, которые формируют составной ключ. Чтобы обозначить оба этих поля как части составного ключа мы должны создать класс, например, ComplexKey с этими полями.<br><br>Затем нам нужно аннотировать сущность Account аннотацией @IdClass(ComplexKey.class). Мы также должны объявить поля из класса ComplexKey в сущности Account с такими же именами и аннотировать их с помощью @Id.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R50" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">51</div></th><td class="s4">public class ComplexKey implements Serializable {<br>     private String accountNumber;<br>     private String accountType;<br>     // default constructor<br>     public AccountId(String accountNumber, String accountType) {<br>        this.accountNumber = accountNumber;<br>        this.accountType = accountType;<br>     }<br>     // equals() and hashCode()<br>}<br><br>@Entity<br>@IdClass(ComplexKey.class)<br>public class Account {<br>    @Id<br>    private String accountNumber;<br>    @Id<br>    private String accountType;<br>    // other fields, getters and setters<br>}</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R51" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">52</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;"> @EmbeddedId</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Рассмотрим пример, в котором мы должны сохранить некоторую информацию о книге с заголовком и языком в качестве полей первичного ключа. В этом случае класс первичного ключа, BookId, должен быть аннотирован @Embeddable.<br>Затем нам нужно встроить этот класс в сущность Book, используя @EmbeddedId.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R52" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">53</div></th><td class="s4">@Embeddable<br>public class BookId implements Serializable {<br>    private String title;<br>    private String language;<br>    // default constructor<br>    public BookId(String title, String language) {<br>        this.title = title;<br>        this.language = language;<br>    }<br>    // getters, equals() and hashCode() methods<br>}<br>@Entity<br>public class Book {<br>    @EmbeddedId<br>    private BookId bookId;<br>    // constructors, other fields, getters and setters<br>}</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R53" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">54</div></th><td class="s3" rowspan="3">Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Аннотация @Id определяет простой (не составной) первичный ключ</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, состоящий из одного поля. В соответствии с JPA, допустимые типы атрибутов для первичного ключа:<br>1.        примитивные типы и их обертки;<br>2.        строки;<br>3.        BigDecimal и BigInteger;<br>4.        java.util.Date и java.sql.Date.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R54" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">55</div></th><td class="s6">Если мы хотим, чтобы значение первичного ключа генерировалось для нас автоматически, мы можем добавить первичному ключу, отмеченному аннотацией @Id, аннотацию @<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">GeneratedValue</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Аннотация @GeneratedValue предназначена для настройки способа приращения указанного столбца(поля).</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Возможно 4 варианта: <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">AUTO(default) - </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Указывает, что Hibernate должен выбрать подходящую стратегию для конкретной базы данных, учитывая её диалект, так как у разных БД разные способы по умолчанию. Поведение по умолчанию - исходить из типа поля идентификатора. <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">IDENTITY - </span><span style="font-size:10pt;font-family:Arial;color:#000000;">для генерации значения первичного ключа будет использоваться столбец IDENTITY, имеющийся в базе данных. Значения в столбце автоматически увеличиваются вне текущей выполняемой транзакции(на стороне базы, так что этого столбца мы не увидим), что позволяет базе данных генерировать новое значение при каждой операции вставки. В промежутках транзакций сущность будет сохранена.</span></td><td class="s6">С версии Hibernate 5.0 для числовых значений генерация основана на SEQUENCE, и, если БД её не поддерживает, то на TABLE.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R55" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">56</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">SEQUENCE </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- тип генерации, рекомендуемый документацией Hibernate. Для получения значений первичного ключа Hibernate должен использовать имеющиеся в базе данных механизмы генерации последовательных значений (Sequence). В бд можно будет увидеть дополнительную таблицу. Но если наша БД не поддерживает тип SEQUENCE, то Hibernate автоматически переключится на тип TABLE. В промежутках транзакций сущность не будет сохранена, так как хибер возьмет из таблицы id hibernate-sequence и вернётся обратно в приложение.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">SEQUENCE </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">это объект базы данных, который генерирует инкрементные целые числа при каждом последующем запросе. </span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">TABLE </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Hibernate должен получать первичные ключи для сущностей из создаваемой для этих целей таблицы</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, способной содержать именованные сегменты значений для любого количества сущностей. Требует использования пессимистических блокировок, которые помещают все транзакции в последовательный порядок и замедляет работу приложения.</span></td><td class="s16"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R56" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">57</div></th><td class="s3" rowspan="5">Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;"> @JoinColumn используется для указания столбца FOREIGN KEY, используемого при установлении связей между сущностями или коллекциями.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Мы помним, что только сущность-владелец связи может иметь внешние ключи от другой сущности (владеемой). Однако, мы можем указать @JoinColumn как во владеющей таблице, так и во владеемой, но столбец с внешними ключами всё равно появится во владеющей таблице. <br>Особенности использования:</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R57" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">58</div></th><td class="s4">❖        @OneToOne: означает, что появится столбец в таблице сущности-владельца связи, который будет содержать внешний ключ, ссылающийся на первичный ключ владеемой сущности.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R58" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">59</div></th><td class="s4">❖        @OneToMany/@ManyToOne: если не указать на владеемой стороне связи атрибут mappedBy, создается joinTable с ключами обеих таблиц. Но при этом же у владельца создается столбец с внешними ключами.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R59" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">60</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> @JoinColumns</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> используется для группировки нескольких аннотаций @JoinColumn, которые используются при установлении связей между сущностями или коллекциями, у которых составной первичный ключ и требуется несколько колонок для указания внешнего ключа.<br>В каждой аннотации @JoinColumn должны быть указаны элементы name и referencedColumnName.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R60" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">61</div></th><td class="s15"> @JoinTable используется для указания связывающей (сводной, третьей) таблицы между двумя другими таблицами.                                <span style="font-size:10pt;font-family:Arial;font-weight:normal;font-style:italic;color:#ff0000;">@JoinTable(name = &quot;CATALOG&quot;, joinColumns = @JoinColumn(name = &quot;ID_BOOK&quot;), inverseJoinColumns = @JoinColumn(name = &quot;ID_STUDENT&quot;))<br> private Student student;</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R61" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">62</div></th><td class="s3" rowspan="4">Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?</td><td class="s4"> <span style="font-size:10pt;font-family:Arial;color:#ff0000;">@</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">OrderBy указывает порядок, в соответствии с которым должны располагаться элементы коллекций</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">сущностей, базовых или встраиваемых типов </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">при их извлечении из БД. Если в кэше есть нужные данные, то сортировки не будет</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Так как @OrderBy просто добавляет к sql-запросу Order By, а при получении данных из кэша, обращения к бд нет. Эта аннотация может использоваться с аннотациями @ElementCollection, @OneToMany, @ManyToMany.<br>При использовании с коллекциями базовых типов, которые имеют аннотацию </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@ElementCollection, элементы этой коллекции будут отсортированы в натуральном порядке, по значению базовых типов.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R62" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">63</div></th><td class="s17">Если это коллекция встраиваемых типов (@Embeddable), то используя точку (&quot;.&quot;) мы можем сослаться на атрибут внутри встроенного атрибута. <br>Если это коллекция сущностей, то у аннотации @OrderBy можно указать имя поля сущности, по которому сортировать эти самые сущности:<br>Если мы не укажем у @OrderBy параметр, то сущности будут упорядочены по первичному ключу.<br>В случае с сущностями доступ к полю по точке не работает. Попытка использовать вложенное свойство, например @OrderBy (&quot;supervisor.name&quot;) повлечет Runtime Exceprtion.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R63" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">64</div></th><td class="s4"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@OrderColumn создает в таблице столбец с индексами порядка элементов</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, который используется для поддержания постоянного порядка в списке, но этот столбец не считается частью состояния сущности или встраиваемого класса.<br>Hibernate отвечает за поддержание порядка как в базе данных при помощи столбца, так и при получении сущностей и элементов из БД. Hibernate отвечает за обновление порядка при записи в базу данных, чтобы отразить любое добавление, удаление или иное изменение порядка, влияющее на список в таблице.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R64" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">65</div></th><td class="s4"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@OrderBy vs @OrderColumn</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Порядок, указанный в @OrderBy, применяется только в рантайме при выполнении запроса к БД, То есть в контексте персистентности, в то время как при использовании @OrderColumn, порядок сохраняется в отдельном столбце таблицы и поддерживается при каждой вставке/обновлении/удалении элементов.<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R65" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">66</div></th><td class="s3">Для чего нужна аннотация Transient?</td><td class="s4"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@Transient используется для объявления того, какие поля</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> у сущности, встраиваемого класса или Mapped SuperClass </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">не будут сохранены в базе данных.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Persistent fields (постоянные поля) - это поля, значения которых будут по умолчанию сохранены в БД. Ими являются любые не static и не final поля.<br>Transient fields (временные поля):<br>❖        static и final поля сущностей;<br>❖        иные поля, объявленные явно с использованием Java-модификатора transient, либо JPA-аннотации @Transient.<br></span></td><td class="s18">Initial user: User{firstName=&#39;Stefan&#39;, lastName=&#39;Smith&#39;<span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, email=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;ssmith@email.com&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, birthDate=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">1991</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">-</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">07</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">-</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">16</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, login=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;ssmith&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, </span><span style="font-size:11pt;font-family:Consolas,Arial;font-weight:bold;color:#ff0000;">password=&#39;gemma_arterton_4ever_in_my_heart91&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">} Loaded user from file: User{firstName=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;Stefan&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, lastName=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;Smith&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, email=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;ssmith@email.com&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, birthDate=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">1991</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">-</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">07</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">-</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">16</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, login=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;ssmith&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, </span><span style="font-size:11pt;font-family:Consolas,Arial;font-weight:bold;color:#ff0000;">password=&#39;null&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">}</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R66" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">67</div></th><td class="s3" rowspan="4">Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?</td><td class="s4">В порядке от самого ненадежного и быстрого, до самого надежного и медленного:<br>1.        <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">NONE </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— без блокировки.<br>2.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">OPTIMISTIC </span><span style="font-size:10pt;font-family:Arial;color:#000000;">(синоним READ в JPA 1) — оптимистическая  блокировка, которая работает, как описано ниже: если при завершении транзакции кто-то извне изменит поле @Version, то будет сделан RollBack транзакции и будет выброшено OptimisticLockException.<br>3.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">OPTIMISTIC_FORCE_INCREMENT </span><span style="font-size:10pt;font-family:Arial;color:#000000;">(синоним WRITE в JPA 1) — работает по тому же алгоритму, что и LockModeType.OPTIMISTIC за тем исключением, что после commit значение поле Version принудительно увеличивается на 1. В итоге окончательно после каждого коммита поле увеличится на 2(увеличение, которое можно увидеть в Post-Update + принудительное увеличение).<br>4.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">PESSIMISTIC_READ </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— данные блокируются в момент чтения и это гарантирует, что никто в ходе выполнения транзакции не сможет их изменить. Остальные транзакции, тем не менее, смогут параллельно читать эти данные. Использование этой блокировки может вызывать долгое ожидание блокировки или даже выкидывание PessimisticLockException.<br>5.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">PESSIMISTIC_WRITE</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — данные блокируются в момент записи и никто с момента захвата блокировки </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">не может в них писать и не может их читать</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> до окончания транзакции, владеющей блокировкой. Использование этой блокировки может вызывать долгое ожидание блокировки.<br>6.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">PESSIMISTIC_FORCE_INCREMENT </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— ведёт себя как PESSIMISTIC_WRITE, но в конце транзакции увеличивает значение поля @Version, даже если фактически сущность не изменилась.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Блокировка - в реляционных базах данных это установка метки на запись, что запись заблокирована для изменений.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R67" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">68</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Оптимистичное блокирование</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - подход предполагает, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">что параллельно выполняющиеся транзакции редко обращаются к одним и тем же данным и позволяет им свободно выполнять любые чтения и обновления данных.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Но при окончании транзакции производится проверка, изменились ли данные в ходе выполнения данной транзакции и, если да, транзакция обрывается и выбрасывается OptimisticLockException. Оптимистичное блокирование в JPA реализовано путём внедрения в сущность специального поля версии:<br>    @Version<br>    private long version;<br>Поле, аннотирование @Version, может быть целочисленным или временнЫм. При завершении транзакции, если сущность была заблокирована оптимистично, будет проверено, не изменилось ли значение @Version кем-либо ещё, после того как данные были прочитаны, и, если изменилось, будет выкинуто OptimisticLockException. Использование этого поля позволяет отказаться от блокировок на уровне базы данных и сделать всё на уровне JPA, улучшая уровень конкурентности.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Позволяет отказатьсь от блокировок на уровне БД и делать всё с JPA.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R68" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">69</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Пессимистичное блокирование</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - подход напротив, ориентирован на транзакции, которые часто конкурируют за одни и те же данные и поэтому блокирует доступ к данным в тот момент когда читает их. Другие транзакции останавливаются, когда пытаются обратиться к заблокированным данным и ждут снятия блокировки (или кидают исключение). </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Пессимистичное блокирование выполняется на уровне базы и поэтому не требует вмешательств в код сущности.</span></td><td class="s1"></td><td class="s6">Filter vs. Interceptor ❖ Перехватчик основан на механизме Reflection, а фильтр основан на обратном вызове функции. ❖ Фильтр зависит от контейнера сервлета, тогда как перехватчик не зависит от него. ❖ Перехватчики могут работать только с запросами к контроллерам, в то время как фильтры могут работать почти со всеми запросами (например, js, .css и т.д.). ❖ Перехватчики в отличии от фильтров могут обращаться к объектам в контейнере Spring, что даёт им более изощренный функционал</td></tr><tr style="height: 20px"><th id="0R69" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">70</div></th><td class="s4">Блокировки ставятся путём вызова метода lock() у EntityManager, в который передаётся сущность, требующая блокировки и уровень блокировки:<br>EntityManager em = entityManagerFactory.createEntityManager();<br>em.lock(company1, LockModeType.OPTIMISTIC);</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R70" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">71</div></th><td class="s3" rowspan="4">Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?</td><td class="s4">1. first-level cache (кэш первого уровня) — кэширует данные одной транзакции;<br>2. second-level cache (кэш второго уровня) —<span style="font-size:10pt;font-family:Arial;color:#ff0000;"> кэширует данные транзакций от одной фабрики сессий.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Провайдер JPA может, но не обязан реализовывать работу с кэшем второго уровня.<br>3. Кэш запросов.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R71" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">72</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Кэш первого уровня</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> – </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">это кэш сессии (Session), который является обязательным, это и есть PersistenceContext</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Через него проходят все запросы.<br>В том случае, если мы выполняем несколько обновлений объекта, Hibernate старается отсрочить (насколько это возможно) обновление этого объекта для того, чтобы сократить количество выполненных запросов в БД. Например, при пяти истребованиях одного и того же объекта из БД в рамках одного persistence context, запрос в БД будет выполнен один раз, а остальные четыре загрузки будут выполнены из кэша. Если мы закроем сессию, то все объекты, находящиеся в кэше, теряются, а далее – либо сохраняются в БД, либо обновляются.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R72" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">73</div></th><td class="s4">Особенности кэша первого уровня:<br>❖        включен по умолчанию, его нельзя отключить;<br>❖        связан с сессией (контекстом персистентности), то есть разные сессии видят только объекты из своего кэша, и не видят объекты, находящиеся в кэшах других сессий;<br>❖        при закрытии сессии PersistenceContext очищается - кэшированные объекты, находившиеся в нем, удаляются;<br>❖        при первом запросе сущности из БД, она загружается в кэш, связанный с этой сессией;<br>❖        если в рамках этой же сессии мы снова запросим эту же сущность из БД, то она будет загружена из кэша, и никакого второго SQL-запроса в БД сделано не будет;<br>❖        сущность можно удалить из кэша сессии методом evict(), после чего следующая попытка получить эту же сущность повлечет обращение к базе данных;<br>❖        метод clear() очищает весь кэш сессии.</td><td class="s6"><span style="font-size:10pt;font-family:Arial;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#000000;">load() или объекта с лениво загружаемыми полями</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, лениво загружаемые данные в кэш не попадут, а вместо этих данных</span><span style="font-size:10pt;font-family:Arial;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#000000;"> Hibernate создаст объект Proxy</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Однако, </span><span style="font-size:10pt;font-family:Arial;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#000000;">как только мы обратимся к этому прокси-объекту в рамках этого же открытого контекста персистентности, Hibernate всё-таки выполнит запрос в базу и данные будут загружены и в объект и в кэш</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. А вот следующая попытка лениво загрузить объект приведёт к тому, что объект сразу вернут из кэша уже полностью загруженным, без обращения в БД.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R73" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">74</div></th><td class="s4">Если кэш первого уровня привязан к объекту сессии, то <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">кэш второго уровня</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> привязан к объекту-фабрике сессий</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">(Session Factory object) и, следовательно, кэш второго уровня доступен одновременно в нескольких сессиях или контекстах персистентности.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Кэш второго уровня требует некоторой настройки и поэтому не включен по умолчанию. Настройка кэша заключается в конфигурировании реализации кэша и разрешения сущностям быть закэшированными.<br>Hibernate не реализует сам никакого in-memory сache, а использует существующие реализации кэшей.<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R74" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">75</div></th><td class="s3" rowspan="3">Как работать с кешем 2 уровня?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R75" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">76</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#ff0000;">В Hibernate кэширование второго уровня реализовано в виде абстракции, то есть мы должны предоставить любую её реализацию, вот несколько провайдеров: Ehcache</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, OSCache, SwarmCache, JBoss TreeCache. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Для Hibernate требуется только реализация интерфейса org.hibernate.cache.spi.RegionFactory, который инкапсулирует все детали, относящиеся к конкретным провайдерам. По сути, RegionFactory действует как мост между Hibernate и поставщиками кэша. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">В примерах будем использовать Ehcache. Что нужно сделать: ❖ добавить мавен-зависимость кэш-провайдера нужной версии ❖ включить кэш второго уровня и определить конкретного провайдера hibernate.cache.use_second_level_cache=true hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory ❖ установить у нужных сущностей JPA-аннотацию @Cacheable, обозначающую, что сущность нужно кэшировать, и Hibernate-аннотацию @Cache, настраивающую детали кэширования, у которой в качестве параметра указать стратегию параллельного доступа&quot; на &quot;Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня. Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Shared Cache Mode</span><span style="font-size:10pt;font-family:Arial;color:#000000;">  </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">ENABLE_SELECTIVE,  ALL, NONE, UNSPECIFIED</span></td><td class="s1"></td><td class="s10">Процесс аутентификации: 1. UsernamePasswordAuthenticationFilter получают имя пользователя и пароль и создает экземпляр класса UsernamePasswordAuthenticationToken (экземпляр интерфейса Authentication). 2. Токен передается экземпляру AuthenticationManager для проверки. 3. AuthenticationManager возвращает полностью заполненный экземпляр Authentication в случае успешной аутентификации. 4. Устанавливается контекст безопасности путем вызова SecurityContextHolder.getContext().setAuthentication(...), куда передается вернувшийся экземпляр Authentication. 5. При успешной аутентификации можно использовать successHandler</td></tr><tr style="height: 20px"><th id="0R76" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">77</div></th><td class="s4">Стратегии параллельного доступа к объектам Проблема заключается в том, что кэш второго уровня доступен из нескольких сессий сразу и несколько потоков программы могут одновременно в разных транзакциях работать с одним и тем же объектом. Следовательно надо как-то обеспечивать их одинаковым представлением этого объекта. ❖<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> READ_ONLY: Используется только для сущностей, которые никогда не изменяются</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> (будет выброшено исключение, если попытаться обновить такую сущность). Очень просто и производительно. Подходит для некоторых статических данных, которые не меняются. ❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">NONSTRICT_READ_WRITE</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: К</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">эш обновляется после совершения транзакции, которая изменила данные в БД и закоммитила их.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Таким образом, строгая согласованность не гарантируется, и существует небольшое временное окно между обновлением данных в БД и обновлением тех же данных в кэше, во время которого параллельная транзакция может получить из кэша устаревшие данные. ❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">READ_WRITE</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: Эта стратегия гарантирует строгую согласованность, которую она достигает, используя «мягкие» блокировки: </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">когда обновляется кэшированная сущность, на нее накладывается мягкая блокировка, которая снимается после коммита транзакции.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Все параллельные транзакции, которые пытаются получить доступ к записям в кэше с наложенной мягкой блокировкой, не смогут их прочитать или записать и отправят запрос в БД. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Ehcache использует эту стратегию по умолчанию. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">TRANSACTIONAL: полноценное разделение транзакций. Каждая сессия и каждая транзакция видят объекты, словно они работали с ними последовательно одна транзакция за другой. Плата за это — блокировки и потеря производительности</span></td><td class="s19 softmerge"><div class="softmerge-inner" style="width:657px;left:-1px">Hibernate Proxy используется для замены реальной сущности POJO (Plain Old Java Object).</div></td><td class="s12"></td></tr><tr style="height: 20px"><th id="0R77" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">78</div></th><td class="s3" rowspan="3">Что такое JPQL/HQL и чем он отличается от SQL?</td><td class="s4">Hibernate Query Language (HQL) и Java Persistence Query Language (JPQL) - оба являются объектно-ориентированными языками запросов, схожими по природе с SQL. <br><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">JPQL - это подмножество HQL.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R78" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">79</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">HQL - это язык запросов, практически такой же как SQL,</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">однако, вместо имен и колонок таблиц базы данных, он использует имена классов Entity и их атрибуты.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> В качестве параметров запросов также используются типы данных атрибутов Entity, а не полей баз данных. В отличии от SQL в JPQL есть автоматический полиморфизм, то есть к</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">аждый запрос к Entity возвращает не только объекты этого Entity, но также объекты всех его классов-потомков</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, независимо от стратегии наследования. В JPA запрос представлен в виде javax.persistence.Query или javax.persistence.TypedQuery, полученных из EntityManager. </span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R79" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">80</div></th><td class="s4">В Hibernate HQL-запрос представлен org.hibernate.query.Query, полученный из Session. Если HQL является именованным запросом, то будет использоваться Session#getNamedQuery, в противном случае требуется Session#createQuery.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R80" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">81</div></th><td class="s3" rowspan="2">Что такое Criteria API и для чего он используется?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">JPA Criteria API - это API, который позволяет делать WHERE (SELECT) запросы гораздо проще. (Динамические запросы). </span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Основные преимущества JPA Criteria API:<br>❖        ошибки могут быть обнаружены во время компиляции;<br>❖        позволяет динамически формировать запросы на этапе выполнения приложения.<br>Основные недостатки:<br>❖        нет контроля над запросом, сложно отловить ошибку<br>❖        влияет на производительность, множество классов<br><br>Для динамических запросов - фрагменты кода создаются во время выполнения - JPA Criteria API является предпочтительней. </span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R81" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">82</div></th><td class="s4">Вот некоторые области применения Criteria API:<br>Criteria API поддерживает проекцию, которую мы можем использовать для агрегатных функций вроде sum(), min(), max() и т.д.<br>Criteria API может использовать ProjectionList для извлечения данных только из выбранных колонок.<br>Criteria API может быть использована для join запросов с помощью соединения нескольких таблиц, используя методы createAlias(), setFetchMode() и setProjection().<br>Criteria API поддерживает выборку результатов согласно условиям (ограничениям). Для этого используется метод add() с помощью которого добавляются ограничения (Restrictions).<br>Criteria API позволяет добавлять порядок (сортировку) к результату с помощью метода addOrder().        </td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R82" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">83</div></th><td class="s3" rowspan="6">Расскажите про проблему N+1 Select и путях ее решения.</td><td class="s4">Проблема N+1 запросов возникает, <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">когда получение данных из БД выполняется за N дополнительных SQL-запросов для извлечения тех же данных, которые могли быть получены при выполнении основного SQL-запроса</span><span style="font-size:10pt;font-family:Arial;color:#000000;">.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Проблема N + 1 возникает, когда фреймворк доступа к данным выполняет N дополнительных SQL-запросов для получения тех же данных, которые можно получить при выполнении одного SQL-запроса.<br>Чем больше значение N, тем больше запросов будет выполнено и тем больше влияние на производительность. И хотя лог медленных запросов может вам помочь найти медленные запросы, но проблему N + 1 он не обнаружит, так как каждый отдельный дополнительный запрос выполняется достаточно быстро. <br>Проблема заключается в выполнении множества дополнительных запросов, которые в сумме выполняются уже существенное время, влияющее на быстродействие.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R83" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">84</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#000000;">1. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">       JOIN FETCH</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>И при FetchType.EAGER и при FetchType.LAZY нам поможет JPQL-запрос с JOIN FETCH. Опцию «FETCH» можно использовать в JOIN (INNER JOIN или LEFT JOIN) для выборки связанных объектов в одном запросе вместо дополнительных запросов для каждого доступа к ленивым полям объекта.<br>Лучший вариант решения для простых запросов (1-3 уровня вложенности связанных объектов).<br><br>select pc<br>    from PostComment pc<br>    join fetch pc.post p</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R84" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">85</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#000000;">2.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">EntityGraph</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>В случаях, когда нам нужно получить по-настоящему много данных, и у нас jpql запрос - лучше всего использовать EntityGraph.<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R85" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">86</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#000000;">3.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Fetch(FetchMode.SUBSELECT)</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Аннотация Hibernate. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Можно использовать только с коллекциями.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций:<br><br>@Fetch(value = FetchMode.SUBSELECT)<br>    private Set&lt;Order&gt; orders = new HashSet&lt;&gt;();</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R86" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">87</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#000000;">4.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Batch fetching</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Это Аннотация Hibernate, в JPA её нет. Указывается над классом сущности или над полем коллекции с ленивой загрузкой. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций. Количество загружаемых сущностей указывается в аннотации.<br><br>@BatchSize(size=5)<br>private Set&lt;Order&gt; orders = new HashSet&lt;&gt;();</span></td><td class="s10">Хотя использовать @BatchSize лучше, чем столкнуться с проблемой запроса N+1, в большинстве случаев гораздо лучшей альтернативой является использование DTO или JOIN FETCH, поскольку они позволяют получать все необходимые данные одним запросом.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R87" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">88</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#000000;">5.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">HibernateSpecificMapping, SqlResultSetMapping</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Для нативных запросов рекомендуется использовать именно их.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R88" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">89</div></th><td class="s3" rowspan="2">Что такое Entity Graph</td><td class="s20"><span style="font-size:10pt;font-family:Arial;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#000000;">Он позволяет определить шаблон путем группировки связанных полей, которые мы хотим получить, и позволяет нам выбирать тип графа во время выполнения</span><span style="font-size:10pt;font-family:Arial;color:#000000;">.Основная цель JPA Entity Graph - улучшить производительность в рантайме при<br>загрузке базовых полей сущности и связанных сущностей и коллекций. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Вкратце, Hibernate загружает весь граф в одном SELECT-запросе, то есть все<br>указанные связи от нужной нам сущности. . Работа с EntityGraph: createEntityGraph, getEntityGraph.<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R89" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">90</div></th><td class="s21"></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R90" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">91</div></th><td class="s22"></td><td class="s10">4.        Логика при регистрации бинов управляется набором @ConditionalOn* аннотаций. Можно указать, чтобы бин создавался при наличии класса в classpath (@ConditionalOnClass), наличии существующего бина (@ConditionalOnBean), отсуствии бина (@ConditionalOnMissingBean) и т.п. Таким образом наличие конфигурации не значит, что бин будет создан и зачастую конфигурация ничего делать и создавать не будет.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R91" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">92</div></th><td class="s22"></td><td class="s10">5.        Созданный в итоге <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">AnnotationConfig</span><span style="font-size:10pt;font-family:Arial;color:#000000;">EmbeddedWeb</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ApplicationContext</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> ищет в том же DI контейнере фабрику для запуска embedded servlet container.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R92" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">93</div></th><td class="s23"></td><td class="s20">6.        Servlet container запускается, приложение готово к работе</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R93" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">94</div></th><td class="s23">Расскажите про нововведения Spring 5.</td><td class="s20">●        Используется JDK 8+ (Optional, CompletableFuture, Time API, java.util.function, default methods)<br>●        Поддержка Java 9 (Automatic-Module-Name in 5.0, module-info in 6.0+, ASM 6)<br>●        Поддержка HTTP/2 (TLS, Push), NIO/NIO.2<br>●        Поддержка Kotlin<br>●        Реактивность (веб-инфраструктура с реактивным стеком, «Spring WebFlux»)<br>●        Null-safety аннотации(@Nullable), новая документация<br>●        Совместимость с Java EE 8 (Servlet 4.0, Bean Validation 2.0, JPA 2.2, JSON Binding API 1.0)<br>●        Поддержка JUnit 5 + Testing Improvements (conditional and concurrent)<br>●        Удалена поддержка: Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R94" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">95</div></th><td class="s23"> Расскажите про аннотацию @ComponentScan</td><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Аннотация @ComponentScan используется вместе с аннотацией @Configuration для указания пакетов, которые мы хотим сканировать на наличие компонентов, из которых нужно сделать бины.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@ComponentScan без аргументов указывает Spring по умолчанию сканировать текущий пакет и все его подпакеты.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Текущий пакет - тот, в котором находится файл конфигурации с этой самой аннотацией @ComponentScan. В данном случае в контейнер попадут: ❖ бин конфигурационного класса; ❖ бины, объявленные в конфигурационном классе с помощью @Bean; ❖ все бины из пакета и его подпакетов. Аннотация @SpringBootApplication включает в себя аннотации @ComponentScan, @SpringBootConfiguration и @EnableAutoConfiguration, но это не мешает разместить её ещё раз отдельно для указания конкретного пакета. Если указать @ComponentScan с атрибутом basePackages, то это изменит пакет по умолчанию на указанный</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R95" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">96</div></th><td class="s1"></td><td class="s24">Java Servlet API — стандартизированный API, предназначенный для реализации на сервере и работе с клиентом по схеме запрос-ответ. Сервлет — это класс, который умеет получать запросы от клиента и возвращать ему ответы. Да, сервлеты в Java — именно те элементы, с помощью которых строится клиент-серверная архитектура.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R96" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">97</div></th><td class="s25">Что делает аннотация @RequestMapping?</td><td class="s26"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#111111;">Используется только для указания URI до класса-контроллера.</span><span style="font-size:10pt;font-family:Arial;color:#111111;"> @RestController<br>@RequestMapping(&quot;/api/coupon&quot;)</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R97" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">98</div></th><td class="s25">Аннотация @RequestParam?</td><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Эта аннотация используется для того, чтобы методы обработчики могли получить параметры из http-запроса. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Запрос с параметрами: http://localhost:8080/getByName/name=Ivan. Следующий код поместит в переменную name строку Ivan.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R98" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">99</div></th><td class="s25">Аннотация @PathVariable?</td><td class="s10">Эта <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">аннотация получает определенную часть из URI</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. URI: http://localhost:8080/getById/23 Следующий код поместит в переменную id значение 23.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R99" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">100</div></th><td class="s25">@RequestBody?</td><td class="s10">@RequestBody, Spring на лету попытается преобразовать содержимое тела входящего запроса в ваш объект параметра.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R100" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">101</div></th><td class="s25">Аннотация @ResponseStatus?</td><td class="s26">Она позволяет устанавливать код ответа. Обычно Spring сам устанавливает нужный код ответа, но бывают моменты, когда это нужно переопределить.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R101" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">102</div></th><td class="s25">RestTemplate? Какие у него преимущества?</td><td class="s10">RestTemplate это специальный клиент в Spring для отправки http-запросов. Он предоставляет удобные API для легкого вызова конечных точек REST’а в одну строку.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R102" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">103</div></th><td class="s25">GET_POST_PUT_DELETE_PATCH</td><td class="s10">@GetMapping — Обрабатывает get-запросы(чтение) @PostMapping — Обрабатывает post-запросы (создание)@DeleteMapping — Обрабатывает delete-запросы @PutMapping — Обрабатывает put-запросы(обновление) @PatchMapping — Обрабатывает patch-запросы</td><td class="s10">PUT — изначально существовавший в стандарте метод, предполагающий полную замену изменяемого объекта. Соответственно в методе PUT, как я и писал выше, придётся указать даже те атрибуты объекта, которые не меняются.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R103" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">104</div></th><td class="s25">@GetMapping</td><td class="s10">Аннотация @GetMapping — это просто аннотация которая содержит @RequestMapping(method = RequestMethod.GET). Она также позволяет более глубоко настроить метод-обработчик. Ее параметры(они конвертируются в аналогичные параметры @RequestMapping):<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> path — URI, headers — заголовки, name — имя обработчика params — параметры , produces — тип возвращаемых данных(JSON, XML, текст). Используется в REST, consumes — тип принимаемых данных. Используется в REST</span></td><td class="s1">@ApiOperation — описывает метод контроллера</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R104" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">105</div></th><td class="s25">Что обозначают разные коды для http-ответов?</td><td class="s10">GET — 200 OK POST — 200 OK, 201 Created, 204 No Content PUT — 200 OK, 201 Created, 204 No Content DELETE — 204 No Content, 202 Accepted</td><td class="s1"></td><td class="s1"></td></tr></tbody></table></div>