<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="../../../../../../../../Users/Салават/Downloads/Hibernate_/resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s11{border-right:none;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s16{background-color:#ffffff;text-align:left;color:#008000;font-family:docs-Consolas,Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s8{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s12{border-left:none;border-right:none;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s13{background-color:#ffffff;text-align:left;font-weight:bold;color:#333333;font-family:Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s10{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s20{border-right:1px SOLID transparent;background-color:#c9daf8;text-align:left;font-weight:bold;color:#1c4587;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s7{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s23{background-color:#ffffff;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s24{background-color:#ffffff;text-align:left;color:#111111;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s3{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#c9daf8;text-align:center;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s15{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#ff0000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s1{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s17{border-right:none;background-color:#ffffff;text-align:left;color:#333333;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s0{border-bottom:1px SOLID transparent;border-right:1px SOLID transparent;background-color:#3d85c6;text-align:left;font-weight:bold;color:#ffffff;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s18{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s4{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s22{background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s6{border-bottom:1px SOLID #0000ff;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s14{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;font-weight:bold;color:#ff0000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s21{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#c9daf8;text-align:left;font-weight:bold;color:#1c4587;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s19{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s2{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#3d85c6;text-align:center;font-weight:bold;color:#ffffff;font-family:Arial;font-size:14pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s5{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s9{background-color:#ffffff;text-align:right;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-origin-ltr"></th><th id="0C0" style="width:159px;" class="column-headers-background">A</th><th id="0C1" style="width:841px;" class="column-headers-background">B</th><th id="0C2" style="width:459px;" class="column-headers-background">C</th><th id="0C3" style="width:100px;" class="column-headers-background">D</th></tr></thead><tbody><tr style="height: 20px"><th id="0R0" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">1</div></th><td class="s0" colspan="2"> </td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R1" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">2</div></th><td class="s2" colspan="2">Hibernate</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R2" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">3</div></th><td class="s3" rowspan="2">Что такое ORM? Что такое JPA? Что такое Hibernate?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ORM</span><span style="font-size:10pt;font-family:Arial;color:#000000;">(Object Relational Mapping) - технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">JPA</span><span style="font-size:10pt;font-family:Arial;color:#000000;">(Java Persistence API) - это стандартная для Java спецификация, описывающая принципы ORM. JPA не умеет работать с объектами, а только определяет правила как должен действовать каждый провайдер (Hibernate, EclipseLink), реализующий стандарт JPA                                                                                                  </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">(Plain Old Java Object - POJO) </span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Hibernate </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- библиотека, являющаяся реализацией этой спецификации, в которой можно использовать стандартные API-интерфейсы JPA.                            </span></td><td class="s5"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">JDBC - Java DataBase Connectivity —</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> API для работы с реляционными (зависимыми) БД. Платформенно независимый промышленный стандарт взаимодействия Java приложений с различными СУБД, реализованный в виде пакета java.sql, входящего в состав Java SE. Предоставляет методы для получения и обновления данных. Не зависит от конкретного типа базы. Библиотека, которая входит в стандартную библиотеу, содержит: набор классов и интерфейсов для работы с БД (для нас разработчиков api) + интерфейсы баз данных.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R3" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">4</div></th><td class="s6">Важные интерфейсы Hibernate:<br><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Session </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- обеспечивает физическое соединение между приложением и БД. Основная функция - предлагать DML-операции для экземпляров сущностей.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">SessionFactory </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- это фабрика для объектов Session. Обычно создается во время запуска приложения и сохраняется для последующего использования. Является потокобезопасным объектом и используется всеми потоками приложения.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Transaction </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- однопоточный короткоживущий объект, используемый для атомарных операций. Это абстракция приложения от основных JDBC транзакций. Session может занимать несколько Transaction в определенных случаях, является необязательным API.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Query </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- интерфейс позволяет выполнять запросы к БД. Запросы написаны на HQL или на SQL.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R4" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">5</div></th><td class="s3" rowspan="2">Что такое EntityManager?</td><td class="s4">EntityManager интерфейс JPA, используемый для взаимодействия с персистентным контекстом, который описывает API для всех основных операций над Entity, а также для получения данных и других сущностей JPA. <br> Основные операции:<br> 1) Операции над Entity: persist (добавление Entity), merge (обновление), remove (удаления), refresh (обновление данных), detach (удаление из управление JPA), lock (блокирование Entity от изменений в других thread),<br> 2) Получение данных: find (поиск и получение Entity), createQuery, createNamedQuery, createNativeQuery, contains, createNamedStoredProcedureQuery, createStoredProcedureQuery<br> 3) Получение других сущностей JPA: getTransaction, getEntityManagerFactory, getCriteriaBuilder, getMetamodel, getDelegate<br> 4) Работа с EntityGraph: createEntityGraph, getEntityGraph<br> 5) Общие операции над EntityManager или всеми Entities: close, clear, isOpen, getProperties, setProperty.</td><td class="s7"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Persistent contex - это набор экземпляров сущностей, загруженных из БД или только что созданных.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Персистентный контекст является своего рода </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">кэшем данных в рамках транзакции - это и есть кэш первого уровня.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Внутри контекста персистентности происходит управление экземплярами сущностей и их жизненным циклом. EntityManager автоматически сохраняет в БД все изменения, сделанные в его персистентном контексте, в момент коммита транзакции, либо при явном вызове метода flush().</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R5" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">6</div></th><td class="s8">Объекты EntityManager не являются потокобезопасными. Это означает, что каждый поток должен получить свой экземпляр EntityManager, поработать с ним и закрыть его в конце.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R6" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">7</div></th><td class="s3" rowspan="2">Каким условиям должен удовлетворять класс чтобы являться Entity?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Entity </span><span style="font-size:10pt;font-family:Arial;color:#000000;">это легковесный хранимый объект бизнес логики. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Основная программная сущность это entity-класс</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, который так же может использовать дополнительные классы, которые могут использоваться как вспомогательные классы или для сохранения состояния еntity.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R7" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">8</div></th><td class="s4">1) Entity класс должен быть помечен аннотацией Entity или описан в XML файле<br>2) Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы с аргументами) - при получении данных из БД и формировании из них объекта сущности, Hibernate должен создать этот самый объект сущности,<br>3) Entity класс должен быть классом верхнего уровня (top-level class),<br>4) Entity класс не может быть enum или интерфейсом,<br>5) Entity класс не может быть финальным классом (final class),<br>6) Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables),<br>7) Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс<br>8) Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity классе),<br>9) Entity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют запись этого Entity класса в базе данных<br></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R8" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">9</div></th><td class="s3">Может ли абстрактный класс быть Entity?</td><td class="s4">Может, при этом он сохраняет все свойства Entity, отличается от обычных Entity классов только тем, что нельзя создать объект этого<br>класса. Абстрактные Entity классы используются в наследовании, когда их потомки<br>наследуют поля абстрактного класса</td><td class="s1"></td><td class="s9">ON представляет собой одно или несколько условий JOIN благодаря которым мы можем сопоставлять записи из одной таблицы в другую.Это не оператор - это часть JOIN, которая является частью предложения FROM Он очень похож на предложение WHERE - за исключением того, что он предназначен только для фильтрации объединения двух таблиц (или наборов строк). В этом случае это условие, при котором строки из A и B сопоставляются. Если у вас были те же условия в WHERE, это повлияло бы на соединение - LEFT JOIN (здесь) разрешено находить несоответствующую строку в B но все равно будет вносить эту строку из A в результат (при этом столбцы B равны NULL). Если вы помещаете такое же условие в WHERE, это заставляет соединение стать INNER JOIN вместо LEFT JOIN.                                                                                                                                   NATURAL JOIN  - может работать без ON<br>        SELECT *<br>                FROM actor<br>        NATURAL JOIN film_actor<br>        NATURAL JOIN film</td></tr><tr style="height: 20px"><th id="0R9" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">10</div></th><td class="s3">Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?</td><td class="s4">Может</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R10" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">11</div></th><td class="s3">Может ли Entity класс наследоваться от других Entity классов?</td><td class="s4">Может</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R11" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">12</div></th><td class="s3">Может ли не Entity класс наследоваться от Entity класса?</td><td class="s4">Может</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R12" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">13</div></th><td class="s3" rowspan="4">Что такое встраиваемый (Embeddable) класс? Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Embeddable класс - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">это класс, который не используется сам по себе, а является частью одного или нескольких Entity-классов</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Entity-класс может содержать как одиночные встраиваемые классы, так и коллекции таких классов. Также такие классы могут быть использованы как ключи или значения map. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Во время выполнения каждый встраиваемый класс принадлежит только одному объекту Entity-класса и не может быть использован для передачи данных между объектами Entity-классов (то есть такой класс не является общей структурой данных для разных объектов). В целом, такой класс служит для того чтобы выносить определение общих атрибутов для нескольких Entity.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R13" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">14</div></th><td class="s4">1. <span style="font-size:10pt;font-family:Arial;color:#ff0000;">Такие классы должны удовлетворять тем же правилам что Entity классы, за исключением того что они </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">не обязаны содержать первичный ключ и быть отмечены аннотацией Entity</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>2. Embeddable класс должен быть помечен аннотацией @Embeddable или описан в XML файле конфигурации JPA. А поле этого класса в Entity аннотацией @Embedded.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;"> От Embeddable класса нельзя наследоваться - конечный класс Стоит использовать если класс конечный</span></td><td class="s7">То есть, если класс Person с полями name и age встроен и в класс Driver, и в класс Baker, то у обоих последних классов появятся оба поля из класса Person. Но если у объекта Driver эти поля будут иметь значения “Иван” и “35”, то эти же поля у объекта B</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R14" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">15</div></th><td class="s8">Embeddable-класс может содержать другой встраиваемый класс. Embeddable Person может имент поле класса Adress - тогда в Student пишем adress.имяполя.</td><td class="s10"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R15" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">16</div></th><td class="s4">Встраиваемый класс может содержать связи с другими Entity или коллекциями Entity, если такой класс не используется как первичный ключ или ключ map&#39;ы.<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;"> Так как мы можем встраивать классы в неограниченное количество других<br>классов, то у каждого класса, содержащего встраиваемый класс, мы можем изменить<br>названия полей из встраиваемого класса. Например, у класса Driver поля из<br>встраиваемого класса Person будут изменены с name на driver_name и с age на<br>driver_age. Делаем с помощью аннотации AttributeOverride - также класс Embeddable &quot;Person&quot; может быть встроет в Studen и с помощью AttributeOverride можно задать для 2 персон &quot;муж и жен пол&quot; 2 разделения. @AssociationOverride - в Embeddable Person есть объект Embeddable Adress а в нем связть MonyToOne с другой таблицой Street для этого в Studen ставим аннотацию @AssociationOverride над Person и подключаем @AssociationOverride(name = adress.street joinColumns = @JoinColumn(name))</span></td><td class="s10"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R16" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">17</div></th><td class="s3">Что такое Mapped Superclass?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Mapped Superclass - (позволяет обойти блокировку наследования Embeddable-классов, то есть от такого класса мы можем наследоваться, также в классе Entity если мы используем класс MappedSuperclass то над ним нужно ставить аннтотацию @Embedded)  это класс, от которого наследуются Entity </span><span style="font-size:10pt;font-family:Arial;color:#000000;">, он может содержать анотации JPA, однако сам такой класс не является Entity, ему не обязательно выполнять все требования установленные для Entity (например, он может не содержать первичного ключа). Такой класс не может использоваться в операциях EntityManager или Query. Такой класс должен быть отмечен аннотацией MappedSuperclass или описан в xml файле.<br>Создание такого класса-предка оправдано тем, что мы заранее определяем ряд свойств и методов, которые должны быть определены в сущностях. Использование такого подхода позволило сократить количество кода.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R17" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">18</div></th><td class="s3" rowspan="3">Какие три типа стратегий наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?</td><td class="s4">Inheritance Mapping Strategies <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Стратегии наследования нужны для того, чтобы дать понять провайдеру (Hibernate) как ему отображать в БД сущности-наследники:</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">1) Одна таблица на всю иерархию классов (SINGLE_TABLE) — все enity, со всеми наследниками записываются в одну таблицу, для идентификации типа entity определяется специальная колонка “discriminator column”.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Например, если есть entity Animals c классами-потомками Cats и Dogs, при такой стратегии все entity записываются в таблицу Animals, но при это имеют дополнительную колонку animalType в которую соответственно пишется значение «cat» или «dog». </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Минусом является то что в общей таблице, будут созданы все поля уникальные для каждого из классов-потомков, которые будет пусты для всех других классов-потомков. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Например, в таблице animals окажется и скорость лазанья по дереву от cats и может ли пес приносить тапки от dogs, которые будут всегда иметь null для dog и cat соотвественно.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Минусом стратегии является невозможность применения ограничения NOT NULL для тех колонок таблицы, которые характерны только для классов-наследников., но можно использовать тригеры</span><span style="font-size:10pt;font-family:Arial;color:#000000;">.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;"> Является стратегией по умолчанию. @DiscriminatorColumn(name = &quot;EMP_TYPE&quot;) - имя общей колонки указывающий на принодлежность к классу @DiscriminatorValue(&quot;P&quot;) - указывает какое имя будет отображенно в @DiscriminatorColumn</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R18" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">19</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">2) Стратегия «соединения» (JOINED) — </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">В данной стратегии корневой класс иерархии представлен отдельной таблицей, а каждый класс-наследник имеет свою таблицу, в которой отображены только поля этого класса-наследника.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">, дополнительно устанавливается связь (relationships) между этими таблицами</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, например в случае классов Animals (см.выше), будут три таблицы animals, cats, dogs, причем в cats будет записана только ключ и скорость лазанья, в dogs — ключ и умеет ли пес приносить палку, а в animals все остальные данные cats и dogs c ссылкой на соответствующие таблицы. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Минусом тут являются потери производительности от объединения таблиц (join) для любых операций. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@Id, который должен быть определен только в родительской таблице.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R19" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">20</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">3) Таблица для каждого класса (TABLE_PER_CLASS) — каждый отдельный класс-наследник имеет свою таблицу</span><span style="font-size:10pt;font-family:Arial;color:#000000;">,</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Во всех таблицах подклассов хранятся все поля этого класса плюс те, которые унаследованы от суперкласса.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> т.е. для cats и dogs (см.выше) все данные будут записываться просто в таблицы cats и dogs как если бы они вообще не имели общего суперкласса. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Минусом является плохая поддержка полиморфизма (polymorphic relationships) и то что для выборки всех классов иерархии потребуются большое количество отдельных sql запросов или использование UNION запроса.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Для задания стратегии наследования используется аннотация Inheritance (</span><span style="font-size:10pt;font-family:Arial;color:#000000;">или соответствующие блоки)</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R20" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">21</div></th><td class="s3" rowspan="3">Как мапятся Enum&#39;ы?</td><td class="s8"> @Enumerated(EnumType.STRING) - означает, что в базе будут храниться имена Enum.<br>@Enumerated(EnumType.ORDINAL) - в базе будут храниться порядковые номера Enum.                                                              <span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#000000;">@Enumerated(EnumType.STRING) </span><span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#ff0000;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Однако переименование значения enum все равно нарушит работу базы данных.</span><span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#ff0000;"> Кроме того, даже несмотря на то, что это представление данных гораздо более читаемо по сравнению с параметром @Enumerated(EnumType.ORDINAL), оно потребляет намного больше места, чем необходимо</span><span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#000000;">. Это может оказаться серьезной проблемой, когда нам нужно иметь дело с большим объемом данных.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R21" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">22</div></th><td class="s4">Другой вариант - мы можем смапить наши enum в БД и обратно в методах с аннотациями <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@PostLoad и @PrePersist. @EntityListener над классом Entity, в которой указать класс, в котором создать два метода, помеченнх этими аннотациями.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Идея в том, чтобы в сущности иметь не только поле с Enum, но и вспомогательное поле. Поле с Enum аннотируем @Transient, а в БД будет храниться значение из вспомогательного поля. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">кажется неправильным иметь в сущности целых два атрибута, представляющих одно перечисление.</span></td><td class="s5"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">По порядковым номерам</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Если мы сохраняем в БД сущность, у которой есть поле-перечисление (Enum), то</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> в таблице этой сущности создаётся колонка для значений этого перечисления и по умолчанию в ячейки сохраняется </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">порядковый номер этого перечисления (ordinal).</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R22" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">23</div></th><td class="s4">В JPA с версии 2.1 можно использовать Converter для конвертации Enum’а в некое его значение для сохранения в БД и получения из БД. Все, что нам нужно сделать, это создать новый класс, который реализует javax.persistence.AttributeConverter и аннотировать его с помощью <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Converter и поле в сущности аннотацией @Convert</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Мы установили @Converter(autoApply=true), чтобы JPA автоматически применял логику преобразования ко всем сопоставленным атрибутам типа Category. В противном случае нам пришлось бы поместить аннотацию @Converter непосредственно над полем Category у каждой сущности, где оно имеется. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Более того, мы можем безопасно добавлять новые значения enum или изменять существующие, не нарушая уже сохраненные данные.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R23" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">24</div></th><td class="s3">Как мапятся даты (до java 8 и после)?</td><td class="s4">Аннотация <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Temporal</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> до Java 8, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">в которой надо было указать какой тип даты мы хотим использовать.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>В Java 8 и далее аннотацию ставить не нужно. java.time Все классы в новом API неизменяемые (immutable) и, как следствие,<br>потоко-безопасные. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Точность представления времени составляет одну наносекунду,</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>что в миллион раз точнее чем в пакете java.util.</span></td><td class="s11 softmerge"><div class="softmerge-inner" style="width:657px;left:-1px">Тип java.util.Date содержит информацию о дате и времени с точностью до миллисекунд.</div></td><td class="s12"></td></tr><tr style="height: 20px"><th id="0R24" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">25</div></th><td class="s3">Как “смапить” коллекцию примитивов?</td><td class="s4"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@ElementCollection<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;"> @OrderBy<br>Если у нашей сущности есть поле с коллекцией, то мы привыкли ставить над ним аннотации @OneToMany либо @ManyToMany. Но данные аннотации применяются в случае, когда это коллекция других сущностей (entities). </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Если у нашей сущности коллекция не других сущностей, а базовых или встраиваемых (embeddable) типов</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> для этих случаев в JPA имеется специальная аннотация </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@ElementCollection, которая указывается в классе сущности над полем коллекции</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">. Все записи коллекции хранятся в отдельной таблице, то есть в итоге получаем две таблицы: одну для сущности, вторую для коллекции элементов.<br>При добавлении новой строки в коллекцию, она полностью очищается и заполняется заново, так как у элементов нет id. Можно решить с помощью @OrderColumn<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;"> @CollectionTable - позволяет редактировать таблицу с коллекцией, прочитать</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R25" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">26</div></th><td class="s3" rowspan="3">Какие есть виды связей?</td><td class="s4">Существуют 4 типа связей:<br>1. OneToOne - когда один экземпляр Entity может быть связан не больше чем с одним экземпляром другого Entity.<br>2. OneToMany - когда один экземпляр Entity может быть связан с несколькими экземплярами других Entity.<br>3. ManyToOne - обратная связь для OneToMany. Несколько экземпляров Entity могут быть связаны с одним экземпляром другого Entity.<br>4. ManyToMany - экземпляры Entity могут быть связаны с несколькими экземплярами друг друга.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R26" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">27</div></th><td class="s4">Каждую из которых можно разделить ещё на два вида:<br><span style="font-size:10pt;font-family:Arial;font-weight:bold;">1. Bidirectional </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Владеемая сторона в двунаправленных отношениях должна ссылаться на владеющую сторону используя элемент mappedBy аннотаций @OneToOne, @OneToMany, или @ManyToMany. Элемент mappedBy определяет поле в объекте, который является владельцем отношения.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">2. Undirectional</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">В однонаправленных отношениях только одна сущность имеет поле, которое ссылается на вторую сущность. Вторая сущность (сторона) не имеет поля первой сущности и не знает об отношениях. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Элемент mappedBy определяет поле в объекте, который является владельцем отношения.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R27" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">28</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Bidirectional (Двунаправленные отношения) </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— ссылка на связь устанавливается у всех Entity, то есть в случае OneToOne A-B в Entity A есть ссылка на Entity B, в Entity B есть ссылка на Entity A. Entity A считается владельцем этой связи (это важно для случаев каскадного удаления данных, тогда при удалении A также будет удалено B, но не наоборот).<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Undirectional</span><span style="font-size:10pt;font-family:Arial;color:#000000;">- ссылка на связь устанавливается только с одной стороны, то есть в случае OneToOne A-B только у Entity A будет ссылка на Entity B, у Entity B ссылки на A не будет.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R28" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">29</div></th><td class="s3">Что такое владелец связи?</td><td class="s4">В отношениях между двумя сущностями всегда есть одна владеющая сторона, а владеемой может и не быть, если это однонаправленные отношения.<br>По сути, <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">у кого есть внешний ключ на другую сущность - тот и владелец связи</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">То есть, если в таблице одной сущности есть колонка, содержащая внешние ключи от другой сущности, то первая сущность признаётся владельцем связи, вторая сущность - владеемой.<br>В однонаправленных отношениях сторона, которая имеет поле с типом другой сущности, является владельцем этой связи по умолчанию.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R29" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">30</div></th><td class="s3" rowspan="2">Что такое каскады?</td><td class="s7"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml">Каскадирование - это когда мы выполняем какое-то действие с целевой Entity, то же самое действие будет применено к связанной Entity.</a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml"><br>JPA CascadeType:<br>ALL -  гарантируют, что все персистентные события, которые происходят на родительском объекте, будут переданы дочернему объекту.<br>PERSIST -  означает, что операции save () или persist () каскадно передаются связанным объектам.<br>MERGE - означает, что связанные entity объединяются, когда объединяется entity-владелец.</a></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R30" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">31</div></th><td class="s4">REMOVE - удаляет все entity, связанные с удаляемой entity.<br>DETACH - отключает все связанные entity, если происходит «ручное отключение».<br>REFRESH - повторно считывают значение данного экземпляра и связанных сущностей из базы данных при вызове refresh().</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R31" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">32</div></th><td class="s3">Разница между PERSIST и MERGE?</td><td class="s4">persist(entity) следует использовать с совершенно новыми объектами, чтобы добавить их в БД (если объект уже существует в БД, будет выброшено исключение EntityExistsException).<br><br>Но в случае merge(entity) сущность, которая уже управляется в контексте персистентности, будет заменена новой сущностью (обновленной), и копия этой обновленной сущности вернется обратно. Но рекомендуется использовать для уже сохраненных сущностей.</td><td class="s13">orphanRemoval. Директива orphanRemoval объявляет, что связанные экземпляры сущностей должны быть удалены, когда они отсоединены от родителя, или эквивалентно, когда родитель удален</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R32" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">33</div></th><td class="s3">Какие два типа fetch стратегии в JPA вы знаете?</td><td class="s4">1) <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">LAZY </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Hibernate может загружать данные не сразу, а при первом обращении к ним</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, но так как это необязательное требование, то Hibernate имеет право изменить это поведение и загружать их сразу. Это поведение по умолчанию для полей, аннотированных @OneToMany, @ManyToMany и @ElementCollection. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">В объект загружается прокси lazy-поля.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>2) </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">EAGER</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">данные поля будут загруженны немедленно</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Это поведение по умолчанию для полей, аннотированных @Basic, @ManyToOne и @OneToOne.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R33" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">34</div></th><td class="s3">Какие четыре статуса жизненного цикла Entity объекта (Entity Instance’s Life Cycle) вы можете перечислить?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Transient (New) — </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">свежесозданная оператором new() сущность не имеет связи с базой данных</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, не имеет данных в базе данных и не имеет сгенерированных первичных ключей.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- объект создан, сохранён в бд, имеет primary key, управляется JPA<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached </span><span style="font-size:10pt;font-family:Arial;color:#000000;">-объект создан, имеет primary key, не является (или больше не является) частью контекста персистентности (не управляется JPA);<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">-</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> </span><span style="font-size:10pt;font-family:Arial;">объект создан, у</span><span style="font-size:10pt;font-family:Arial;color:#000000;">правляется JPA, будет удален при commit-е и статус станет опять detached</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R34" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">35</div></th><td class="s3">Как влияет операция persist на Entity объекты каждого из четырех статусов?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">new </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ managed, и объект будет сохранен в базу при commit-е транзакции или в результате flush операций<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ операция игнорируется, однако зависимые Entity могут поменять статус на managed, если у них есть аннотации каскадных изменений<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ exception сразу или на этапе commit-а транзакции<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ managed, но только в рамках одной транзакции. </span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R35" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">36</div></th><td class="s3">Как влияет операция remove на Entity объекты каждого из четырех статусов?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">new </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ операция игнорируется, однако зависимые Entity могут поменять статус на removed, если у них есть аннотации каскадных изменений и они имели статус managed<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ removed и запись объект в базе данных будет удалена при commit-е транзакции (также произойдут операции remove для всех каскадно зависимых объектов)<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ exception сразу или на этапе commit-а транзакции<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ операция игнорируется</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R36" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">37</div></th><td class="s3">Как влияет операция merge на Entity объекты каждого из четырех статусов?</td><td class="s8">new → <span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#000000;">будет создана новая managed entity, в которую будут скопированы данные<br>объекта.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed → </span><span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#000000;">операция игнорируется, однако операция merge сработает на<br>каскадно зависимых entity, если их статус не managed.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed → </span><span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#000000;">exception сразу или на этапе commit-а транзакции.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached → </span><span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#000000;">либо данные будут скопированы в существующую БД managed entity<br>с тем же пер</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R37" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">38</div></th><td class="s3">Как влияет операция refresh на Entity объекты каждого из четырех статусов?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ будут восстановлены все изменения из базы данных данного Entity, также произойдет refresh всех каскадно зависимых объектов<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">new</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ exception<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R38" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">39</div></th><td class="s3">Как влияет операция detach на Entity объекты каждого из четырех статусов?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ detached.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">new</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ операция игнорируется<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R39" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">40</div></th><td class="s3" rowspan="2">Для чего нужна аннотация Basic?</td><td class="s4"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@Basic - указывает на простейший тип маппинга данных на колонку таблицы базы данных.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет. Может быть применена к полю любого из следующих типов:<br>1. Примитивы и их обертки.<br>2. java.lang.String<br>3. java.math.BigInteger<br>4. java.math.BigDecimal<br>5. java.util.Date<br>6. java.util.Calendar<br>7. java.sql.Date<br>8. java.sql.Time<br>9. java.sql.Timestamp<br>10. byte[] or Byte[]<br>11. char[] or Character[]<br>12. enums<br>13. любые другие типы, которые реализуют Serializable.<br></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Вообще, аннотацию @Basic можно не ставить, как это и происходит по умолчанию.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R40" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">41</div></th><td class="s4"> Аннотация @Basic определяет 2 атрибута:<br><br>1. optional - boolean (по умолчанию true) - определяет, может ли значение поля или свойства быть null. Игнорируется для примитивных типов. Но если тип поля не примитивного типа, то при попытке сохранения сущности будет выброшено исключение.<br><br>2. fetch - FetchType (по умолчанию EAGER) - определяет, должен ли этот атрибут извлекаться незамедлительно (EAGER) или лениво (LAZY). Однако, это необязательное требование JPA, и провайдерам разрешено незамедлительно загружать данные, даже для которых установлена ленивая загрузка.<br><br>Без аннотации @Basic при получении сущности из БД по умолчанию её поля базового типа загружаются принудительно (EAGER) и значения этих полей могут быть null</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R41" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">42</div></th><td class="s3" rowspan="2">Для чего нужна аннотация Column?</td><td class="s14">Через аннотацию @Column можно явно указать поведение столбца. Если откроете ее реализацию, то увидите, что столбцу можно задавать такие свойства, как уникальность, обновляемость и т.д.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R42" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">43</div></th><td class="s4">@Basic vs @Column:<br>1. Атрибуты @Basic применяются к сущностям JPA, тогда как атрибуты @Column применяются к столбцам базы данных.<br>2. @Basic имеет атрибут optional, который говорит о том, может ли поле объекта быть null или нет; с другой стороны атрибут nullable аннотации @Column указывает, может ли соответствующий столбец в таблице быть null.<br>3. Мы можем использовать @Basic, чтобы указать, что поле должно быть загружено лениво.<br>4. Аннотация @Column позволяет нам указать имя столбца в таблице и ряд других свойств:<br> a. insertable/updatable - можно ли добавлять/изменять данные в колонке, по умолчанию true;<br> b. length - длина, для строковых типов данных, по умолчанию 255.<br>Коротко, в Column (колум) мы задаем constraints (констрейнтс), а в Basic (бейсик) - ФЕТЧ ТАЙП</td><td class="s5">    @Column(name=&quot;STUDENT_NAME&quot;, length=50, nullable=false, unique=false)<br>    private String name;</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R43" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">44</div></th><td class="s3" rowspan="2">Для чего нужна аннотация Access?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#000000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth">Она </a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#ff0000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth">определяет</a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#000000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth"> тип доступа (access type) для класса entity, Mapped Superclass, embeddable или отдельных атрибутов, то есть </a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#ff0000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth">как JPA будет обращаться к атрибутам entity, как к полям класса (FIELD) или как к свойствам класса (PROPERTY), имеющие гетеры (getter) и сетеры (setter).</a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#000000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth"><br><br></a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth">Определяет тип доступа к полям сущности. Для чтения и записи этих полей есть два подхода:<br>1. Field access (доступ по полям). При таком способе аннотации маппинга (Id, Column,...) размещаются над полями, и Hibernate напрямую работает с полями сущности, читая и записывая их.<br>2. Property access (доступ по свойствам). При таком способе аннотации размещаются над методами-геттерами, но никак не над сеттерами. Hibernate использует их и сеттеры для чтения и записи полей сущности. </a></span></td><td class="s5"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Но есть требование - у сущности с property access</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> названия методов должны соответствовать требованиям JavaBeans. Например, если у сущности Customer есть поле с именем firstName, то у этой сущности должны быть определены методы getFirstName и setFirstName для чтения и записи поля firstName.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R44" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">45</div></th><td class="s4">По умолчанию тип доступа определяется местом, в котором находится аннотация @Id. Если она будет над полем - это будет AccessType.FIELD, если над геттером - это AccessType.PROPERTY.<br>Чтобы явно определить тип доступа у сущности, нужно использовать аннотацию @Access, которая может быть указана у сущности, Mapped Superclass и Embeddable class, а также над полями или методами.<br>Поля, унаследованные от суперкласса, имеют тип доступа этого суперкласса.<br>Когда у одной сущности определены разные типы доступа, то нужно использовать аннотацию @Transient для избежания дублирования маппинга.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R45" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">46</div></th><td class="s3">Для чего нужна аннотация @Cacheable?</td><td class="s4"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@Cacheable - необязательная аннотация JPA, используется для указания того, должна ли сущность храниться в кэше второго уровня.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> JPA говорит о пяти значениях shared-cache-mode из persistence.xml, который определяет как будет использоваться second-level cache:<br><br>❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ENABLE_SELECTIVE</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: (дефолтное и рекомендуемое значение):только сущности с аннотацией @Cacheable (равносильно значению по умолчанию @Cacheable(value=true)) будут сохраняться в кэше второго уровня.<br>❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">DISABLE_SELECTIVE</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: все сущности будут сохраняться в кэше второго уровня, за исключением сущностей, помеченных @Cacheable(value=false) как некэшируемые.<br>❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ALL</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: сущности всегда кэшируются, даже если они помечены как некэшируемые.<br>❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">NONE</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: ни одна сущность не кэшируется, даже если помечена как кэшируемая. При данной опции имеет смысл вообще отключить кэш второго уровня.<br>❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">UNSPECIFIED</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: применяются значения по умолчанию для кэша второго уровня, определенные Hibernate. Это эквивалентно тому, что вообще не используется shared-cache-mode, так как Hibernate не включает кэш второго уровня, если используется режим UNSPECIFIED.<br><br>Аннотация @Cacheable размещается над классом сущности. Её действие распространяется на эту сущность и её наследников, если они не определили другое поведение.</span></td><td class="s5">Как и большинство других полностью оснащенных платформ ORM, <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Hibernate имеет концепцию кэша первого уровня.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Это кэш с областью действия сеанса, который гарантирует, что каждый экземпляр сущности загружается только один раз в постоянном контексте. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">С другой стороны, кэш второго уровня имеет область SessionFactory </span><span style="font-size:10pt;font-family:Arial;color:#000000;">-, что означает, что он является общим для всех сеансов, созданных с помощью одной и той же фабрики сеансов. </span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R46" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">47</div></th><td class="s3">Для чего нужна аннотация @Cache?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Это аннотация Hibernate, настраивающая тонкости кэширования объекта в кэше второго уровня Hibernate.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> @Cache принимает три параметра:<br>❖        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">include</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - имеет по умолчанию значение </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">all</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> и означающий кэширование всего объекта. Второе возможное значение - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">non-lazy</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, запрещает кэширование лениво загружаемых объектов. Кэш первого уровня не обращает внимания на эту директиву и всегда кэширует лениво загружаемые объекты.<br>❖        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">region</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - позволяет задать имя региона кэша для хранения сущности. Регион можно представить как разные области кэша, имеющие разные настройки на уровне реализации кэша. Например, можно было бы создать в конфигурации ehcache два региона, один с краткосрочным хранением объектов, другой с долгосрочным и отправлять часто изменяющиеся объекты в первый регион, а все остальные - во второй. Ehcache по умолчанию создает регион для каждой сущности с именем класса этой сущности, соответственно в этом регионе хранятся только эти сущности. К примеру, экземпляры Foo хранятся в Ehcache в кэше с именем “com.baeldung.hibernate.cache.model.Foo”.<br>❖        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">usage</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - задаёт стратегию одновременного доступа к объектам.<br>transactional<br>read-write<br>nonstrict-read-write<br>read-only</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R47" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">48</div></th><td class="s3">Для чего нужны аннотации @Embedded и @Embeddable?</td><td class="s4"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/">@Embeddable - аннотация JPA, размещается над классом для указания того, что класс является встраиваемым в другие классы.<br>@Embedded - аннотация JPA, используется для размещения над полем в классе-сущности для указания того, что мы внедряем встраиваемый класс.</a></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R48" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">49</div></th><td class="s3" rowspan="5">Как смапить составной ключ?</td><td class="s4">Составной первичный ключ, также называемый составным ключом, представляет собой комбинацию из двух или более столбцов для формирования первичного ключа таблицы.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R49" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">50</div></th><td class="s4"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@IdClass</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Допустим, у нас есть таблица с именем Account, и она имеет два столбца - accountNumber и accountType, которые формируют составной ключ. Чтобы обозначить оба этих поля как части составного ключа мы должны создать класс, например, ComplexKey с этими полями.<br><br>Затем нам нужно аннотировать сущность Account аннотацией @IdClass(ComplexKey.class). Мы также должны объявить поля из класса ComplexKey в сущности Account с такими же именами и аннотировать их с помощью @Id.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R50" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">51</div></th><td class="s4">public class ComplexKey implements Serializable {<br>     private String accountNumber;<br>     private String accountType;<br>     // default constructor<br>     public AccountId(String accountNumber, String accountType) {<br>        this.accountNumber = accountNumber;<br>        this.accountType = accountType;<br>     }<br>     // equals() and hashCode()<br>}<br><br>@Entity<br>@IdClass(ComplexKey.class)<br>public class Account {<br>    @Id<br>    private String accountNumber;<br>    @Id<br>    private String accountType;<br>    // other fields, getters and setters<br>}</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R51" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">52</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;"> @EmbeddedId</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Рассмотрим пример, в котором мы должны сохранить некоторую информацию о книге с заголовком и языком в качестве полей первичного ключа. В этом случае класс первичного ключа, BookId, должен быть аннотирован @Embeddable.<br>Затем нам нужно встроить этот класс в сущность Book, используя @EmbeddedId.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R52" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">53</div></th><td class="s4">@Embeddable<br>public class BookId implements Serializable {<br>    private String title;<br>    private String language;<br>    // default constructor<br>    public BookId(String title, String language) {<br>        this.title = title;<br>        this.language = language;<br>    }<br>    // getters, equals() and hashCode() methods<br>}<br>@Entity<br>public class Book {<br>    @EmbeddedId<br>    private BookId bookId;<br>    // constructors, other fields, getters and setters<br>}</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R53" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">54</div></th><td class="s3" rowspan="3">Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Аннотация @Id определяет простой (не составной) первичный ключ</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, состоящий из одного поля. В соответствии с JPA, допустимые типы атрибутов для первичного ключа:<br>1.        примитивные типы и их обертки;<br>2.        строки;<br>3.        BigDecimal и BigInteger;<br>4.        java.util.Date и java.sql.Date.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R54" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">55</div></th><td class="s7">Если мы хотим, чтобы значение первичного ключа генерировалось для нас автоматически, мы можем добавить первичному ключу, отмеченному аннотацией @Id, аннотацию @<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">GeneratedValue</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Аннотация @GeneratedValue предназначена для настройки способа приращения указанного столбца(поля).</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Возможно 4 варианта: <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">AUTO(default) - </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Указывает, что Hibernate должен выбрать подходящую стратегию для конкретной базы данных, учитывая её диалект, так как у разных БД разные способы по умолчанию. Поведение по умолчанию - исходить из типа поля идентификатора. <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">IDENTITY - </span><span style="font-size:10pt;font-family:Arial;color:#000000;">для генерации значения первичного ключа будет использоваться столбец IDENTITY, имеющийся в базе данных. Значения в столбце автоматически увеличиваются вне текущей выполняемой транзакции(на стороне базы, так что этого столбца мы не увидим), что позволяет базе данных генерировать новое значение при каждой операции вставки. В промежутках транзакций сущность будет сохранена.</span></td><td class="s7">С версии Hibernate 5.0 для числовых значений генерация основана на SEQUENCE, и, если БД её не поддерживает, то на TABLE.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R55" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">56</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">SEQUENCE </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- тип генерации, рекомендуемый документацией Hibernate. Для получения значений первичного ключа Hibernate должен использовать имеющиеся в базе данных механизмы генерации последовательных значений (Sequence). В бд можно будет увидеть дополнительную таблицу. Но если наша БД не поддерживает тип SEQUENCE, то Hibernate автоматически переключится на тип TABLE. В промежутках транзакций сущность не будет сохранена, так как хибер возьмет из таблицы id hibernate-sequence и вернётся обратно в приложение.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">SEQUENCE </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">это объект базы данных, который генерирует инкрементные целые числа при каждом последующем запросе. </span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">TABLE </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Hibernate должен получать первичные ключи для сущностей из создаваемой для этих целей таблицы</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, способной содержать именованные сегменты значений для любого количества сущностей. Требует использования пессимистических блокировок, которые помещают все транзакции в последовательный порядок и замедляет работу приложения.</span></td><td class="s10"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R56" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">57</div></th><td class="s3" rowspan="5">Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;"> @JoinColumn используется для указания столбца FOREIGN KEY, используемого при установлении связей между сущностями или коллекциями.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Мы помним, что только сущность-владелец связи может иметь внешние ключи от другой сущности (владеемой). Однако, мы можем указать @JoinColumn как во владеющей таблице, так и во владеемой, но столбец с внешними ключами всё равно появится во владеющей таблице. <br>Особенности использования:</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R57" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">58</div></th><td class="s4">❖        @OneToOne: означает, что появится столбец в таблице сущности-владельца связи, который будет содержать внешний ключ, ссылающийся на первичный ключ владеемой сущности.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R58" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">59</div></th><td class="s4">❖        @OneToMany/@ManyToOne: если не указать на владеемой стороне связи атрибут mappedBy, создается joinTable с ключами обеих таблиц. Но при этом же у владельца создается столбец с внешними ключами.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R59" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">60</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> @JoinColumns</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> используется для группировки нескольких аннотаций @JoinColumn, которые используются при установлении связей между сущностями или коллекциями, у которых составной первичный ключ и требуется несколько колонок для указания внешнего ключа.<br>В каждой аннотации @JoinColumn должны быть указаны элементы name и referencedColumnName.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R60" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">61</div></th><td class="s14"> @JoinTable используется для указания связывающей (сводной, третьей) таблицы между двумя другими таблицами.                                <span style="font-size:10pt;font-family:Arial;font-weight:normal;font-style:italic;color:#ff0000;">@JoinTable(name = &quot;CATALOG&quot;, joinColumns = @JoinColumn(name = &quot;ID_BOOK&quot;), inverseJoinColumns = @JoinColumn(name = &quot;ID_STUDENT&quot;))<br> private Student student;</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R61" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">62</div></th><td class="s3" rowspan="4">Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?</td><td class="s4"> <span style="font-size:10pt;font-family:Arial;color:#ff0000;">@</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">OrderBy указывает порядок, в соответствии с которым должны располагаться элементы коллекций</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">сущностей, базовых или встраиваемых типов </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">при их извлечении из БД. Если в кэше есть нужные данные, то сортировки не будет</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Так как @OrderBy просто добавляет к sql-запросу Order By, а при получении данных из кэша, обращения к бд нет. Эта аннотация может использоваться с аннотациями @ElementCollection, @OneToMany, @ManyToMany.<br>При использовании с коллекциями базовых типов, которые имеют аннотацию </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@ElementCollection, элементы этой коллекции будут отсортированы в натуральном порядке, по значению базовых типов.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R62" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">63</div></th><td class="s15">Если это коллекция встраиваемых типов (@Embeddable), то используя точку (&quot;.&quot;) мы можем сослаться на атрибут внутри встроенного атрибута. <br>Если это коллекция сущностей, то у аннотации @OrderBy можно указать имя поля сущности, по которому сортировать эти самые сущности:<br>Если мы не укажем у @OrderBy параметр, то сущности будут упорядочены по первичному ключу.<br>В случае с сущностями доступ к полю по точке не работает. Попытка использовать вложенное свойство, например @OrderBy (&quot;supervisor.name&quot;) повлечет Runtime Exceprtion.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R63" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">64</div></th><td class="s4"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@OrderColumn создает в таблице столбец с индексами порядка элементов</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, который используется для поддержания постоянного порядка в списке, но этот столбец не считается частью состояния сущности или встраиваемого класса.<br>Hibernate отвечает за поддержание порядка как в базе данных при помощи столбца, так и при получении сущностей и элементов из БД. Hibernate отвечает за обновление порядка при записи в базу данных, чтобы отразить любое добавление, удаление или иное изменение порядка, влияющее на список в таблице.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R64" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">65</div></th><td class="s4"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@OrderBy vs @OrderColumn</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Порядок, указанный в @OrderBy, применяется только в рантайме при выполнении запроса к БД, То есть в контексте персистентности, в то время как при использовании @OrderColumn, порядок сохраняется в отдельном столбце таблицы и поддерживается при каждой вставке/обновлении/удалении элементов.<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R65" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">66</div></th><td class="s3">Для чего нужна аннотация Transient?</td><td class="s4"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@Transient используется для объявления того, какие поля</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> у сущности, встраиваемого класса или Mapped SuperClass </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">не будут сохранены в базе данных.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Persistent fields (постоянные поля) - это поля, значения которых будут по умолчанию сохранены в БД. Ими являются любые не static и не final поля.<br>Transient fields (временные поля):<br>❖        static и final поля сущностей;<br>❖        иные поля, объявленные явно с использованием Java-модификатора transient, либо JPA-аннотации @Transient.<br></span></td><td class="s16">Initial user: User{firstName=&#39;Stefan&#39;, lastName=&#39;Smith&#39;<span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, email=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;ssmith@email.com&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, birthDate=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">1991</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">-</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">07</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">-</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">16</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, login=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;ssmith&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, </span><span style="font-size:11pt;font-family:Consolas,Arial;font-weight:bold;color:#ff0000;">password=&#39;gemma_arterton_4ever_in_my_heart91&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">} Loaded user from file: User{firstName=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;Stefan&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, lastName=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;Smith&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, email=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;ssmith@email.com&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, birthDate=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">1991</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">-</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">07</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">-</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">16</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, login=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;ssmith&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, </span><span style="font-size:11pt;font-family:Consolas,Arial;font-weight:bold;color:#ff0000;">password=&#39;null&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">}</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R66" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">67</div></th><td class="s3" rowspan="4">Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?</td><td class="s4">В порядке от самого ненадежного и быстрого, до самого надежного и медленного:<br>1.        <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">NONE </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— без блокировки.<br>2.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">OPTIMISTIC </span><span style="font-size:10pt;font-family:Arial;color:#000000;">(синоним READ в JPA 1) — оптимистическая  блокировка, которая работает, как описано ниже: если при завершении транзакции кто-то извне изменит поле @Version, то будет сделан RollBack транзакции и будет выброшено OptimisticLockException.<br>3.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">OPTIMISTIC_FORCE_INCREMENT </span><span style="font-size:10pt;font-family:Arial;color:#000000;">(синоним WRITE в JPA 1) — работает по тому же алгоритму, что и LockModeType.OPTIMISTIC за тем исключением, что после commit значение поле Version принудительно увеличивается на 1. В итоге окончательно после каждого коммита поле увеличится на 2(увеличение, которое можно увидеть в Post-Update + принудительное увеличение).<br>4.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">PESSIMISTIC_READ </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— данные блокируются в момент чтения и это гарантирует, что никто в ходе выполнения транзакции не сможет их изменить. Остальные транзакции, тем не менее, смогут параллельно читать эти данные. Использование этой блокировки может вызывать долгое ожидание блокировки или даже выкидывание PessimisticLockException.<br>5.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">PESSIMISTIC_WRITE</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — данные блокируются в момент записи и никто с момента захвата блокировки </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">не может в них писать и не может их читать</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> до окончания транзакции, владеющей блокировкой. Использование этой блокировки может вызывать долгое ожидание блокировки.<br>6.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">PESSIMISTIC_FORCE_INCREMENT </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— ведёт себя как PESSIMISTIC_WRITE, но в конце транзакции увеличивает значение поля @Version, даже если фактически сущность не изменилась.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Блокировка - в реляционных базах данных это установка метки на запись, что запись заблокирована для изменений.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R67" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">68</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Оптимистичное блокирование</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - подход предполагает, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">что параллельно выполняющиеся транзакции редко обращаются к одним и тем же данным и позволяет им свободно выполнять любые чтения и обновления данных.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Но при окончании транзакции производится проверка, изменились ли данные в ходе выполнения данной транзакции и, если да, транзакция обрывается и выбрасывается OptimisticLockException. Оптимистичное блокирование в JPA реализовано путём внедрения в сущность специального поля версии:<br>    @Version<br>    private long version;<br>Поле, аннотирование @Version, может быть целочисленным или временнЫм. При завершении транзакции, если сущность была заблокирована оптимистично, будет проверено, не изменилось ли значение @Version кем-либо ещё, после того как данные были прочитаны, и, если изменилось, будет выкинуто OptimisticLockException. Использование этого поля позволяет отказаться от блокировок на уровне базы данных и сделать всё на уровне JPA, улучшая уровень конкурентности.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Позволяет отказатьсь от блокировок на уровне БД и делать всё с JPA.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R68" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">69</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Пессимистичное блокирование</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - подход напротив, ориентирован на транзакции, которые часто конкурируют за одни и те же данные и поэтому блокирует доступ к данным в тот момент когда читает их. Другие транзакции останавливаются, когда пытаются обратиться к заблокированным данным и ждут снятия блокировки (или кидают исключение). </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Пессимистичное блокирование выполняется на уровне базы и поэтому не требует вмешательств в код сущности.</span></td><td class="s1"></td><td class="s7">Filter vs. Interceptor ❖ Перехватчик основан на механизме Reflection, а фильтр основан на обратном вызове функции. ❖ Фильтр зависит от контейнера сервлета, тогда как перехватчик не зависит от него. ❖ Перехватчики могут работать только с запросами к контроллерам, в то время как фильтры могут работать почти со всеми запросами (например, js, .css и т.д.). ❖ Перехватчики в отличии от фильтров могут обращаться к объектам в контейнере Spring, что даёт им более изощренный функционал</td></tr><tr style="height: 20px"><th id="0R69" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">70</div></th><td class="s4">Блокировки ставятся путём вызова метода lock() у EntityManager, в который передаётся сущность, требующая блокировки и уровень блокировки:<br>EntityManager em = entityManagerFactory.createEntityManager();<br>em.lock(company1, LockModeType.OPTIMISTIC);</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R70" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">71</div></th><td class="s3" rowspan="4">Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?</td><td class="s4">1. first-level cache (кэш первого уровня) — кэширует данные одной транзакции;<br>2. second-level cache (кэш второго уровня) —<span style="font-size:10pt;font-family:Arial;color:#ff0000;"> кэширует данные транзакций от одной фабрики сессий.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Провайдер JPA может, но не обязан реализовывать работу с кэшем второго уровня.<br>3. Кэш запросов.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R71" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">72</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Кэш первого уровня</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> – </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">это кэш сессии (Session), который является обязательным, это и есть PersistenceContext</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Через него проходят все запросы.<br>В том случае, если мы выполняем несколько обновлений объекта, Hibernate старается отсрочить (насколько это возможно) обновление этого объекта для того, чтобы сократить количество выполненных запросов в БД. Например, при пяти истребованиях одного и того же объекта из БД в рамках одного persistence context, запрос в БД будет выполнен один раз, а остальные четыре загрузки будут выполнены из кэша. Если мы закроем сессию, то все объекты, находящиеся в кэше, теряются, а далее – либо сохраняются в БД, либо обновляются.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R72" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">73</div></th><td class="s4">Особенности кэша первого уровня:<br>❖        включен по умолчанию, его нельзя отключить;<br>❖        связан с сессией (контекстом персистентности), то есть разные сессии видят только объекты из своего кэша, и не видят объекты, находящиеся в кэшах других сессий;<br>❖        при закрытии сессии PersistenceContext очищается - кэшированные объекты, находившиеся в нем, удаляются;<br>❖        при первом запросе сущности из БД, она загружается в кэш, связанный с этой сессией;<br>❖        если в рамках этой же сессии мы снова запросим эту же сущность из БД, то она будет загружена из кэша, и никакого второго SQL-запроса в БД сделано не будет;<br>❖        сущность можно удалить из кэша сессии методом evict(), после чего следующая попытка получить эту же сущность повлечет обращение к базе данных;<br>❖        метод clear() очищает весь кэш сессии.</td><td class="s7"><span style="font-size:10pt;font-family:Arial;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#000000;">load() или объекта с лениво загружаемыми полями</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, лениво загружаемые данные в кэш не попадут, а вместо этих данных</span><span style="font-size:10pt;font-family:Arial;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#000000;"> Hibernate создаст объект Proxy</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Однако, </span><span style="font-size:10pt;font-family:Arial;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#000000;">как только мы обратимся к этому прокси-объекту в рамках этого же открытого контекста персистентности, Hibernate всё-таки выполнит запрос в базу и данные будут загружены и в объект и в кэш</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. А вот следующая попытка лениво загрузить объект приведёт к тому, что объект сразу вернут из кэша уже полностью загруженным, без обращения в БД.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R73" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">74</div></th><td class="s4">Если кэш первого уровня привязан к объекту сессии, то <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">кэш второго уровня</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> привязан к объекту-фабрике сессий</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">(Session Factory object) и, следовательно, кэш второго уровня доступен одновременно в нескольких сессиях или контекстах персистентности.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Кэш второго уровня требует некоторой настройки и поэтому не включен по умолчанию. Настройка кэша заключается в конфигурировании реализации кэша и разрешения сущностям быть закэшированными.<br>Hibernate не реализует сам никакого in-memory сache, а использует существующие реализации кэшей.<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R74" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">75</div></th><td class="s3" rowspan="3">Как работать с кешем 2 уровня?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R75" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">76</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#ff0000;">В Hibernate кэширование второго уровня реализовано в виде абстракции, то есть мы должны предоставить любую её реализацию, вот несколько провайдеров: Ehcache</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, OSCache, SwarmCache, JBoss TreeCache. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Для Hibernate требуется только реализация интерфейса org.hibernate.cache.spi.RegionFactory, который инкапсулирует все детали, относящиеся к конкретным провайдерам. По сути, RegionFactory действует как мост между Hibernate и поставщиками кэша. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">В примерах будем использовать Ehcache. Что нужно сделать: ❖ добавить мавен-зависимость кэш-провайдера нужной версии ❖ включить кэш второго уровня и определить конкретного провайдера hibernate.cache.use_second_level_cache=true hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory ❖ установить у нужных сущностей JPA-аннотацию @Cacheable, обозначающую, что сущность нужно кэшировать, и Hibernate-аннотацию @Cache, настраивающую детали кэширования, у которой в качестве параметра указать стратегию параллельного доступа&quot; на &quot;Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня. Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Shared Cache Mode</span><span style="font-size:10pt;font-family:Arial;color:#000000;">  </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">ENABLE_SELECTIVE,  ALL, NONE, UNSPECIFIED</span></td><td class="s1"></td><td class="s5">Процесс аутентификации: 1. UsernamePasswordAuthenticationFilter получают имя пользователя и пароль и создает экземпляр класса UsernamePasswordAuthenticationToken (экземпляр интерфейса Authentication). 2. Токен передается экземпляру AuthenticationManager для проверки. 3. AuthenticationManager возвращает полностью заполненный экземпляр Authentication в случае успешной аутентификации. 4. Устанавливается контекст безопасности путем вызова SecurityContextHolder.getContext().setAuthentication(...), куда передается вернувшийся экземпляр Authentication. 5. При успешной аутентификации можно использовать successHandler</td></tr><tr style="height: 20px"><th id="0R76" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">77</div></th><td class="s4">Стратегии параллельного доступа к объектам Проблема заключается в том, что кэш второго уровня доступен из нескольких сессий сразу и несколько потоков программы могут одновременно в разных транзакциях работать с одним и тем же объектом. Следовательно надо как-то обеспечивать их одинаковым представлением этого объекта. ❖<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> READ_ONLY: Используется только для сущностей, которые никогда не изменяются</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> (будет выброшено исключение, если попытаться обновить такую сущность). Очень просто и производительно. Подходит для некоторых статических данных, которые не меняются. ❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">NONSTRICT_READ_WRITE</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: К</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">эш обновляется после совершения транзакции, которая изменила данные в БД и закоммитила их.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Таким образом, строгая согласованность не гарантируется, и существует небольшое временное окно между обновлением данных в БД и обновлением тех же данных в кэше, во время которого параллельная транзакция может получить из кэша устаревшие данные. ❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">READ_WRITE</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: Эта стратегия гарантирует строгую согласованность, которую она достигает, используя «мягкие» блокировки: </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">когда обновляется кэшированная сущность, на нее накладывается мягкая блокировка, которая снимается после коммита транзакции.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Все параллельные транзакции, которые пытаются получить доступ к записям в кэше с наложенной мягкой блокировкой, не смогут их прочитать или записать и отправят запрос в БД. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Ehcache использует эту стратегию по умолчанию. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">TRANSACTIONAL: полноценное разделение транзакций. Каждая сессия и каждая транзакция видят объекты, словно они работали с ними последовательно одна транзакция за другой. Плата за это — блокировки и потеря производительности</span></td><td class="s17 softmerge"><div class="softmerge-inner" style="width:657px;left:-1px">Hibernate Proxy используется для замены реальной сущности POJO (Plain Old Java Object).</div></td><td class="s12"></td></tr><tr style="height: 20px"><th id="0R77" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">78</div></th><td class="s3" rowspan="3">Что такое JPQL/HQL и чем он отличается от SQL?</td><td class="s4">Hibernate Query Language (HQL) и Java Persistence Query Language (JPQL) - оба являются объектно-ориентированными языками запросов, схожими по природе с SQL. <br><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">JPQL - это подмножество HQL.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R78" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">79</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">HQL - это язык запросов, практически такой же как SQL,</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">однако, вместо имен и колонок таблиц базы данных, он использует имена классов Entity и их атрибуты.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> В качестве параметров запросов также используются типы данных атрибутов Entity, а не полей баз данных. В отличии от SQL в JPQL есть автоматический полиморфизм, то есть к</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">аждый запрос к Entity возвращает не только объекты этого Entity, но также объекты всех его классов-потомков</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, независимо от стратегии наследования. В JPA запрос представлен в виде javax.persistence.Query или javax.persistence.TypedQuery, полученных из EntityManager. </span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R79" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">80</div></th><td class="s4">В Hibernate HQL-запрос представлен org.hibernate.query.Query, полученный из Session. Если HQL является именованным запросом, то будет использоваться Session#getNamedQuery, в противном случае требуется Session#createQuery.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R80" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">81</div></th><td class="s3" rowspan="2">Что такое Criteria API и для чего он используется?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">JPA Criteria API - это API, который позволяет делать WHERE (SELECT) запросы гораздо проще. (Динамические запросы). </span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Основные преимущества JPA Criteria API:<br>❖        ошибки могут быть обнаружены во время компиляции;<br>❖        позволяет динамически формировать запросы на этапе выполнения приложения.<br>Основные недостатки:<br>❖        нет контроля над запросом, сложно отловить ошибку<br>❖        влияет на производительность, множество классов<br><br>Для динамических запросов - фрагменты кода создаются во время выполнения - JPA Criteria API является предпочтительней. </span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R81" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">82</div></th><td class="s4">Вот некоторые области применения Criteria API:<br>Criteria API поддерживает проекцию, которую мы можем использовать для агрегатных функций вроде sum(), min(), max() и т.д.<br>Criteria API может использовать ProjectionList для извлечения данных только из выбранных колонок.<br>Criteria API может быть использована для join запросов с помощью соединения нескольких таблиц, используя методы createAlias(), setFetchMode() и setProjection().<br>Criteria API поддерживает выборку результатов согласно условиям (ограничениям). Для этого используется метод add() с помощью которого добавляются ограничения (Restrictions).<br>Criteria API позволяет добавлять порядок (сортировку) к результату с помощью метода addOrder().        </td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R82" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">83</div></th><td class="s3" rowspan="6">Расскажите про проблему N+1 Select и путях ее решения.</td><td class="s4">Проблема N+1 запросов возникает, <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">когда получение данных из БД выполняется за N дополнительных SQL-запросов для извлечения тех же данных, которые могли быть получены при выполнении основного SQL-запроса</span><span style="font-size:10pt;font-family:Arial;color:#000000;">.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Проблема N + 1 возникает, когда фреймворк доступа к данным выполняет N дополнительных SQL-запросов для получения тех же данных, которые можно получить при выполнении одного SQL-запроса.<br>Чем больше значение N, тем больше запросов будет выполнено и тем больше влияние на производительность. И хотя лог медленных запросов может вам помочь найти медленные запросы, но проблему N + 1 он не обнаружит, так как каждый отдельный дополнительный запрос выполняется достаточно быстро. <br>Проблема заключается в выполнении множества дополнительных запросов, которые в сумме выполняются уже существенное время, влияющее на быстродействие.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R83" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">84</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#000000;">1. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">       JOIN FETCH</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>И при FetchType.EAGER и при FetchType.LAZY нам поможет JPQL-запрос с JOIN FETCH. Опцию «FETCH» можно использовать в JOIN (INNER JOIN или LEFT JOIN) для выборки связанных объектов в одном запросе вместо дополнительных запросов для каждого доступа к ленивым полям объекта.<br>Лучший вариант решения для простых запросов (1-3 уровня вложенности связанных объектов).<br><br>select pc<br>    from PostComment pc<br>    join fetch pc.post p</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R84" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">85</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#000000;">2.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">EntityGraph</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>В случаях, когда нам нужно получить по-настоящему много данных, и у нас jpql запрос - лучше всего использовать EntityGraph.<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R85" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">86</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#000000;">3.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Fetch(FetchMode.SUBSELECT)</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Аннотация Hibernate. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Можно использовать только с коллекциями.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций:<br><br>@Fetch(value = FetchMode.SUBSELECT)<br>    private Set&lt;Order&gt; orders = new HashSet&lt;&gt;();</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R86" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">87</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#000000;">4.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Batch fetching</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Это Аннотация Hibernate, в JPA её нет. Указывается над классом сущности или над полем коллекции с ленивой загрузкой. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций. Количество загружаемых сущностей указывается в аннотации.<br><br>@BatchSize(size=5)<br>private Set&lt;Order&gt; orders = new HashSet&lt;&gt;();</span></td><td class="s5">Хотя использовать @BatchSize лучше, чем столкнуться с проблемой запроса N+1, в большинстве случаев гораздо лучшей альтернативой является использование DTO или JOIN FETCH, поскольку они позволяют получать все необходимые данные одним запросом.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R87" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">88</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#000000;">5.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">HibernateSpecificMapping, SqlResultSetMapping</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Для нативных запросов рекомендуется использовать именно их.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R88" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">89</div></th><td class="s3" rowspan="2">Что такое Entity Graph</td><td class="s18"><span style="font-size:10pt;font-family:Arial;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#000000;">Он позволяет определить шаблон путем группировки связанных полей, которые мы хотим получить, и позволяет нам выбирать тип графа во время выполнения</span><span style="font-size:10pt;font-family:Arial;color:#000000;">.Основная цель JPA Entity Graph - улучшить производительность в рантайме при<br>загрузке базовых полей сущности и связанных сущностей и коллекций. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Вкратце, Hibernate загружает весь граф в одном SELECT-запросе, то есть все<br>указанные связи от нужной нам сущности. . Работа с EntityGraph: createEntityGraph, getEntityGraph.<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R89" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">90</div></th><td class="s19"></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R90" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">91</div></th><td class="s20"></td><td class="s5">4.        Логика при регистрации бинов управляется набором @ConditionalOn* аннотаций. Можно указать, чтобы бин создавался при наличии класса в classpath (@ConditionalOnClass), наличии существующего бина (@ConditionalOnBean), отсуствии бина (@ConditionalOnMissingBean) и т.п. Таким образом наличие конфигурации не значит, что бин будет создан и зачастую конфигурация ничего делать и создавать не будет.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R91" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">92</div></th><td class="s20"></td><td class="s5">5.        Созданный в итоге <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">AnnotationConfig</span><span style="font-size:10pt;font-family:Arial;color:#000000;">EmbeddedWeb</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ApplicationContext</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> ищет в том же DI контейнере фабрику для запуска embedded servlet container.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R92" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">93</div></th><td class="s21"></td><td class="s18">6.        Servlet container запускается, приложение готово к работе</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R93" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">94</div></th><td class="s21">Расскажите про нововведения Spring 5.</td><td class="s18">●        Используется JDK 8+ (Optional, CompletableFuture, Time API, java.util.function, default methods)<br>●        Поддержка Java 9 (Automatic-Module-Name in 5.0, module-info in 6.0+, ASM 6)<br>●        Поддержка HTTP/2 (TLS, Push), NIO/NIO.2<br>●        Поддержка Kotlin<br>●        Реактивность (веб-инфраструктура с реактивным стеком, «Spring WebFlux»)<br>●        Null-safety аннотации(@Nullable), новая документация<br>●        Совместимость с Java EE 8 (Servlet 4.0, Bean Validation 2.0, JPA 2.2, JSON Binding API 1.0)<br>●        Поддержка JUnit 5 + Testing Improvements (conditional and concurrent)<br>●        Удалена поддержка: Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R94" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">95</div></th><td class="s21"> Расскажите про аннотацию @ComponentScan</td><td class="s5"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Аннотация @ComponentScan используется вместе с аннотацией @Configuration для указания пакетов, которые мы хотим сканировать на наличие компонентов, из которых нужно сделать бины.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@ComponentScan без аргументов указывает Spring по умолчанию сканировать текущий пакет и все его подпакеты.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Текущий пакет - тот, в котором находится файл конфигурации с этой самой аннотацией @ComponentScan. В данном случае в контейнер попадут: ❖ бин конфигурационного класса; ❖ бины, объявленные в конфигурационном классе с помощью @Bean; ❖ все бины из пакета и его подпакетов. Аннотация @SpringBootApplication включает в себя аннотации @ComponentScan, @SpringBootConfiguration и @EnableAutoConfiguration, но это не мешает разместить её ещё раз отдельно для указания конкретного пакета. Если указать @ComponentScan с атрибутом basePackages, то это изменит пакет по умолчанию на указанный</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R95" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">96</div></th><td class="s1"></td><td class="s22">Java Servlet API — стандартизированный API, предназначенный для реализации на сервере и работе с клиентом по схеме запрос-ответ. Сервлет — это класс, который умеет получать запросы от клиента и возвращать ему ответы. Да, сервлеты в Java — именно те элементы, с помощью которых строится клиент-серверная архитектура.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R96" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">97</div></th><td class="s23">Что делает аннотация @RequestMapping?</td><td class="s24"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#111111;">Используется только для указания URI до класса-контроллера.</span><span style="font-size:10pt;font-family:Arial;color:#111111;"> @RestController<br>@RequestMapping(&quot;/api/coupon&quot;)</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R97" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">98</div></th><td class="s23">Аннотация @RequestParam?</td><td class="s5"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Эта аннотация используется для того, чтобы методы обработчики могли получить параметры из http-запроса. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Запрос с параметрами: http://localhost:8080/getByName/name=Ivan. Следующий код поместит в переменную name строку Ivan.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R98" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">99</div></th><td class="s23">Аннотация @PathVariable?</td><td class="s5">Эта <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">аннотация получает определенную часть из URI</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. URI: http://localhost:8080/getById/23 Следующий код поместит в переменную id значение 23.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R99" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">100</div></th><td class="s23">@RequestBody?</td><td class="s5">@RequestBody, Spring на лету попытается преобразовать содержимое тела входящего запроса в ваш объект параметра.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R100" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">101</div></th><td class="s23">Аннотация @ResponseStatus?</td><td class="s24">Она позволяет устанавливать код ответа. Обычно Spring сам устанавливает нужный код ответа, но бывают моменты, когда это нужно переопределить.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R101" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">102</div></th><td class="s23">RestTemplate? Какие у него преимущества?</td><td class="s5">RestTemplate это специальный клиент в Spring для отправки http-запросов. Он предоставляет удобные API для легкого вызова конечных точек REST’а в одну строку.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R102" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">103</div></th><td class="s23">GET_POST_PUT_DELETE_PATCH</td><td class="s5">@GetMapping — Обрабатывает get-запросы(чтение) @PostMapping — Обрабатывает post-запросы (создание)@DeleteMapping — Обрабатывает delete-запросы @PutMapping — Обрабатывает put-запросы(обновление) @PatchMapping — Обрабатывает patch-запросы</td><td class="s5">PUT — изначально существовавший в стандарте метод, предполагающий полную замену изменяемого объекта. Соответственно в методе PUT, как я и писал выше, придётся указать даже те атрибуты объекта, которые не меняются.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R103" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">104</div></th><td class="s23">@GetMapping</td><td class="s5">Аннотация @GetMapping — это просто аннотация которая содержит @RequestMapping(method = RequestMethod.GET). Она также позволяет более глубоко настроить метод-обработчик. Ее параметры(они конвертируются в аналогичные параметры @RequestMapping):<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> path — URI, headers — заголовки, name — имя обработчика params — параметры , produces — тип возвращаемых данных(JSON, XML, текст). Используется в REST, consumes — тип принимаемых данных. Используется в REST</span></td><td class="s1">@ApiOperation — описывает метод контроллера</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R104" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">105</div></th><td class="s23">Что обозначают разные коды для http-ответов?</td><td class="s5">GET — 200 OK POST — 200 OK, 201 Created, 204 No Content PUT — 200 OK, 201 Created, 204 No Content DELETE — 204 No Content, 202 Accepted</td><td class="s1"></td><td class="s1"></td></tr></tbody></table></div>