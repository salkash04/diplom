<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s1{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#cfe2f3;text-align:center;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s22{background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s32{background-color:#ffffff;text-align:left;color:#3e5656;font-family:"docs-Liberation Sans",Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s0{border-bottom:1px SOLID transparent;border-right:1px SOLID transparent;background-color:#3d85c6;text-align:center;font-weight:bold;color:#ffffff;font-family:Arial;font-size:14pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s2{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s19{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:middle;white-space:nowrap;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s21{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;font-weight:bold;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s20{background-color:#ffffff;text-align:left;font-weight:bold;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s9{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#ff0000;font-family:Arial;font-size:10pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s26{border-bottom:1px SOLID transparent;border-right:1px SOLID transparent;background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s12{background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s17{background-color:#ffffff;text-align:left;font-weight:bold;color:#333333;font-family:"docs-Liberation Sans",Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s29{border-bottom:1px SOLID transparent;background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0;}.ritz .waffle .s4{background-color:#ffffff;text-align:left;font-weight:bold;color:#333333;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s3{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s5{border-bottom:1px SOLID transparent;border-right:1px SOLID transparent;background-color:#cfe2f3;text-align:center;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s18{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s15{background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s25{border-right:1px SOLID transparent;background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0;}.ritz .waffle .s28{background-color:#ffffff;text-align:left;color:#3e5656;font-family:Verdana;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s31{background-color:#ffffff;text-align:left;color:#111111;font-family:"docs-Liberation Sans",Arial;font-size:12pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s24{border-bottom:1px SOLID transparent;background-color:#ffffff;text-align:left;font-weight:bold;color:#3e5656;font-family:"docs-Liberation Sans",Arial;font-size:10pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s13{border-bottom:1px SOLID transparent;background-color:#ffffff;}.ritz .waffle .s7{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0;}.ritz .waffle .s14{border-bottom:1px SOLID transparent;border-right:1px SOLID transparent;background-color:#ffff00;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s11{background-color:#ffffff;text-align:left;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#8b8948;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s8{background-color:#ffffff;text-align:left;font-weight:bold;color:#333333;font-family:Arial;font-size:12pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s30{background-color:#ffffff;text-align:left;font-weight:bold;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s10{background-color:#ffffff;text-align:left;color:#c3cbd2;font-family:docs-Consolas,Arial;font-size:14pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s16{background-color:#ffffff;text-align:left;color:#3e5656;font-family:"Times New Roman";font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s23{background-color:#ffffff;text-align:left;color:#24292f;font-family:"docs-Liberation Sans",Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s27{background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0;}.ritz .waffle .s6{border-bottom:1px SOLID transparent;background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-origin-ltr"></th><th id="1554587176C0" style="width:247px;" class="column-headers-background">A</th><th id="1554587176C1" style="width:872px;" class="column-headers-background">B</th><th id="1554587176C2" style="width:465px;" class="column-headers-background">C</th><th id="1554587176C3" style="width:373px;" class="column-headers-background">D</th><th id="1554587176C4" style="width:100px;" class="column-headers-background">E</th><th id="1554587176C5" style="width:100px;" class="column-headers-background">F</th><th id="1554587176C6" style="width:100px;" class="column-headers-background">G</th><th id="1554587176C7" style="width:100px;" class="column-headers-background">H</th><th id="1554587176C8" style="width:100px;" class="column-headers-background">I</th><th id="1554587176C9" style="width:100px;" class="column-headers-background">J</th><th id="1554587176C10" style="width:100px;" class="column-headers-background">K</th><th id="1554587176C11" style="width:100px;" class="column-headers-background">L</th></tr></thead><tbody><tr style="height: 20px"><th id="1554587176R0" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">1</div></th><td class="s0" colspan="2">Core-2</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R1" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">2</div></th><td class="s1">Что такое дженерики?</td><td class="s2">Дженерики – это параметризованные типы.<br>С их помощью можно объявлять классы, интерфейсы и методы, в которых тип данных указан в виде параметра.<br>Используя дженерики, можно создать единственный класс, который будет автоматически работать с разными типами данных.<br>Эта информация доступна только на этапе компиляции и стирается в runtime, и в байт код попадет только информация о том, что в программе есть некий список List&lt;Object&gt; list вместо List&lt;String&gt; list, например.<br>Появились в версии 1.5 </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R2" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">3</div></th><td class="s1">Для чего нужны дженерики?</td><td class="s2">Для строгой типизации и проверки на этапе компиляции.<br>Дженерики позволяют передавать тип объекта компилятору в форме &lt;тип&gt;. Таким образом, компилятор может выполнить все необходимые действия по проверке типов во время компиляции, обеспечивая безопасность по приведению типов во время выполнения.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R3" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">4</div></th><td class="s1">Что такое сырые типы (raw type)?</td><td class="s3">Сырые типы — это типы без указания типа в фигурных скобках ( List list = new ArrayList&lt;&gt;() ), они использовались до появления дженериков.<br>Не указывая их, под капотом используется Object. </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R4" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">5</div></th><td class="s1">Что такое вайлдкарды? </td><td class="s2">Маске (wildcard) можно задать ограничения (Преодолеть инвариантность дженериков):<br>-<span style="font-size:10pt;font-family:Arial;font-weight:bold;">“? extends T”</span><span style="font-size:10pt;font-family:Arial;"> (для получения в методе)  - объект, который наследуется от Т, либо сам Т – ковариантность.<br>Если контейнер объявлен ? extends T, то можно только читать значения. В список нельзя ничего добавить, кроме null.<br>-</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">“? super T”</span><span style="font-size:10pt;font-family:Arial;"> (для отдачи в методе) - любой объект подтипа Т, включая Т – контравариантность. Нельзя прочитать элемент из контейнера с wildcard ? super, кроме объекта класса Object<br><br>При использовании ? мы сообщаем компилятору, чтобы он игнорировал информацию о типе, т.е. &lt;?&gt; - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">неограниченный символ подстановки</span><span style="font-size:10pt;font-family:Arial;">. &lt;?&gt; означает то же что и &lt;? extends Object&gt;, т.е. принимает всё. Это можно обойти, создав обобщенный метод, объявленный с переменной типа T.<br></span></td><td class="s4">Wildcards<span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#333333;"> – специальные вопросительные знаки, отмечающие место, где должно оказаться название параметра типа</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R5" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">6</div></th><td class="s5">Расскажите про принцип PECS</td><td class="s6">Producer Extends Consumer Super<br>wildcard подстановочный знак:<br> Если мы объявили wildcard с <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">extends,</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> то это producer. Он только «производит», предоставляет элемент из контейнера, а сам ничего не принимает.<br> Если же мы объявили wildcard с </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">super</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> — то это consumer. Он только принимает, а предоставить ничего не может.<br><br>Иначе говоря:<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Если вы только получаете объекты из дженерик-коллекции - это producer и надо использвовать extends.<br>Если вы только кладете объекты в коллекцию - это consumer и надо использовать super.<br>Если вы делаете оба эти действия, то не надо использовать ни super, ни extends.</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R6" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">7</div></th><td class="s0" colspan="2">Коллекции</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R7" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">8</div></th><td class="s1">Что такое «коллекция»?</td><td class="s2">Коллекция – это объект, который содержит набор объектов одного типа. Каждый из этих объектов в коллекции называется элементом.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 433px"><th id="1554587176R8" style="height: 433px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 433px">9</div></th><td class="s1">Расскажите про иерархию коллекций</td><td class="s7"><div style="width:872px;height:433px;"><img src="https://lh7-rt.googleusercontent.com/sheetsz/AHOq17EzdNuKPoOQG70Fyni2AKM0lKpETCfzPTAl_bdvHPDdXZIiySlxokIARQv-bOFD7mqnnRI4L8M5ODtVgkdQoS0qa43sw88qCXeCu0vHSb2a0Sr0IRfkSJroIT2bzPV03rdqX4IbWGRF7shMwDZqOxsWqajajF9GHIjWcQx2Rg=w872-h433?key=hmZU6X5bC09eoSadsn6fkQ" style="width:inherit;height:inherit;object-fit:scale-down;object-position:left center;"/></div></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R9" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">10</div></th><td class="s1">Почему Map — это не Collection, в то время как List и Set являются Collection?</td><td class="s2">Коллекция (List и Set) <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">представляет собой совокупность</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> некоторых элементов (обычно </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">экземпляров одного класса</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">).Map -это совокупность пар &quot;ключ&quot;-&quot;значение&quot;.<br>У map нет итерабл, не понятно по чему проводить итерацию</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R10" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">11</div></th><td class="s1">В чем разница между java.util.Collection и java.util.Collections?</td><td class="s2"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Класс </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">java.util.Collections</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">содержит исключительно статические методы для работы с коллекциями.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> <br>В них входят методы, реализующие полиморфные алгоритмы (такие алгоритмы, использование которых возможно с разными видами структур данных), &quot;оболочки&quot;, возвращающие новую коллекцию с инкапсулированной указанной структурой данных и некоторые другие методы. <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">java.util.Collection</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">это корневой интерфейс Java Collections Framework</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. Этот интерфейс в основном п</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">рименяется там, где требуется высокий уровень абстракции</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, например, в классе java.util.Collections.</span></td><td class="s8"></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R11" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">12</div></th><td class="s1">Какая разница между итераторами с fail-fast и fail-safe поведением? (С примерами)</td><td class="s9">Итератор fail-safe не вызывает исключений при изменении структуры коллекции, потому что работает с её клоном.<br>Пример fail-safe - CopyOnWriteArrayList (он создал отдельную копию )и итератор (keySet коллекции ConcurrentHashMap - не создает отдельную копию).<br><br>Итератор fail-fast генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, но работает быстрее.<br>Пример fail-fast - Vector и Hashtable.</td><td class="s10"><span style="font-size:14pt;font-family:Consolas,Arial;color:#00b050;">List&lt;String&gt; cities = </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#00b050;">new</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#00b050;"> ArrayList&lt;&gt;(); </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#0070c0;">cities.add(“Warsaw”); cities.add(“Prague”); cities.add(“Budapest”); </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#814e0f;">Iterator&lt;String&gt; cityIterator = cities.iterator(); </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#0070c0;">cityIterator.next(); </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#ff0000;">cities.remove(1); </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#0070c0;">cityIterator.next();</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#c3cbd2;"> </span><span style="font-size:14pt;font-family:Consolas,Arial;">// генерирует ConcurrentModificationException</span></td><td class="s11"><a target="_blank" href="http://espressocode.top/fail-fast-fail-safe-iterators-java/">http://espressocode.top/fail-fast-fail-safe-iterators-java/</a></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 190px"><th id="1554587176R12" style="height: 190px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 190px">13</div></th><td class="s1">Чем различаются Enumeration и Iterator?</td><td class="s2">Iterator имеет больше методов работы с коллекциями и был специально введен в java2, вместо Enumeration(interface). Рекоммендуется юзать Iterator.<br><br>Оба интерфейса предназначены для обхода коллекции, но есть различия:<br>-с помощью Enumeration нельзя удалять элементы;<br>-в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д);<br>-Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных коллекциях.<br></td><td class="s12"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#00b050;">Методы Iterator</span><span style="font-size:10pt;font-family:Arial;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">forEachRemaining(Consumer&lt;? super E&gt;action)</span><span style="font-size:10pt;font-family:Arial;"> Он выполняет действия над каждым элементом до тех пор, пока все элементы не будут обработаны. Также до тех пор, пока действие не создаст исключение. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">hasNext()</span><span style="font-size:10pt;font-family:Arial;"> Возвращает истинное значение, если во время итерации встречается большое количество элементов.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;"> next() </span><span style="font-size:10pt;font-family:Arial;">Возвращает следующий указанный элемент во время итерации. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">remove()</span><span style="font-size:10pt;font-family:Arial;"> Этот метод удаляет текущий элемент. Создает исключение IllegalStateException, если предпринята попытка вызвать метод remove(), которому не предшествует вызов метода next(). </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">boolean hasNext()</span><span style="font-size:10pt;font-family:Arial;"> Возвращает true, если итерация содержит больше элементов. </span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R13" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">14</div></th><td class="s1">Как между собой связаны Iterable, Iterator и «for-each»?</td><td class="s2">Интерфейс Iterable имеет метод - iterator(), с типом возвращаемого значения - интерфейс Iterator.<br>Экземпляры классов, реализующих интерфейс Iterable, могут использоваться в цикле foreach.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R14" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">15</div></th><td class="s1">Можно ли итерируясь по ArrayList удалить элемент? Какое вылетит исключение?</td><td class="s2"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Можно, но нужно использовать iterator.remove()</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Иначе </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">при прохождении по ArrayList в цикле for сразу после удаления элемента будет </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">ConcurrentModificationException.</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R15" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">16</div></th><td class="s1">Как поведёт себя коллекция, если вызвать iterator.remove()?</td><td class="s2">Этот метод удаляет текущий элемент. Важный момент заключается в том, что сначала этот элемент необходимо получить с помощью метода next(), если мы вызовем метод remove() до метода next(), то мы получим IllegalStateException.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R16" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">17</div></th><td class="s1">Чем Set отличается от List?</td><td class="s2">Set не добавляет новых методов, только вносит изменения в унаследованные.<br>В частности, метод add() добавляет элемент в коллекцию и возвращает true, если не было такого элемента.<br>Разрешено наличие только одной ссылки типа null. Set не имеет дубликатов List имеет</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R17" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">18</div></th><td class="s1">Расскажите про интерфейс Set.</td><td class="s2"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Интерфейс Set расширяет интерфейс Collection. <br>Set не добавляет новых методов, только вносит изменения унаследованные.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Set - неупорядоченный набор неповторяющихся элементов</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>В частности, метод add() добавляет элемент в коллекцию и возвращает true, если не было такого элемента.<br>Разрешено наличие только одной ссылки типа null.</span></td><td class="s13"></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R18" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">19</div></th><td class="s1">Расскажите про реализации интерфейса Set</td><td class="s3">В HashSet порядок добавления элементов будет непредсказуемым - используется хэширование для ускорения выборки.<br>В TreeSet объекты хранятся отсортированными по возрастанию из-за применения к/ч дерева.<br>LinkedHashSet хранит элементы в порядке добавления.</td><td class="s14"></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 189px"><th id="1554587176R19" style="height: 189px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 189px">20</div></th><td class="s1">В чем отличия TreeSet и HashSet?</td><td class="s2">HashSet быстрее, чем TreeSet .<br>В HashSet элементы в случайном порядке, в TreeSet в отсортированном.<br>HashSet обеспечивает постоянную производительность - О(1) - для большинства операций, таких как add () , remove () и contains () , по сравнению с временем log(n), предлагаемым TreeSet.</td><td class="s15"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Бинарное дерево</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> —это иерархическая структура данных, в которой каждый узел имеет значение (оно же является в данном случае и ключом) и ссылки на левого и правого потомка. Узел, находящийся на самом верхнем уровне (не являющийся чьим либо потомком) называется корнем. Узлы, не имеющие потомков (оба потомка которых равны NULL) называются листьями.</span></td><td class="s16">5 правил красно-черных деревьев 1) Каждый узел окрашен либо в красный, либо в черный цвет (в структуре данных узла появляется дополнительное поле - бит цвета). 2) Корень окрашен в черный цвет. 3) Листья(так называемые NULL-узлы) окрашены в черный цвет. 4) Каждый красный узел должен иметь два черных дочерних узла. Нужно отметить, что у черного узла могут быть черные дочерние узлы. Красные узлы в качестве дочерних могут иметь только черные. 5) Пути от узла к его листьям должны содержать одинаковое количество черных узлов(это черная высота).</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 85px"><th id="1554587176R20" style="height: 85px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 85px">21</div></th><td class="s1">Чем LinkedHashSet отличается от HashSet?</td><td class="s2">Основное различие в том, что LinkedHashSet сохраняет порядок вставки элементов, а HashSet - нет. В основе LinkedHashSet лежит LinkedHashMap вместо HashMap. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов</td><td class="s15"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">O(n) </span><span style="font-size:10pt;font-family:Arial;">— линейная сложность Такой сложностью обладает, например, алгоритм поиска наибольшего элемента в не отсортированном массиве</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">.O(log n) </span><span style="font-size:10pt;font-family:Arial;">— логарифмическая сложность Простейший пример — бинарный поиск. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">O(n2)</span><span style="font-size:10pt;font-family:Arial;"> — квадратичная сложность Такую сложность имеет, например, алгоритм сортировки вставками. </span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 121px"><th id="1554587176R21" style="height: 121px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 121px">22</div></th><td class="s1">Что будет, если добавлять элементы в TreeSet по возрастанию?</td><td class="s2">TreeSet все равно в каком порядке вы добавляете в него элементы, так как в основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать и хранить элементы по возрастанию. </td><td class="s17"></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 203px"><th id="1554587176R22" style="height: 203px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 203px">23</div></th><td class="s1" rowspan="2">Как устроен HashSet, сложность основных операций.</td><td class="s18" rowspan="2">Все классы, реализующие интерфейс Set, внутренне поддерживаются реализациями Map. HashSet хранит элементы с помощью HashMap. Значение, которые мы передаем в HashSet, является ключом к объекту HashMap, а в качестве значения используется Object.(значение - константа)</td><td class="s15"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Коэффициент загрузки</span><span style="font-size:10pt;font-family:Arial;"> – показатель того, насколько заполненным может быть HashSet до того момента, когда его емкость автоматически увеличится. Когда количество элементов в HashSet становится больше, чем произведение начальной емкости и коэффициента загрузки, хэш-таблица ре-хэшируется (заново вычисляются хэшкоды элементов, и таблица перестраивается согласно полученным значениям) и количество ячеек в ней увеличивается </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">в 2 раза.</span></td><td class="s12"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">boolean add(E e):</span><span style="font-size:10pt;font-family:Arial;"> добавляет элемент в HashSet, если таковой отсутствует, если же такой элемент уже присутствует, метод возвращает false. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">void clear():</span><span style="font-size:10pt;font-family:Arial;"> удаляет все элементы из множества. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">boolean contains(Object o): </span><span style="font-size:10pt;font-family:Arial;">Возвращает true, если данный элемент присутствует в множестве.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;"> boolean remove(Object o):</span><span style="font-size:10pt;font-family:Arial;"> удаляет данный элемент из множества, если таковой присутствует.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;"> Iterator iterator():</span><span style="font-size:10pt;font-family:Arial;"> возвращает итератор для элементов множества. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">boolean isEmpty()</span><span style="font-size:10pt;font-family:Arial;">: возвращает true, если в множестве нет элементов.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;"> Object clone()</span><span style="font-size:10pt;font-family:Arial;">: выполняет поверхностное клонирование HashSet.</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 266px"><th id="1554587176R23" style="height: 266px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 266px">24</div></th><td class="s15">Может хранить NULL – значения;t (ключ - константа в HashMap). Не может содержать дубликатов.<span style="font-size:10pt;font-family:Arial;font-weight:bold;"> Начальная емкость</span><span style="font-size:10pt;font-family:Arial;"> – изначальное количество ячеек («корзин») в хэш-таблице. Если все ячейки будут заполнены, их количество увеличится автоматически.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Коэффициент загрузки и начальная емкость</span><span style="font-size:10pt;font-family:Arial;"> – два главных фактора, от которых зависит производительность операций с HashSet. Коэффициент загрузки, равный 0,75, в среднем обеспечивает хорошую производительность. Если этот параметр увеличить, тогда уменьшится нагрузка на память (так как это уменьшит количество операций ре-хэширования и перестраивания), но это повлияет на операции добавления и поиска. Чтобы минимизировать время, затрачиваемое на ре-хэширование, нужно правильно подобрать параметр начальной емкости. Если начальная емкость больше, чем максимальное количество элементов, поделенное на коэффициент загрузки, то никакой операции ре-хэширования не произойдет в принципе.</span></td><td class="s12"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">HashSet h = new HashSet();</span><span style="font-size:10pt;font-family:Arial;"> — конструктор по умолчанию. Начальная емкость по умолчанию – 16, коэффициент загрузки – 0,75. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">HashSet h = new HashSet(int initialCapacity)</span><span style="font-size:10pt;font-family:Arial;"> – конструктор с заданной начальной емкостью. Коэффициент загрузки – 0,75. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">HashSet h = new HashSet(int initialCapacity, float loadFactor);</span><span style="font-size:10pt;font-family:Arial;"> — конструктор с заданными начальной емкостью и коэффициентом загрузки. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">HashSet h = new HashSet(Collection C)</span><span style="font-size:10pt;font-family:Arial;"> – конструктор, добавляющий элементы из другой коллекции.</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 267px"><th id="1554587176R24" style="height: 267px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 267px">25</div></th><td class="s1" rowspan="2">Как устроен LinkedHashSet, сложность основных операций.</td><td class="s19"></td><td class="s12"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">LinkedHashSet()</span><span style="font-size:10pt;font-family:Arial;"> : создает пустой связанный набор хэшей с начальной емкостью по умолчанию (16) и коэффициентом загрузки (0,75). </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">LinkedHashSet(int initialCapacity)</span><span style="font-size:10pt;font-family:Arial;"> : создает новый пустой связанный набор хэшей с указанной начальной емкостью и коэффициентом загрузки по умолчанию (0,75). Это вызывает исключение IllegalArgumentException, если начальная емкость меньше 0. LinkedHashSet(int initialCapacity, коэффициент загрузки с плавающей точкой) : создает пустой LinkedHashSet с заданной начальной емкостью и коэффициентом загрузки. Он создает исключение IllegalArgumentException, если начальная емкость меньше нуля или если коэффициент нагрузки не является положительным. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">LinkedHashSet(Коллекция расширяет E&gt; c)</span><span style="font-size:10pt;font-family:Arial;"> : создает новый связанный набор хэшей с теми же элементами, что и в указанной коллекции. Он выдает Исключение NullPointerException , если данная коллекция равна null. расширяет E&gt; c)</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 110px"><th id="1554587176R25" style="height: 110px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 110px">26</div></th><td class="s3">В его основе лежит HashMap. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 209px"><th id="1554587176R26" style="height: 209px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 209px">27</div></th><td class="s1" rowspan="2">Как устроен TreeSet, сложность основных операций.</td><td class="s19"></td><td class="s20">Нельзя добавить null элемент после Java 8                                         Элементы, вставленные в TreeSet должны либо реализовать Comparator интерфейс или, по крайней мере, быть принятым указанным компаратором. <span style="font-size:10pt;font-family:Arial;font-weight:normal;">Все такие элементы должны быть взаимосопоставимыми, т.е. e1.compareTo(e2) или comparator.compare (e1, e2) не должны бросать ClassCastException .</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 110px"><th id="1554587176R27" style="height: 110px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 110px">28</div></th><td class="s21">Время для базовых операций - Логарифмическое время.<br>Гарантирует порядок элементов - в основе лежит красно-черное дерево, которое умеет само себя балансировать.<br>Не предоставляет каких-либо параметров для настройки производительности<br>Предоставляет дополнительные методы для упорядоченного списка: first(), last(), headSet() - до значения (типо все студенты до 3 курса), tailSet() (все студенты после или == 3 курсу)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 202px"><th id="1554587176R28" style="height: 202px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 202px">29</div></th><td class="s1">Расскажите про интерфейс List</td><td class="s2">Контейнеры List хранит элементы в порядке добавления. Интерфейс List дополняет Collection несколькими методами, обеспечивающими вставку и удаление элементов в середине списка. Позволяет хранить дубликаты и null. Каждый элемент имеет индекс.<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"> Это позволяет получить (get) элемент по индексу или задать значением для определённого индекса (set). Методы коллекций add, addAll, remove позволяют указать индекс, с которого необходимо их выполнять. Кроме того, у List есть своя версия итератора, которая называется ListIterator</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. Этот итератор знает про индекс элемента, поэтому он умеет итерироваться не только вперёд, но и назад. Его даже можно создать от определённого места в коллекции. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Скорость LinkedList - O(n) LinkedList — это связанный (Linked) список (List). Каждая запись в связанном списке представлена в виде Entry, которая хранит сами данные, а так же ссылку на следующую (next) и предыдущую (previous) Entry. Таким образом LinkedList реализует &quot;Последовательный доступ&quot; (Sequential Access).</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 242px"><th id="1554587176R29" style="height: 242px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 242px">30</div></th><td class="s1" rowspan="2">Как устроен ArrayList, сложность основных операций.</td><td class="s22"></td><td class="s15"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> Только что созданный объект list, содержит свойства </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">elementData</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> и </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">size.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> Хранилище значений elementData есть ни что иное как массив определенного типа (указанного в generic), в нашем случае String[]. Если вызывается конструктор без параметров, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">то по умолчанию будет создан массив из 10-ти элементов типа Object</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> (с приведением к типу, разумеется). </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">При добавлении 11-го элемента, проверка показывает что места в массиве нет. Соответственно создается новый массив и вызывается System.arraycopy().</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 180px"><th id="1554587176R30" style="height: 180px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 180px">31</div></th><td class="s2"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">ArrayList реализован внутри в виде обычного массива</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"> в его основе лежит массив Object</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. Поэтому при вставке элемента в середину, приходится сначала сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять новый элемент. <br>Механизм автоматического «расширения» массива существует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize() </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Создается новый массив размером, в 1.5 раза больше исходного, плюс один элемент.</span></td><td class="s20">Если необходимо вставлять (или удалять) в середину коллекции много элементов, то лучше использовать LinkedList. Во всех остальных случаях – ArrayList.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 116px"><th id="1554587176R31" style="height: 116px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 116px">32</div></th><td class="s1">Что такое Queue?</td><td class="s2"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Queue - коллекция, предназначенная для хранения элементов в порядке, нужном для их обработки. Очереди обычно, но не обязательно, упорядочивают элементы в FIFO (first-in-first-out) порядке.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">(Добавляется в конец очереди используется из начала)</span></td><td class="s12">В Queue метод add выбросит исключение если мы зайдем за границы очереди и поэтому елси мы этого не хотим допускать используем метод offer. Метод remove выбросит исключение если в очереди не осталось эелементов и чтобы не допускать этого можно использовать poll - вернет null. Element - выводит верхний элемент бросает исключение  peek - не бросает а возвращает null</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R32" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">33</div></th><td class="s1">Что такое Deque? Чем отличается от Queue?</td><td class="s2">Deque - двухстороняя очередь, расширяет queue. Он отличается от Queue тем, что можно добавлять и удалять элементы как в хвосте так и в голове. Количество методов удваивается. Пример:<br> addFirst(E e);<br> addLast(E e);<br>Помимо этого реализации интерфейса Deque могут строится по принципу FIFO, либо LIFO.<br>Реализации и Deque, и Queue обычно не переопределяют методы equals() и hashCode(), а используются методы класса Object, основанные на сравнении ссылок.<br>Рекомендуется использовать вместо устравшего Stack.<br></td><td class="s15"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Stack</span><span style="font-size:10pt;font-family:Arial;">. Добавление элементов осуществляется методом </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">push()</span><span style="font-size:10pt;font-family:Arial;">, а удаление методом </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">pop().                                                                              Отличие двусвязного и односвязного списка?<br>Двусвязный список похож на обычный связный список, только элементы в нем хранят ссылки не только на следующий, но и на предыдущий элемент. Благодаря этому свойству, можно перемещаться по списку вперед и назад.</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R33" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">34</div></th><td class="s1">Приведите пример реализации Deque.</td><td class="s2">Linked list ArrayDeque</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R34" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">35</div></th><td class="s1">Какая коллекция реализует  FIFO?</td><td class="s2">Queue</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R35" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">36</div></th><td class="s1">Какая коллекция реализует  LIFO?</td><td class="s2">Vector, Stack</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R36" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">37</div></th><td class="s1">Оцените количество памяти на хранение одного примитива типа byte в LinkedList?</td><td class="s2">Каждый элемент LinkedList хранит ссылку на предыдущий элемент, следующий элемент и ссылку на данные. Для x32 систем каждая ссылка занимает 32 бита (4 байта). Сам объект типа Node занимает приблизительно 8 байт. Размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. Примитив типа byte занимает 1 байт памяти, но в списке примитивы упаковываются, соответственно получаем еще 8 байт. Таким образом, в x32 JVM около 32 байтов выделяется для хранения одного значения типа byte в LinkedList.<br><br>Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт). Вычисления аналогичны.<br>Посчитать на других переменных!</td><td class="s12">Для 32-битных систем каждая ссылка занимает 32 бита (4 байта). Сам объект (заголовок) вложенного класса Node занимает 8 байт. 4 + 4 + 4 + 8 = 20 байт, а т.к. размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. Примитив типа byte занимает 1 байт памяти, но в JCF примитивы упаковываются: объект типа Byte занимает в памяти 16 байт (8 байт на заголовок объекта, 1 байт на поле типа byte и 7 байт для кратности 8). Также напомню, что значения от -128 до 127 кэшируются и для них новые объекты каждый раз не создаются. Таким образом, в x32 JVM 24 байта тратятся на хранение одного элемента в списке и 16 байт - на хранение упакованного объекта типа Byte. Итого 40 байт. Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт), размер заголовка каждого объекта составляет 16 байт (два машинных слова). Вычисления аналогичны: 8 + 8 + 8 + 16 = 40байт и 24 байта. Итого 64 байта.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R37" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">38</div></th><td class="s1">Оцените количество памяти на хранение одного примитива типа byte в ArrayList?</td><td class="s2">ArrayList основан на массиве. Каждый элемент массива хранит примитивный тип данных - byte, размер которого 1 байт.<br> </td><td class="s23"><span style="font-size:10pt;font-family:&quot;Liberation Sans&quot;,Arial;color:#24292f;">ArrayList</span><span style="font-size:12pt;font-family:&quot;Liberation Sans&quot;,Arial;color:#24292f;"> основан на массиве, для примитивных типов данных осуществляется автоматическая упаковка значения, поэтому 16 байт тратится на хранение упакованного объекта и 4 байта (8 для x64) - на хранение ссылки на этот объект в самой структуре данных. Таким образом, </span><span style="font-size:12pt;font-family:&quot;Liberation Sans&quot;,Arial;color:#24292f;">в x32 JVM 4 байта используются на хранение одного элемента и 16 байт - на хранение упакованного объекта типа </span><span style="font-size:10pt;font-family:&quot;Liberation Sans&quot;,Arial;color:#24292f;">Byte</span><span style="font-size:12pt;font-family:&quot;Liberation Sans&quot;,Arial;color:#24292f;">. Для x64 - 8 байт и 24 байта соответственно.</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 115px"><th id="1554587176R38" style="height: 115px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 115px">39</div></th><td class="s1">Какие существуют реализации Map?</td><td class="s2">TreeMap, HashMap, HashTable, LinkedHashMap</td><td class="s24">Также HashMap допускает хранение null ключей и значений, но недопускает дублей ключей. Следует помнить, что для null-ключа hashCode() всегда равен нулю.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 161px"><th id="1554587176R39" style="height: 161px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 161px">40</div></th><td class="s1" rowspan="2">Как устроена HashMap, сложность основных операций? (Расскажите про принцип корзин)</td><td class="s25"><div style="width:872px;height:161px;"><img src="https://lh7-rt.googleusercontent.com/sheetsz/AHOq17H1bDWD-eM2ECDUf4jOb-T-zOU_vq928w3wOZ3T4JWfCYoS6ywwUri4WxMcvPAK0Ev5doX5HR2oUkGEIeLugdVlZeG_AfRfs1AIXaqVtsNZxaBlzEy4H5udrEorpNnlMudH5Gjg1h5hPBQUHIK_Aj9Ha58eh-iSjuJ7d0rDiQ=w872-h161?key=hmZU6X5bC09eoSadsn6fkQ" style="width:inherit;height:inherit;object-fit:scale-down;object-position:left center;"/></div></td><td class="s26" rowspan="2"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Имеет по дефолту 16 бакетов. Пары ключ-значение. <br>Нода хранит: значение, ссылку на следующий элемент. Все ноды в каждом бакете хранятся как односвязный список. Нода и энтри(по сути одно и тоже). Нода – пара ключ/значение.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">При заполнении бакетов на 75% их кол-во увеличивается в 2 раза.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Как определяется, в каком бакете будет храниться объект?</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> Перед добавлением в мап, высчитывается его хэш(по формуле hashCode()^hashCode&gt;&gt;&gt;16). Для уменьшения колизий, иначе может быть ситуация, когда 50 объектов хранятся в одном бакете, а остальные 15 пустые. <br>1)Сначала мы проверяем хэш объектов, 2) Мы проверяем ссылки объектов, 3) потом мы проверяем на иквалс. <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Если у нас появляется&lt;64 бакетов и&lt;8 Node в бакете),то Node перестраивается в TreeNode </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">в чёрно-красное дерево.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Оно будет таким, пока кол-во элементов не будет меньше 6.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">TreeNode -&gt; Node – это DeTreeify(Раздеревизация). Node -&gt; TreeNode – это Treeify(Деревизация).</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Может ли null быть ключём в HashMap.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> HashMap позволяет иметь один null ключ и сколько угодно null значений</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"> Какой хэш-код у null в HashMap. </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Хэш код null равен 0.</span></td><td class="s22"> </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 375px"><th id="1554587176R40" style="height: 375px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 375px">41</div></th><td class="s3" dir="ltr"><span style="color:#3e5656;">HashMap – внутри состоит из корзин и списка элементов, на которые ссылаются корзины.<br>Корзины – массив <br>Элементы(Node) – связанный список ( Принцип связи в корзинах основан на linkedlist), то есть каждый элемент списка имеет указатель на следующий элемент. </span><span style="font-weight:bold;color:#3e5656;">Перавая идет проверка на null</span><span style="color:#3e5656;"><br>При добавлении нового элемента, хэш-код ключа определяет корзину для элемента с помощью hashFunction(), который принимает hashCode ключа и возвращает номер корзины. В корзине есть ссылка на связанный список, в который будет положен наш объект. Идет проверка, есть ли элементы в этом списке. Если нету, то корзина получает ссылку нового элемента, если есть, то происходит прохождение по списку элементов и сравнивание элементов в списке. Проверяется равенство hashcode. Зная о коллизии, проводится еще сравнивание ключей методом equals.<br>Если оба равны: идет перезапись<br>Если не равен equals: добавляется элемент в конец списка<br><br>HashMap имеет поле loadFactor. Оно может быть задано через конструктор. По умолчанию - 0.75. Его произведение на количество корзин дает нам необходимое число объектов которое нужно добавить чтобы состоялось удвоение количества корзин.<br>Например если у нас мапка с 16-ю(default) корзинами, а loadFactor равняется 0.75, то расширение произойдет когда мы добавим 16 * 0.75 = 12 объектов. <br>После удвоения все объекты будут перераспределены с учетом нового количества корзин                                                                                                    </span><span style="font-weight:bold;color:#3e5656;">Если индексы равны хэщ-коды равный ключи равны то происходит перезапись элемента                                                                                           Метод get()  - проверка по хэш коду после проверка на equals                                                                                                                                                               При коллизии и хранении в 1 бакете огромного LinkedList скорость будет О(n) до Java 8 после в сбаласированное красно-черное дерево и скокрость O(log2(n))</span></td><td class="s22"></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 161px"><th id="1554587176R41" style="height: 161px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 161px">42</div></th><td class="s1" rowspan="2">Как устроена TreeMap, сложность основных операций?</td><td class="s27"><div style="width:872px;height:161px;"><img src="https://lh7-rt.googleusercontent.com/sheetsz/AHOq17FsbALcvL_2UWMceEzP1HgdAZarIhSnxTsB32Ou2Ci_Mojqet-cTBHilEDrYbq1etvNXm513-fWuO2JpcZGIC5YCXB5z4DjNLz76ks1T2mgheMlbPtWm2-FYl6u74jTnWZvDOL0PhjqoL34CIBj8ni3Vf8RL6bl_bhtDfmNSw=w872-h161?key=hmZU6X5bC09eoSadsn6fkQ" style="width:inherit;height:inherit;object-fit:scale-down;object-position:left center;"/></div></td><td class="s15" rowspan="2"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">TreeMap имплементирует интерфейс NavigableMap, который наследуется от SortedMap, а он, в свою очередь от интерфейса Map.  SortedMap<br></span><span style="font-size:10pt;font-family:Arial;">Интерфейс SortedMap расширяет Map и создает отображение, в котором все элементы отсортированы в порядке возрастания их ключей. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">NavigableMap<br></span><span style="font-size:10pt;font-family:Arial;">Интерфейс NavigableMap расширяет интерфейс SortedMap и обеспечивает возможность получения элементов отображения относительно других элементов.                                                                               </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">WeakHashMap - </span><span style="font-size:10pt;font-family:Arial;">это класс, аналогичный классу HashMap, все они используют метод хеширования (hashing technique) для хранения и извлечения данных. Разница в том, что если объект указан в качестве ключа of WeakHashMap, он может быть удален из памяти Garbage Collector (GC) (сборщиком мусора), если он больше не используется в другом месте, более сильном, чем GC. Как только ключ удаляется by GC, соответствующее отображение также удаляется из WeakHashMap.</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 229px"><th id="1554587176R42" style="height: 229px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 229px">43</div></th><td class="s2"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Класс TreeMap&lt;K, V&gt; представляет отображение в виде дерева. Он наследуется от класса AbstractMap и реализует интерфейс NavigableMap, а следовательно, также и интерфейс SortedMap. Поэтому в отличие от коллекции HashMap в TreeMap все объекты автоматически сортируются по возрастанию их ключей. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Если ключи одинаковые то происходит перезапись. Treemap - не сонхрjнизированная коллекция. Возможность работы с null-ключом - Можно, если используется компаратор, разрешающий null</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 143px"><th id="1554587176R43" style="height: 143px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 143px">44</div></th><td class="s1">Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false?</td><td class="s2">По значению hashCode() вычисляется индекс ячейки массива, в список которой этот элемент будет добавлен. Перед добавлением осуществляется проверка на наличие элементов в этой ячейке. Если элементы с таким hashCode() уже присутствует, но их equals() методы не равны, то элемент будет добавлен в конец списка.</td><td class="s28">0</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R44" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">45</div></th><td class="s1">Что будет, если мы кладем в HashMap ключ, у которого equals и hashCode определены некорректно?</td><td class="s3">Объект скорее всего добавится, но обратно мы не сможем получить его.</td><td class="s15"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">В каком случае может быть потерян элемент в HashMap? </span><span style="font-size:10pt;font-family:Arial;">После добавления элемента в HashMap у объекта, который выступает в качестве ключа, изменяют одно поле, которое участвует в вычислении хеш-кода. </span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 229px"><th id="1554587176R45" style="height: 229px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 229px">46</div></th><td class="s1">Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()?</td><td class="s2">Это возможно в случае, если метод, определяющий номер корзины будет возвращать одинаковые значения.</td><td class="s12">Пройтись по всем значениям в Map Проход по каждой паре ключ-значение — самая базовая, основная процедура прохода по Map. В Java, каждая пара хранится в поле Map называемом Map.Entry. Map.entrySet() возвращает набор ключ-значений, потому самым эффективным способом пройтись по всем значениям Map будет:<br><br>for(Entry entry: Map.entrySet()) {<br>//получить ключ<br>K key = entry.getKey();<br>//получить значение<br>V value = entry.getValue();<br>}</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R46" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">47</div></th><td class="s1">Почему нельзя использовать byte[] в качестве ключа в HashMap?</td><td class="s2">Хэш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании адреса массива). Также у массивов не переопределен equals и выполняется сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R47" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">48</div></th><td class="s1">Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?</td><td class="s2">Да, будет, но в этом случае HashMap вырождается в связный список и теряет свои преимущества.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R48" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">49</div></th><td class="s1">Какое худшее время работы метода get(key) для ключа, которого нет в HashMap?</td><td class="s2">O(N). Худший случай - это поиск ключа в таблице, вырожденной в список, перебор ключей которой занимает линейно пропорциональное время количеству хранимых элементов.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R49" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">50</div></th><td class="s1">Какое худшее время работы метода get(key) для ключа, который есть в HashMap?</td><td class="s2">O(N) - линейное</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 351px"><th id="1554587176R50" style="height: 351px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 351px">51</div></th><td class="s5">Начальная ёмкость коллекций</td><td class="s29"><div style="width:872px;height:351px;"><img src="https://lh7-rt.googleusercontent.com/sheetsz/AHOq17FVaSty9MY0OV3OohFd0dZTMjAm0DoCMQ7Ib0uBJ-g2m8wYnZL3hJfxfORsIqS46yNhBYGTUur4ItRjoyn-p-doW45kWKegbyALJr62X6Gg1WZfOyeH1ntnl2FDVZu0K-k0IqjOwL8hPLO4yttN-rl0fLkuPK7aKhrTOQzAdQ=w872-h351?key=hmZU6X5bC09eoSadsn6fkQ" style="width:inherit;height:inherit;object-fit:scale-down;object-position:left center;"/></div></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R51" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">52</div></th><td class="s0" colspan="2">Функциональные интерфейсы</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R52" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">53</div></th><td class="s1">Что такое функциональный интерфейс?</td><td class="s2">Это интерфейс, который содержит только 1 абстрактный метод.<br>Интерфейс может включать сколько угодно default (и static) методов и при этом оставаться функциональным, потому что default методы - не абстрактные.</td><td class="s20">Но если у нас в интерфейсе будет абстрактный метод, совпадающий сигнатурой с каким-то методом класса Object, такой метод (или методы) не поломает наше ограничение функционального интерфейса:</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R53" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">54</div></th><td class="s1">Для чего нужна аннотация @FunctionalInterface?</td><td class="s2">Нужна чтобы точно определить интерфейс как функциональный. Она обозначит замысел и не даст определить второй абстрактный метод в интерфейсе.<br></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 545px"><th id="1554587176R54" style="height: 545px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 545px">55</div></th><td class="s1">Какие встроенные функциональные интерфейсы вы знаете?</td><td class="s2">Predicate&lt;T&gt; - реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе значение типа boolean<br><br>Consumer&lt;T&gt; - реализуется функция, которая получает на вход экземпляр класса T, производит с ним некоторое действие и ничего не возвращает<br><br>Function&lt;T,R&gt; - реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе экземпляр класса R<br><br>Supplier&lt;T&gt; - реализуется функция, ничего не принимающая на вход, но возвращающая на выход результат класса T<br> <br>UnaryOperator&lt;T&gt; - принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T<br> <br>BinaryOperator&lt;T, Т&gt; - реализуется функция, получающая на вход два экземпляра класса T и возвращающая на выходе экземпляр класса T</td><td class="s20"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">public interface Predicate&lt;T&gt; {<br>    boolean test(T t);<br>}                                                                                                                                                    </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">public static void main(String[] args) {<br>         <br>        Predicate&lt;Integer&gt; isPositive = x -&gt; x &gt; 0;<br>         <br>        System.out.println(isPositive.test(5)); // true<br>        System.out.println(isPositive.test(-7)); // false<br>    }                                                                                                                                 </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">public interface BinaryOperator&lt;T&gt; {<br>    T apply(T t1, T t2);<br>}                                                                                                      </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">BinaryOperator&lt;Integer&gt; multiply = (x, y) -&gt; x*y;<br>         <br>System.out.println(multiply.apply(3, 5)); // 15                                             </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">public interface UnaryOperator&lt;T&gt; {<br>    T apply(T t);<br>}                                                                                                                                      </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">  UnaryOperator&lt;Integer&gt; square = x -&gt; x*x; System.out.println(square.apply(5)); // 25                                                       </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">public interface Function&lt;T, R&gt; {<br>    R apply(T t);<br>}                                                                                                                             </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Function&lt;Integer, String&gt; convert = x-&gt; String.valueOf(x) + &quot; долларов&quot;;<br>System.out.println(convert.apply(5)); // 5 долларов                                  </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">public interface Consumer&lt;T&gt; {<br>    void accept(T t);<br>}                                                                                                            </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;"> Consumer&lt;Integer&gt; printer = x-&gt; System.out.printf(&quot;%d долларов \n&quot;, x);<br>printer.accept(600); // 600 долларов               </span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R55" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">56</div></th><td class="s1">Что такое ссылка на метод?</td><td class="s2">Ссылка на статический метод - имя_класса::имя_метода<br> <br>Ссылка на нестатический метод конкретного объекта - имя_экземпляра::имя_методаимя_класса::имя_метода<br>  <br>Ссылка на конструктор - ClassName::new<br><br><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Ссылка на метод</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - это сокращенный синтаксис выражения лямбда, который выполняет только один метод. Это позволяет нам ссылаться на конструкторы или методы, не выполняя их. </span></td><td class="s30"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">public interface Supplier&lt;T&gt; {<br>    T get();<br>}                                                                                                                          </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Supplier&lt;User&gt; userFactory = ()-&gt;{<br>             <br>            Scanner in = new Scanner(System.in);<br>            System.out.println(&quot;Введите имя: &quot;);<br>            String name = in.nextLine();<br>            return new User(name);<br>        };<br>         <br>        User user1 = userFactory.get();<br>        User user2 = userFactory.get();<br>         <br>        System.out.println(&quot;Имя user1: &quot; + user1.getName());<br>        System.out.println(&quot;Имя user2: &quot; + user2.getName());</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R56" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">57</div></th><td class="s1">Что такое лямбда-выражение? Чем его можно заменить?</td><td class="s2">Лямбда-выражение - упрощённая запись анонимного класса, реализующего функциональный интерфейс</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R57" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">58</div></th><td class="s0" colspan="2">Stream API</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R58" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">59</div></th><td class="s1">Что такое Stream API? Для чего нужны стримы?</td><td class="s2">Интерфейс java.util.Stream представляет собой последовательность элементов, над которой можно производить различные операции.<br>Операции над стримами бывают или промежуточными или терминальными. Терминальные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом вы можете строить цепочки из несколько операций над одним и тем же стримом.<br>Его задача - упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 30px"><th id="1554587176R59" style="height: 30px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 30px">60</div></th><td class="s1">Почему Stream называют ленивым?</td><td class="s2">Методы не будут выполняться пока не будет вызван терминальный метод</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 229px"><th id="1554587176R60" style="height: 229px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 229px">61</div></th><td class="s1">Какие существуют способы создания стрима?</td><td class="s2"> Пустой стрим: Stream.empty()<br> Стрим из List: list.stream()<br> Стрим из Map: map.entrySet().stream()<br> Стрим из массива: Arrays.stream(array)<br> Стрим из указанных элементов: Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)<br>-Можно получить из BufferedReader при помощи метода lines(), который вернет поток строк из потока символов.<br>-Из директории на диске при помощи методов Files.list() и Files.walk()<br>-Можно получить из строки методом chars(), будет IntStream с символами.<br>-Можно порождать динамически, генерировать при помощи supplier.<br>-Итерированием какой-то функции<br>-Можно получить диапазон чисел в виде стрима range и rangeClosed<br>-Конкатенацией других стримов<br></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R61" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">62</div></th><td class="s1">Как из коллекции создать стрим?</td><td class="s2">Collection&lt;String&gt; collection = Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;);<br>Stream&lt;String&gt; streamFromCollection = collection.stream();</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R62" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">63</div></th><td class="s1">Какие промежуточные методы в стримах вы знаете?</td><td class="s2">filter(boolean - Predicate)<br>map()<br>flatMap()<br>limit(n)<br>skip(n)<br>concat(Stream s1, Stream s2)<br>peek(someFunction)<br>distinct()<br>sorted()</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R63" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">64</div></th><td class="s1">Расскажите про метод peek().</td><td class="s2">Предполагается, что map() получает на вход один объект, а возвращает другой. Возможно, того же типа, но другой. <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">peek() - это частный случай map(), который возвращает тот же самый объект, который получил на входе</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, возможно, с изменённым внутренним состоянием. Конечно, можно использовать для этого map(), но есть нюансы. Во-первых, peek() на одну строчку короче - не нужно писать return, Java и так знает, что нужно возвращать. Во-вторых, вы страхуетесь от ошибок - из peek() невозможно вернуть не тот объект, который пришёл на вход.</span></td><td class="s22">Можем менять внутри но возвращать должны объект с входа</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R64" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">65</div></th><td class="s1">Расскажите про метод map().</td><td class="s21">Метод map() заданным образом преобразует каждый элемент стрима, потом преобразует все объекты в итоговый стрим. </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R65" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">66</div></th><td class="s1">Расскажите про метод flatMap().</td><td class="s2"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">flatMap возвращает по стриму для каждого объекта в первоначальном стриме, а затем результирующие потоки объединяются в исходный стрим</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. (Похоже на map, но может создавать из одного элемента несколько)</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 55px"><th id="1554587176R66" style="height: 55px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 55px">67</div></th><td class="s1">Чем отличаются методы map() и flatMap().</td><td class="s18">map для каждого объекта в стриме возвращает по 1 объекту, потом преобразует все объекты в итоговый стрим. flatMap возвращает по стриму для каждого объекта в первоначальном стриме, а затем результирующие потоки объединяются в исходный стрим.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R67" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">68</div></th><td class="s1">Расскажите про метод filter()</td><td class="s2">фильтрует стрим, возвращая только те элементы, что проходят по условию (Predicate)<br>Проверяет значение на “true” и “false”</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R68" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">69</div></th><td class="s1">Расскажите про метод limit()</td><td class="s2"> limit(n) - возвращает новый поток, ограниченный n-результатами</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R69" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">70</div></th><td class="s1">Расскажите про метод skip()</td><td class="s2"> skip(n) - возвращает новый поток, пропуская первые n элементов</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R70" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">71</div></th><td class="s1">Расскажите про метод sorted()</td><td class="s2"> sorted() - возвращает отсортированный поток</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 38px"><th id="1554587176R71" style="height: 38px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 38px">72</div></th><td class="s1">Расскажите про метод distinct()</td><td class="s2" dir="ltr"> <br> distinct() - возвращает поток равнозначный исходному, но без дубликатов</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R72" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">73</div></th><td class="s1">Какие терминальные методы в стримах вы знаете?</td><td class="s2">-forEach – принимает consumer, которому будут выведены элементы стрима. <br>-forEachOrdered – как и forEach, но гарантирует порядок. <br>-count() - подсчет всех значений<br>-max() - возвращает максимальный элемент<br>-min() - возвращает минимальный элемент<br>-findAny() - находится вхождение – сразу возвращает результат<br>-anyMatch() проверяет на наличие совпадения<br>-allMatch() – возвращает boolean<br>-noneMatch() – возвращает boolean <br>-findFirst – возвращает первый элемент из стрима, возвращается OptionalInt<br>-collect – собирает элементы в новое хранилище<br>-reduce – результат применения бинарного оператора к каждой паре элементов стрима, пока не останется один элемент.<br>-toArray  - возвращет массив<br><br>Терминальный метод можно вызвать только один раз.<br>Все оконечные методы возвращают Optional - оболочка ответа<br>(этот специальный тип ввели чтобы не возвращать null)</td><td class="s15">forEach Применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R73" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">74</div></th><td class="s1">Расскажите про метод collect()</td><td class="s2">Stream.collect () является одним из терминальных методов. Это позволяет выполнять изменяемые операции свертывания (переупаковка элементов в некоторые структуры данных и применение некоторой дополнительной логики, объединение их и т. Д.)<br>Преобразует стрим в коллекцию</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 96px"><th id="1554587176R74" style="height: 96px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 96px">75</div></th><td class="s1">Расскажите про метод reduce()</td><td class="s3"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">позволяет выполнять агрегатные функции и возвращать один результат.<br>-<br>Результат применения бинарного оператора к каждой паре элементов стрима, пока не останется один элемент.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Позволяет выполнять агрегатные функции на всей коллекцией и возвращать один результат</span></td><td class="s31"><span style="font-size:12pt;font-family:&quot;Liberation Sans&quot;,Arial;color:#111111;">collection.stream().reduce((s1, s2) -&gt; s1 + s2).orElse(0) </span><span style="font-size:12pt;font-family:&quot;Liberation Sans&quot;,Arial;font-weight:bold;color:#111111;">агрегатные функции - это функции, которые вычисляются от группы значений и объединяют их в одно результирующе</span><span style="font-size:12pt;font-family:&quot;Liberation Sans&quot;,Arial;color:#111111;">е</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 254px"><th id="1554587176R75" style="height: 254px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 254px">76</div></th><td class="s1">Расскажите про класс Collectors и его методы.</td><td class="s3">Нужен для того, чтобы упаковывать стримы в коллекции:<br>toList() - преобразует поток в список — List&lt;T&gt;<br>toSet() - преобразует поток в список — Set&lt;T&gt;<br>toMap() - преобразует поток в список — Map&lt;K, V&gt;<br>Используются в методе collect().</td><td class="s15"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Существует три варианта этого метода, которые отличаются своими сигнатурами и типами возвращаемых данных. Они могут иметь следующие параметры: </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">identity – начальное значение для аккумулятора</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> или значение по умолчанию, если поток пуст и накапливать нечего </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">аккумулятор – позволяет выполнять агрегатные функции и возвращать один результат.<br>Результат применения бинарного оператора к каждой паре элементов стрима, пока не останется один элемент.<br>. </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Поскольку накопитель создает новое значение для каждого шага уменьшения, количество новых значений равно размеру потока, и только последнее значение полезно. Это не очень хорошо для производительности. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">объединитель – функция, которая агрегирует результаты работы накопителя. </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Мы вызываем объединитель только в параллельном режиме, чтобы уменьшить результаты накопителей из разных потоков.</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 231px"><th id="1554587176R76" style="height: 231px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 231px">77</div></th><td class="s1">Расскажите о параллельной обработке в Java 8.</td><td class="s2">Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта Stream метод <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">parallel(внутри потока). </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">А обратный метод - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">sequential()</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. Кроме того, можно также использовать блокирующий метод parallelStream() интерфейса Collection для создания параллельного потока из коллекции. В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Работает на фреймворке fork/join(под капотом)</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.Кроме того, можно также использовать метод </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">parallelStream() (над стримами потока) </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">интерфейса Collection для создания параллельного потока из коллекции. - сразу создается параллельнй стрим</span></td><td class="s15"></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R77" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">78</div></th><td class="s1">Что такое IntStream и DoubleStream?</td><td class="s2">В Java 8 создание Stream-ов примитивов напрямую невозможно, из-за дженериков. Но разработчики сделали 3 Stream-а примитивов : IntStream, LongStream, DoubleStream. Работает быстрее, чем стрим с классами-обертками.<br>Поддерживают дополнительные терминальный методы sum(), average(), mapToObj()</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R78" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">79</div></th><td class="s0" colspan="2">Java 8</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R79" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">80</div></th><td class="s1">Какие нововведения появились в java 8?</td><td class="s2">1. Полноценная поддержка лямбда-вражений<br>2. Ссылки на методы ::<br>3. Функциональные интерфейсы <br>4. default методы в интефейсах <br>5. Потоки для работы с коллекциями<br>6. Новое api для работы с датами <br>7. Nashorn движок JavaScript, разрабатываемый полностью на Java компанией Oracle.<br>8. Кодировщик/декодировщик.<br>9. Новые методы для Map - PutIfAbsent(), СomputeIfAbsent()\СomputeIfPresent(), Remove(), GetOrDefault(), Merge()<br>10. Metaspace пришла на замену PermGen</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 59px"><th id="1554587176R80" style="height: 59px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 59px">81</div></th><td class="s1">Какие новые классы для работы с датами появились в java 8?</td><td class="s2">LocalDate , LocalTime, LocalDateTime, ZonedDateTime, Period, Duration</td><td class="s32"><span style="font-size:10pt;font-family:&quot;Liberation Sans&quot;,Arial;font-weight:bold;">Duration</span><span style="font-size:12pt;font-family:&quot;Liberation Sans&quot;,Arial;"> </span><span style="font-size:10pt;font-family:&quot;Liberation Sans&quot;,Arial;">представляет собой точное количество времени, в то время как</span><span style="font-size:12pt;font-family:&quot;Liberation Sans&quot;,Arial;"> </span><span style="font-size:10pt;font-family:&quot;Liberation Sans&quot;,Arial;font-weight:bold;">Period</span><span style="font-size:12pt;font-family:&quot;Liberation Sans&quot;,Arial;"> </span><span style="font-size:10pt;font-family:&quot;Liberation Sans&quot;,Arial;">представляет собой предполагаемое количество времени.</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 83px"><th id="1554587176R81" style="height: 83px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 83px">82</div></th><td class="s1">Расскажите про класс Optional</td><td class="s2">Optional - новый класс в пакете java.util, является контейнером (оберткой) для значений которая также может безопасно содержать null. Благодаря опциональным типам можно забыть про проверки на null и NullPointerException.</td><td class="s12">Optional&lt;T&gt; reduce();<br>Optional&lt;T&gt; min();<br>Optional&lt;T&gt; max();<br>Optional&lt;T&gt; findFirst();<br>Optional&lt;T&gt; findAny();</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R82" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">83</div></th><td class="s1">Что такое Nashorn?</td><td class="s2">В Java 8, Nashorn, представлен значительно улучшенный движок javascript для замены существующего Rhino. Nashorn обеспечивает в 2-10 раз лучшую производительность, так как он напрямую компилирует код в памяти и передает байт-код в JVM. Nashorn использует функцию динамического вызова, представленную в Java 7, для повышения производительности.<br>* Nashorn — немецкое слово (Носорог)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R83" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">84</div></th><td class="s1">Что такое jjs?</td><td class="s3">Инструмент командной строки для выполнения JavaScript-кодов на консоли.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R84" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">85</div></th><td class="s1">Какой класс появился в Java 8 для кодирования/декодирования данных?</td><td class="s2">public static class Base64.Encoder /public static class Base64.Decoder</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R85" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">86</div></th><td class="s1">Как создать Base64 кодировщик и декодировщик?</td><td class="s2">op00000000000000i</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R86" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">87</div></th><td class="s1">Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?</td><td class="s2"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">putIfAbsent</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">() добавляет пару «ключ-значение», только если ключ отсутствовал:<br> map.putIfAbsent(&quot;a&quot;, &quot;Aa&quot;);<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">forEach</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">() принимает функцию, которая производит операцию над каждым элементом:<br> map.forEach((k, v) -&gt; System.out.println(v));<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">compute</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">() создаёт или обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):<br> map.compute(&quot;a&quot;, (k, v) -&gt; String.valueOf(k).concat(v)); //[&quot;a&quot;, &quot;aAa&quot;]<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">computeIfPresent</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">() если ключ существует, обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):<br> map.computeIfPresent(&quot;a&quot;, (k, v) -&gt; k.concat(v));<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">computeIfAbsent</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">() если ключ отсутствует, создаёт его со значением, которое вычисляется (возможно использовать ключ):<br> map.computeIfAbsent(&quot;a&quot;, k -&gt; &quot;A&quot;.concat(k)); //[&quot;a&quot;,&quot;Aa&quot;]<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">getOrDefault</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">() в случае отсутствия ключа, возвращает переданное значение по-умолчанию:<br> map.getOrDefault(&quot;a&quot;, &quot;not found&quot;);<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">merge</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">() принимает ключ, значение и функцию, которая объединяет передаваемое и текущее значения. Если под заданным ключем значение отсутствует, то записывает туда передаваемое значение.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- map.remove(key, value) - Если такое ключ-значение есть в map, то удаляем</span></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 20px"><th id="1554587176R87" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">88</div></th><td class="s1">Что такое LocalDateTime?</td><td class="s2">LocalDateTime объединяет вместе LocaleDate и LocalTime, содержит дату и время в календарной системе ISO-8601 без привязки к часовому поясу. Время хранится с точностью до наносекунды. Содержит множество удобных методов, таких как plusMinutes, plusHours, isAfter, toSecondOfDay и т.д.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr style="height: 73px"><th id="1554587176R88" style="height: 73px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 73px">89</div></th><td class="s1">Что такое ZonedDateTime?</td><td class="s2">java.time.ZonedDateTime — аналог java.util.Calendar, класс с самым полным объемом информации о временном контексте в календарной системе ISO-8601. Включает объект ZoneId - временную зону(в ZoneId 599 зон), поэтому все операции с временными сдвигами этот класс проводит с её учётом.</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><div id='embed_1346587968' class='waffle-embedded-object-overlay' style='width: 538px; height: 267px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17F_BIetzfgqi4AqvfNHp3vSzJBH0HqVyAGduo6qfdka8a3i4shFki-Ps8Pm2eB8sPhpODu5sGGhqGFDPe3jx6iQpQHCNwu6BRsLw8kmj-97VfaQQM3ZyyjS32D9UhbDV9IcbBN2g_D2ALQN99Ug39QFL0WTWz82yzvZSckh?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='267' width='538'></div><div id='embed_770633056' class='waffle-embedded-object-overlay' style='width: 421px; height: 207px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17HpXLrmMuk_j79Wbzh-lCklDxsSAQcGx0LJHfkb_PTYpONN0ZJaZt0h0-iQX9rWd5AZQ7Dk_18aDTncyHnUxCOo5KDLa2CK0pnsq0roncZ8S7SA6qnj8Ft8cTc2xgwuKFVF5x4TzGmWkrTEU4o4JVyk66IxgyEfipOLsNUr?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='207' width='421'></div><div id='embed_1619879868' class='waffle-embedded-object-overlay' style='width: 353px; height: 182px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17HlS7dE8lEhllQzerZXo2wEPGfD_1IK3a4JN01GznT0Bc-WMN5mjIG7_DP08hWvfpdME6Xye29EEOy7qeGDGiOzvJDIemTr62LhrhVo8gbwbbu8vykCzHxr4x-gG4IxAwdCr_25bXRAdOFNMa2UBd5Xrum_DPxvPOunWzg?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='182' width='353'></div><div id='embed_465318990' class='waffle-embedded-object-overlay' style='width: 454px; height: 153px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17FFj9zBj9B2eFfqze4F8M7AB7MB4MeekAP9OtWzodhJ4YzlO4ZXuaA-xRGaupobukVLSoZczuVzbT8FfdVXJPtzPJisSPgRc2K2rbWwKs0nG7Mb_VZ2oOkgDTYjA3de3-tKGLkwNW4WZhoH-z6BiWlyrrnbynB8TxVAb8Yszw?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='153' width='454'></div><div id='embed_1872468140' class='waffle-embedded-object-overlay' style='width: 738px; height: 454px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17FqLfB4j0t_iw06KJA9il1WhG-qcNSyLWcVztrLx1XQF-HsDGmMRSM_P0mFdJ8BzcY1L766-eYbXtGKng9nVFvVEgkJ1F8FEiYlLtUbhcP9U1nz0IjsrS50CuWmgRVSRv6Bk-k_fr-U5VNGi3AllDtem5OzB5ysKqTA1ZdPkg?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='454' width='738'></div><div id='embed_441424426' class='waffle-embedded-object-overlay' style='width: 461px; height: 171px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17Hh8tAiuSH0-6WHKzn-JeTIT9ztgI7qS1CwtAGCCYOY86v2IvXj9J3d_TTbJjtcDSPkgoAzQQ6aaBPm-knQdYjqe8A-LFeXZpfJ1kFanvv9mYXzVz25FoHGHw-qkz3j6TljpEwO2jTKR2mVLd7FfouZkQQJzlAI_7m2bWpiWw?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='171' width='461'></div><div id='embed_2074859627' class='waffle-embedded-object-overlay' style='width: 522px; height: 134px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17HVAbEbqgBZj2-hMA6XoFftmx5ieH6Slf5AtQfEmq5YWis5Nyygx5ZV2bTwGKVC2z3yeEW-j69WRG0YqaANNX2CkOZ8HS7mHE46aiG8UrV5RwBAwR8dR8UeY_jXLMA_0MvaiOMB2iGw9pVMp2Xls7OFThaXw-81IZRKfOVQmQ?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='134' width='522'></div><div id='embed_411670185' class='waffle-embedded-object-overlay' style='width: 435px; height: 204px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17G6zzaxM_uviSdr2pxn-c2oGQKLBB1ve88AxFAGGe8tFz2DjSWGFtASlyfO4AS_8INMOjE7c8t16nerti9Zly2pKAnae4Xr1fM1XNUZ0K4Ku07InvmNc91JY7g3kbehkp2wBGZ0P-OnUgA6hEJ1tv9FJwo6xskst72kxBBrdg?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='204' width='435'></div><div id='embed_18388107' class='waffle-embedded-object-overlay' style='width: 307px; height: 47px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17HDYr-mpdcd5BwDUV90L5wazqe8fgMT4GjnXwTSlC58sl0MP1gRU19WeOFy6Es3u2-2sUl89VSi5tQhhusl7UNRGUnVxoiw31vkIJSYYtHRB1vsgenqqc5lzQz9NDiLZxJ0VSsV5T-bNpmyCGsHIUTb6MX_KecV9WIoalvuAw?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='47' width='307'></div><div id='embed_2049747002' class='waffle-embedded-object-overlay' style='width: 443px; height: 43px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17HpOMdD35PRKxTB8jHpmiO2Gs4J8ouicjO2w7eIZDG-OHh6MBNE_npPT5nqB4O-PU-JHju5j0XpaZTBD18jBWMnUWm60hFP_hSnExD6FjMcSUDUGiJeBqHxx0CEMhI1cW6aW9NeTNZkXv3drE9-oX44E1EVjrOz51Ffpz0DBg?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='43' width='443'></div><div id='embed_1730929528' class='waffle-embedded-object-overlay' style='width: 163px; height: 135px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17EhL2PsNhZWWL3WjPVj2KUBTGd2TTt77TfL9bdq13kvTvvRyehACOy8l_uh3Kdz-NL9inPIh5fkIamDYJGilM9XaLr5TR0k_RNYattPpFQTiTHpBa45-B2e0_o2qIx3WnfNatA4fyP4JFON-vC3u4-zzBWylrHY6ISrDkDWfw?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='135' width='163'></div><div id='embed_1211655436' class='waffle-embedded-object-overlay' style='width: 384px; height: 215px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17GlT5YnwRVggzlSW-5x1yCBWjt6VuK34cml7dQykBy6MaVftO21rfskcj3ltp1rR3241sylx0PXX_QI0gcEw-KJEEcRoYdUstiRqYceuR88sbQqtEW5UoXBWIzSw2C55c1QF8-z3JotKndLw7hS_8YbTflqNTd40Lf1cLTP?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='215' width='384'></div><div id='embed_1206970419' class='waffle-embedded-object-overlay' style='width: 578px; height: 402px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17G2WW52_-uKoGA8or08Qw3u5WFjhJIU8O3njwHrPV_LTQuFZg5PHoWK0MWO2VVY6ygxscwNzT5rnTSh2vYYryHqt1Wefm2XlcH9Mh1YUgVZBnxMvvwhpNbEYMLNRBZy1rT6cN_5TXXVxNqCB3_IyDADYdKGiHeBMv1el0EiIg?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='402' width='578'></div><div id='embed_1031219613' class='waffle-embedded-object-overlay' style='width: 697px; height: 143px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17HTSfzw-UZ6jNlyBTEJhad5Xcx6G46bNTC1xJOEQCuPQZHjMQMic_XD7cBsCDID5cdmZW2zZnabqGWf5GKoj--D519sA5Tn-CAL7Z_HNLcmFf-htH8ODTc7aigzP5pcf4S7e3p90A-6ANKsbMdwHBd1wGZYdfvJDTE4Og2WeA?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='143' width='697'></div><div id='embed_2127618721' class='waffle-embedded-object-overlay' style='width: 498px; height: 100%; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17FWNcVGmGd5freTXxKJQWSJwu05rDAReWd3WQDNjm2jkGPqI2hJnHVvvBOurLyQ--OPz0Cjt_pg4Ghmn7f8I7tYd02Yte1z-XjkrUOJg7fow94cHlCvGqIooMZE3BDgaDtmtuQueisOpZVb-_fmNar8HNb-M_FTTGawl_Kv?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='-175' width='498'></div><div id='embed_759785721' class='waffle-embedded-object-overlay' style='width: 630px; height: 281px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17G374n7yBXotjspvd8kQ2HKOVe5aNFxNjO_r8aGUBsyE5ddflY9tYsAq18oQIjPihUXWEK7rquL4PHHG0fCAvd2YmdtVDPvYE4IK7PLxhYGKO6IdwxF1B8tmGxK41ea1ZMIjpWINtBakFVDb__VPMEbnS4qpyLKV7b0TTc0?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='281' width='630'></div><script>
  function posObj(sheet, id, row, col, x, y) {
      var rtl = false;
      var sheetElement = document.getElementById(sheet);
      if (!sheetElement) {
        sheetElement = document.getElementById(sheet + '-grid-container');
      }
      if (sheetElement) {
        rtl = sheetElement.getAttribute('dir') == 'rtl';
      }
      var r = document.getElementById(sheet+'R'+row);
      var c = document.getElementById(sheet+'C'+col);
      if (r && c) {
        var objElement = document.getElementById(id);
        var s = objElement.style;
        var t = y;
        while (r && r != sheetElement) {
          t += r.offsetTop;
          r = r.offsetParent;
      }
      var offsetX = x;
      while (c && c != sheetElement) {
        offsetX += c.offsetLeft;
        c = c.offsetParent;
      }
      if (rtl) {
        offsetX -= objElement.offsetWidth;
      }
      s.left = offsetX + 'px';
      s.top = t + 'px';
      s.display = 'block';
      s.border = '1px solid #000000';
    }
  }

  function posObjs() {
  posObj('1554587176', 'embed_1346587968', 22, 1, 3, 10);posObj('1554587176', 'embed_770633056', 24, 1, 0, 0);posObj('1554587176', 'embed_1619879868', 26, 1, 8, 8);posObj('1554587176', 'embed_465318990', 28, 1, 0, 202);posObj('1554587176', 'embed_1872468140', 21, 4, 0, 88);posObj('1554587176', 'embed_441424426', 24, 1, 422, 30);posObj('1554587176', 'embed_2074859627', 26, 1, 359, 15);posObj('1554587176', 'embed_411670185', 27, 2, 0, 111);posObj('1554587176', 'embed_18388107', 29, 2, 124, 140);posObj('1554587176', 'embed_2049747002', 29, 2, 8, 187);posObj('1554587176', 'embed_1730929528', 37, 1, 710, 137);posObj('1554587176', 'embed_1211655436', 41, 1, 406, 17);posObj('1554587176', 'embed_1206970419', 40, 3, 0, 369);posObj('1554587176', 'embed_1031219613', 29, 1, 3, 152);posObj('1554587176', 'embed_2127618721', 72, 2, 0, 225);posObj('1554587176', 'embed_759785721', 45, 1, 873, 227);}posObjs();</script>