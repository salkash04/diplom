<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s11{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#ffff00;text-align:center;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s8{background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s9{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#cfe2f3;text-align:center;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s24{border-bottom:1px SOLID transparent;border-right:1px SOLID transparent;background-color:#ffff00;text-align:left;color:#ff0000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s4{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s0{border-bottom:1px SOLID transparent;border-right:1px SOLID transparent;background-color:#3d85c6;text-align:center;font-weight:bold;color:#ffffff;font-family:Arial;font-size:14pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s17{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#c9daf8;text-align:center;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s21{background-color:#ffffff;text-align:left;color:#333333;font-family:Arial;font-size:12pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s1{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#cfe2f3;text-align:left;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s6{background-color:#ffffff;text-align:left;font-weight:bold;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s18{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#3e5656;font-family:"docs-Helvetica Neue",Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s2{border-bottom:1px SOLID transparent;border-right:1px SOLID transparent;background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:10pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s5{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#ffff00;text-align:left;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s19{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:11pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s15{background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s10{background-color:#ffffff;text-align:left;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#8b8948;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s12{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#fce5cd;text-align:center;font-weight:bold;color:#ffffff;font-family:Arial;font-size:11pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s13{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#8b8948;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s14{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#ffff00;text-align:center;font-weight:bold;color:#3e5656;font-family:Arial;font-size:11pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s20{background-color:#ffffff;text-align:left;color:#d07b34;font-family:docs-Consolas,Arial;font-size:14pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s3{background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s23{border-bottom:1px SOLID transparent;background-color:#ffffff;}.ritz .waffle .s26{border-bottom:1px SOLID transparent;border-right:1px SOLID transparent;background-color:#c9daf8;text-align:center;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:middle;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s22{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s25{background-color:#ffffff;text-align:center;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s16{border-bottom:1px SOLID transparent;background-color:#ffffff;text-align:left;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}.ritz .waffle .s7{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;font-weight:bold;color:#3e5656;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:0px 3px 0px 3px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle no-grid" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-origin-ltr"></th><th id="1989704007C0" style="width:198px;" class="column-headers-background">A</th><th id="1989704007C1" style="width:863px;" class="column-headers-background">B</th><th id="1989704007C2" style="width:718px;" class="column-headers-background">C</th></tr></thead><tbody><tr style="height: 20px"><th id="1989704007R0" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">1</div></th><td class="s0" dir="ltr" colspan="2">CORE 1</td><td></td></tr><tr style="height: 249px"><th id="1989704007R1" style="height: 249px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 249px">2</div></th><td class="s1">Что такое ООП</td><td class="s2" dir="ltr">**ООП** - методология программирования, основанная на представлении программы в виде совокупности объектов, а не алгоритмов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.<br><br>Согласно парадигмы **ООП** программа состоит из **обьектов**, обменивающихся сообщениями. Обьекты могут обладать состоянием, единственный способ изменить состояние обьекта - передать ему сообщение,  в ответ на которое, обьект может изменить собственное состояние.<br><br>**Класс** - описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора, а объект – экземпляр класса, созданный на основе этого описания.<br><br>**Три составляющих каждого объекта:**<br><br>- **идентичность (identity)** – то, что отличает один объект класса от другого (equals)<br>- **состояние (state)** - набор всех полей объекта и их значений<br>- **поведение (behaviour)** - набор всех методов класса объекта</td><td></td></tr><tr style="height: 20px"><th id="1989704007R2" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">3</div></th><td class="s1" rowspan="4">Какие преимущества у ООП</td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Легко читается</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - не нужно выискивать в коде функции и выяснять, за что они отвечают</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R3" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">4</div></th><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Быстро пишется - </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">можно быстро создать сущности, с которыми должна работать программа.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R4" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">5</div></th><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Простота реализации большого функционала</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - т.к. на написание кода уходит меньше времени, можно гораздо быстрее создать приложение с множеством возможностей</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R5" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">6</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Меньше повторений кода </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- не нужно писать однотипные функции для разных сущностей</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R6" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">7</div></th><td class="s5" rowspan="5">Какие недостатки у ООП</td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Потребление памяти</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - обьекты потребляют больше оперативной памяти, чем примитивные типы данных</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R7" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">8</div></th><td class="s6"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Снижает производительность</span><span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#3e5656;"> - многие вещи технически реализованы иначе, поэтому они используют больше ресурсов.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R8" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">9</div></th><td class="s6">Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).</td><td></td></tr><tr style="height: 20px"><th id="1989704007R9" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">10</div></th><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Излишняя универсальность.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R10" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">11</div></th><td class="s7">Сложно начать<span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#3e5656;"> - парадигма ООП сложнее функционального программирования, поэтому на старт уходит больше времени</span></td><td></td></tr><tr style="height: 54px"><th id="1989704007R11" style="height: 54px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 54px">12</div></th><td class="s1">Назовите основные принципы ООП</td><td class="s7">Инкапсуляция<br>Наследование <br>Полиморфизм</td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Абстрактный класс</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> – это средство, позволяющее избежать написания повторяющегося кода,<br> инструмент для частичной реализации поведения. </span></td></tr><tr style="height: 20px"><th id="1989704007R12" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">13</div></th><td class="s1">Что такое инкапсуляция? <br>(С примером)<br></td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Свойство </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">системы, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">которое объединяет данные и методы,</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> манипулирующие этими данными, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">а также защищает и то, и другое </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">от внешнего вмешательства или неправильного использования.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Инкапсуляция - это объединение данных и методов работы с этими данными в одной упаковке («капсуле»).<br>Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.</span></td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Абстракция</span><span style="font-size:10pt;font-family:Arial;"> —  означает выделение значимой информации и исключение из рассмотрения незначимой. С точки зрения программирования это правильное разделение программы на объекты. Абстракция позволяет отобрать главные характеристики и опустить второстепенные.</span></td></tr><tr style="height: 20px"><th id="1989704007R13" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">14</div></th><td class="s1">Что такое наследование?<br>(С примером)</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Свойство </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">системы, которое </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">позволяет описать</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> новый </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">класс на основе</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">уже существующего</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> с частично или полностью заимствованной функциональностью.</span></td><td class="s8">Когда создаем объект а в другом классе описываем функционал этого объекта</td></tr><tr style="height: 238px"><th id="1989704007R14" style="height: 238px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 238px">15</div></th><td class="s5">Что такое полиморфизм? <br>(С примером)</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Полиморфизм </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">– предоставляет возможность</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"> единообразно обрабатывать объекты с различной реализацией при условии наличия у них общего интерфейса или класса. Полиморфизм – способность функции обрабатывать данные разных типов.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>Есть три вида полиморфизма:<br>-</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">ad hoc</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> полиморфизм, основан на различении типов. Для различных типов аргументов используется разный код метода, пример статического - перегрузка метода. Пример динамического - перегрузка метода. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">(@Overload)</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>-</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">параметрический</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> полиморфизм - ситуация, когда один и тот же метод работает с аргументами различных типов одинаково, не зависимо от их точного типа. Пример — функция, работающая с объектом некоторого класса C, может без изменений работать с объектом порождённого от C класса (этот вид полиморфизма часто называют полиморфизм включения). </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">(@Override)</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>-</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">subtype</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> полиморфизм - самый популярный - возможность объектов с одинаковой спецификацией(интерфейс\класс\abstract класс) иметь различную реализацию.<br><br>Пример:<br>Переопределение методов, интерфейсы.</span></td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Динамический полиморфизм</span><span style="font-size:10pt;font-family:Arial;">: Предположим, что подкласс переопределяет конкретный метод суперкласса. Допустим, мы создаем объект подкласса и присваиваем его ссылке на суперкласс. Теперь, если мы вызовем переопределенный метод для ссылки на суперкласс, то будет вызвана версия метода для подкласса.                                                                                            <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Статический полиморфизм:</span><span style="font-size:10pt;font-family:Arial;"><br>В Java статический полиморфизм достигается за счет перегрузки методов. Перегрузка метода означает, что в классе есть несколько методов, имеющих одинаковое имя, но разные типы / порядок / количество параметров.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Интерфейс</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> — это совокупность методов и правил взаимодействия элементов системы. Другими словами, интерфейс определяет как элементы будут взаимодействовать между собой</span></td></tr><tr style="height: 139px"><th id="1989704007R15" style="height: 139px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 139px">16</div></th><td class="s9" rowspan="2">Что такое ассоциация</td><td class="s10"><a target="_blank" href="http://java-course.ru/begin/relations/">Есть два типа связи между объектами: ассоциация, которая делится на композицию и агрегацию, и наследование.<br>Ассоциация - обозначает связь между обьектами. Например, игрок играет в определенной команде.<br><br>Ассоциация означает, что объекты двух классов могут ссылаться один на другой, иметь некоторую связь между друг другом. Например Менеджер может выписать Счет. Соответственно возникает ассоциация между Менеджером и Счетом. Еще пример — Преподаватель и Студент — т.е. какой-то Студент учится у какого-то Преподавателя. Ассоциация и есть описание связи между двумя объектами. Студент учится у Преподавателя. Идея достаточно простая — два объекта могут быть связаны между собой и это надо как-то описать.<br>http://java-course.ru/begin/relations/</a></td><td></td></tr><tr style="height: 1px"><th id="1989704007R16" style="height: 1px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 1px">17</div></th><td class="s7"></td><td></td></tr><tr style="height: 20px"><th id="1989704007R17" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">18</div></th><td class="s5" rowspan="3">Что такое композиция</td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Композиция </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">— еще более «жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежат еще кому-то. Например Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет быть в двух или трех машинах одновременно. В отличии от студента, который может входить и в другие группы тоже. <br><br>Например, в класс автомобиля содержит объект класса электрического двигателя:</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R18" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">19</div></th><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#4a86e8;">public </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">class ElectricEngine{ }<br> <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#4a86e8;">public </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">class Car {<br>    ElectricEngine engine;<br>    </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#4a86e8;">public </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Car()<br>    {<br>        engine = </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#4a86e8;">new </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">ElectricEngine();<br>    }<br>}</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R19" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">20</div></th><td class="s4">При этом класс автомобиля полностью управляет жизненным циклом объекта двигателя. При уничтожении объекта автомобиля в области памяти вместе с ним будет уничтожен и объект двигателя. И в этом плане объект автомобиля является главным, а объект двигателя - зависимой.</td><td></td></tr><tr style="height: 20px"><th id="1989704007R20" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">21</div></th><td class="s9">Что такое агрегация</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>Агрегация является особой формой ассоциации. Это более конкретизированные отношения между объектами.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Агрегация </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">— отношение когда один объект является частью другого. <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Например: </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Студент входит в Группу любителей физики.Это представляет отношения HAS-A.<br><br>Агрегация определяет </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">отношение HAS A </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">(&quot;имеет&quot;), но связь слабее, чем в композиции, т.к. обьекты будут равноправны. <br></span></td><td></td></tr><tr style="height: 345px"><th id="1989704007R21" style="height: 345px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 345px">22</div></th><td class="s11">Расскажите про раннее и позднее связывание.</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Связывание означает наличие связи между ссылкой и кодом. Например, переменная, на которую вы ссылаетесь, привязана к коду, в котором она определена. Аналогично, вызываемый метод привязан к месту в коде, где он определен.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Раннее связывание</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Если метод известен компилятору</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">,  то происходит ранее связывание на этапе компиляции (early binding), также называют статическим связыванием. Используется для </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">final, перегруженных, статических методов.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Позднее связывание</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> (late binding) - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">вызов метода возможен только во время выполнения</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, т.к. у компилятора нет информации, чтобы проверить корректность такого вызова. В java это возможно при помощи рефлексии. Используется для </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">переопределенных и абстрактных методов.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br> Вот пример: Object a = ... // какое-то присваивание a.toString(); На этапе компиляции мы не знаем, какого типа объект a. Он может быть как собственно Object, так и любым его наследником, в котором метод toString() переопределён. Именно на этапе выполнения определяется тип a и вызывается toString() из того класса, какого типа объект a. Это и есть позднее связывание.<br><br>В случае статического связывания используются не конкретные объекты, а информация о типе, то есть используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения нужного метода используется конкретный объект.<br><br>Исходя из того, что раннее связывание выполняется на этапе компиляции, а позднее - в рантайме, первый вариант обладает лучшим быстродействием, однако второй необходим для реализации полиморфизма.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R22" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">23</div></th><td class="s12">SOLID</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">SOLID </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">— это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования. <br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">S(Single Responsibility Principle)</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - принцип единственной ответственности - каждый класс выполняет лишь одну задачу. <br>Легкая модификация в будущем, простое тестирование, класс не имеет зависимостей на другие классы.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">O(Open Closed Principle)</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - принцип открытости/закрытости - программные сущности открыты для расширения и закрыты для модификации.<br>Чтобы не сломать логику в классе-родителе, мы унаследуемся от него и реализуем что-то своё, и используем свой класс.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">L(Liskov’s Substitution Principle)</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - принцип подстановки барбары лисков -  объекты в программе можно заменить их наследниками без изменения свойств программы.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">I(Interface Segregation Principle)</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - принцип разделения интерфейса - много специализированных интерфейсов лучше, чем один общий<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">D(Dependency Inversion Principle) </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- принцип инверсии зависимостей - зависимость на абстракциях. <br>Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.<br>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.<br><br>Использование: Создание интерфейсов и их реализаций. Пример: терминал оплаты(абстракция) и разные карты оплаты.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R23" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">24</div></th><td class="s0" colspan="2">Java</td><td></td></tr><tr style="height: 42px"><th id="1989704007R24" style="height: 42px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 42px">25</div></th><td class="s9">Какая основная идея языка?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">«Написано однажды - работает везде»</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.<br>Идея основывается в написании одного кода, который будет работать на любой платформе.</span></td><td></td></tr><tr style="height: 97px"><th id="1989704007R25" style="height: 97px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 97px">26</div></th><td class="s9">За счет чего обеспечивается кроссплатформенность?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Кроссплатформенность была достигнута </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">за счёт</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> создания </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">виртуальной машина Java</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. Java Virtual Machine или JVM - это программа, являющаяся </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">прослойкой между операционной системой </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">и </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Java программой</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. В среде виртуальной машины выполняются коды Java программ. Сама JVM реализована для разных ОС.<br>Что байт код для JVM может исполняться везде где установлена JVM.<br>Код не нужно перекомпилировать под каждую из платформ.</span></td><td></td></tr><tr style="height: 506px"><th id="1989704007R26" style="height: 506px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 506px">27</div></th><td class="s9">Какие преимущества у java?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Объектно-ориентированное программирование   <br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- структура данных становится объектом, которым можно управлять для создания отношений между различными объектами.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Стандарт для корпоративных вычислительных систем<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- корпоративные приложения — главное преимущество Java с 90-х годов, когда организации начали искать надежные инструменты программирования не на C.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Безопасность <br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- благодарю отсутсвию указателей и Security Manager (политика безопасности, в которой можно указать правила доступа, позволяет запускать приложения Java в &quot;песочнице&quot;).<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Независимость от платформы <br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его на любой другой платформе, поддерживающей виртуальную машину Java (JVM). Таким образом, JVM служит уровнем абстракции между кодом и оборудованием.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Язык для распределенного программирования и комфортной удаленной совместной работы<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- Специфическая для Java методология распределенных вычислений называется Remote Method Invocation (RMI). RMI позволяет использовать все преимущества Java: безопасность, независимость от платформы и объектно-ориентированное программирование для распределенных вычислений. Кроме того, Java также поддерживает программирование сокетов и методологию распределения CORBA для обмена объектами между программами, написанными на разных языках.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Автоматическое управление памятью<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Разработчикам Java не нужно вручную писать код для управления памятью благодаря <br>автоматическому управлению памятью (AMM).<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Многопоточность<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Поток — наименьшая единица обработки в программировании. Чтобы максимально эффективно использовать время процессора, Java позволяет запускать потоки одновременно, что называется многопоточностью.</span></td><td></td></tr><tr style="height: 207px"><th id="1989704007R27" style="height: 207px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 207px">28</div></th><td class="s9">Какие недостатки у java?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Платное коммерческое использование (с 2019)<br><br>Низкая производительность<br></span><span style="font-size:10pt;font-family:Arial;">из-за компиляции и абстракции с помощью виртуальной машины, а также приложение очистки памяти.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Не развитые инструменты по созданию GUI приложений на чистой java.<br><br>Многословный код<br></span><span style="font-size:10pt;font-family:Arial;">Java — это более легкая версия неприступного C ++, которая вынуждает программистов прописывать свои действия словами из английского языка. Это делает язык более понятным для неспециалистов, но менее компактным.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R28" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">29</div></th><td class="s11">Что такое JDK? Что в него входит?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">JDK (Java Development Kit)</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> -</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"> включает JRE и набор инструментов разработчика </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">приложений на языке Java:<br>- компилятор Java (javac)<br>- стандартные библиотеки классов java<br>- примеры<br>- документацию<br>- различные утилиты</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R29" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">30</div></th><td class="s9">Что такое JRE? Что в него входит?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">JRE (java Runtime Environment) </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Состоит из JVM, ClassLoader</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">и</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> стандартного </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">набора библиотек</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> и классов Java</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R30" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">31</div></th><td class="s9">Что такое JVM?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">JVM (Java Virtual Machine) </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- виртуальная машина Java исполняет байт-код Java, предварительно созданный из кода JIT компилятором, с помощью встроенного интерпретатора байткода.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">HotSpot</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> представляет собой реализацию концепции JVM.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R31" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">32</div></th><td class="s9">Что такое byte code?</td><td class="s4">Байт-код Java — набор инструкций, скомпилированный компилятором, исполняемый JVM. </td><td></td></tr><tr style="height: 387px"><th id="1989704007R32" style="height: 387px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 387px">33</div></th><td class="s9">Что такое загрузчик классов (classloader)?</td><td class="s4">Используется<span style="font-size:10pt;font-family:Arial;font-weight:bold;"> для передачи в JVM скомпилированного байт-кода</span><span style="font-size:10pt;font-family:Arial;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">хранится в</span><span style="font-size:10pt;font-family:Arial;"> файлах с расширением </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">.class</span><span style="font-size:10pt;font-family:Arial;"><br><br>При запуске JVM, используются три загрузчика классов:<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">- Bootstrap ClassLoader - базовый загрузчик</span><span style="font-size:10pt;font-family:Arial;"><br>- загружает платформенные классы JDK из архива rt.jar<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">- AppClassLoader - системный загрузчик (3)<br></span><span style="font-size:10pt;font-family:Arial;">- загружает классы приложения, определенные в CLASSPATH <br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">- Extension ClassLoader - загрузчик расширений (2)</span><span style="font-size:10pt;font-family:Arial;"><br>- загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.<br><br>ClassLoader выполняет три основных действия в строгом порядке:<br>•        Загрузка: находит и импортирует двоичные данные для типа.<br>•        Связывание: выполняет проверку, подготовку и (необязательно) разрешение.<br> -        Проверка: обеспечивает правильность импортируемого типа.<br> -        Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию.<br> -        Разрешение: преобразует символические ссылки из типа в прямые ссылки.<br>•        Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.<br><br>Каждый загрузчик хранит указатель на родительский, чтобы суметь передать загрузку если сам будет не в состоянии этого сделать.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R33" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">34</div></th><td class="s9">Что такое JIT?</td><td class="s13"><a target="_blank" href="https://javahelp.online/osnovy/voprosy-otvety-sobesedovanie-java">JIT (Just-in-time compilation) - компиляция на лету или динамическая компиляция - технология увеличения производительности программных систем, использующих байт-код, путем компиляции байт-кода в машинный код во время работы программы.<br>В основном отвечает за оптимизацию производительности приложений во время выполнения.<br>https://javahelp.online/osnovy/voprosy-otvety-sobesedovanie-java (Q13)</a></td><td></td></tr><tr style="height: 20px"><th id="1989704007R34" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">35</div></th><td class="s14" rowspan="2">Что такое сборщик мусора? (Garbage collector)</td><td class="s10"><a target="_blank" href="http://habr.com/ru/post/269621">Про 4 типа сборщиков мусора читай здесь: habr.com/ru/post/269621</a></td><td></td></tr><tr style="height: 2082px"><th id="1989704007R35" style="height: 2082px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 2082px">36</div></th><td class="s4" dir="ltr"><span style="color:#3e5656;">Сборщик мусора выполняет две задачи:<br></span><span style="font-weight:bold;color:#3e5656;">- поиск мусора;</span><span style="color:#3e5656;"><br></span><span style="font-weight:bold;color:#3e5656;">- очистка мусора.</span><span style="color:#3e5656;"><br><br>                                                                                                                                                                                                <br>- поиск мусора;<br>- очистка мусора.<br><br>                                                                                                                                                                                                                                                                                                                                                                                                                                                </span><span style="font-weight:bold;color:#3e5656;">Для обнаружения</span><span style="color:#3e5656;"> </span><span style="font-weight:bold;color:#3e5656;">мусора есть</span><span style="color:#3e5656;"> </span><span style="font-weight:bold;color:#3e5656;">два подхода:<br><br></span><span style="color:#3e5656;">&quot;Reference Counting<br>Суть подхода состоит в том, что каждый объект имеет некоторый счетчик. Этот счетчик хранит информацию о том, сколько ссылок указывает на объект. Kогда какая-либо ссылка уничтожается, то и значение счетчика уменьшается.Если значение счетчика равно нулю - объект можно считать мусором и память, которую он занимает, можно очищать.<br>Tracing<br> Живые объекты - это те, до которых мы можем добраться от корня (GC Root), в то время как все остальные являются мусором.<br>Существует 4 типа корневых точки:<br>- Локальные переменные и параметры методов;<br>- Потоки;<br>- Статические переменные;<br>- Ссылки из JNI.<br>Самое простое java приложение будет иметь корневые точки:<br>- Локальные переменные внутри main() метода и параметры main() метода;<br>- Поток, который выполняет main();<br>- Статические переменные класса, внутри которого находится main() метод<br><br>Все что доступно с живого объекта - также живое.&quot;<br><br><br>&quot;Процессы сборки мусора разделяются несколько видов:<br>minor GC (малая) - частый и быстрый, работает только с областью памяти &quot;&quot;young generation&quot;&quot;;<br>- приложение приостанавливается на начало сборки мусора (такие остановки называются stop-the-world);<br>- «живые» объекты из Eden перемещаются в область памяти «To» (S1(From) и S2(To)); <br>- «живые» объекты из «From» перемещаются в «To» или в «old generation», если они достаточно «старые»;<br>- Eden и «From» очищаются от мусора;<br>- «To» и «From» меняются местами;<br>- приложение возобновляет работу.<br>major GC (старшая) - редкий и более длительный, затрагивает объекты старшего поколения.<br>В принцип работы «major GC» добавляется процедура «уплотнения», позволяющая более эффективно использовать память. В процедуре живые объекты перемещаются в начало. Таким образом, мусор остается в конце памяти.<br>full GC (полная) -  полный сборщик мусора сначала запускает Minor, а затем Major (хотя порядок может быть изменен, если старое поколение заполнено, и в этом случае он освобождается первым, чтобы позволить ему получать объекты от молодого поколения).&quot;<br><br><br><br><br>&quot;Serial (последовательный) — самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.<br><br>Parallel (параллельный) — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности.<br><br>Concurrent Mark Sweep (CMS) — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти.<br><br>Garbage-First (G1) — создан для постепенной замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных.&quot;<br><br><br><br><br><br><br><br></span><span style="font-weight:bold;color:#3e5656;">Области памяти heap<br></span><span style="color:#3e5656;">&quot;young generation : Это место, где жили в течение короткого периода времени и разделены на два пространства:<br><br>Эдем (первые жили Адам и Ева) Пространство : когда объект создается с использованием нового ключевого слова memory, выделенного в этом пространстве.<br>Survivor Space : это пул, который содержит объекты, уцелевшие после Java-сборки мусора из пространства Эдема.<br>old generationе : этот пул в основном содержит постоянное и виртуальное (зарезервированное) пространство и будет содержать те объекты, которые выжили после сборки мусора из молодого поколения.<br><br>Постоянное пространство: этот пул памяти содержит объекты, которые уцелели после многократной сборки мусора, означает объект, который уцелел после сборки мусора из оставшегося пространства.<br>permanent  generation : этот пул памяти, как следует из названия, также содержит постоянные метаданные класса и информацию дескрипторов, поэтому пространство PermGen всегда зарезервировано для классов и тех, которые привязаны к классам, например, для статических членов.<br><br><br><br><br>&quot;Трассировка - до обьекта можно добраться из Корневых точке (GC root). <br>До чего добраться нельзя - мусор.<br>Всё, что доступно из «живого» объекта, также является «живым».&quot;<br>Типы корневых точек (GC Roots) java приложения:<br>&quot;- объекты в статических полях классов<br>- объекты, доступные из стека потоков<br>- объекты из JNI(java native interface) ссылок в native методах&quot;</span></td><td class="s15" dir="ltr">1. Что такое сборщик мусора (Garbage Collector)?<br><br>Сборщик мусора (GC) — это механизм в Java, который автоматически управляет памятью. Он отвечает за освобождение памяти, занятой объектами, которые больше не используются в программе. Сборщик мусора отслеживает объекты, которые стали не доступными (не могут быть использованы в дальнейшем) и освобождает память для новых объектов.<br><br>3. Как работает сборщик мусора?<br><br>Сборщик мусора работает в два этапа:<br><br>    Выявление неиспользуемых объектов.<br>    Освобождение памяти.<br><br>Сначала давай разберем, как он находит ненужные объекты, а потом — как он их удаляет.<br>Этап 1: Выявление ненужных объектов<br><br>Сборщик мусора в Java использует концепцию достижимости объектов. Объекты, на которые все еще есть ссылки (доступы), считаются достижимыми и не подлежат сборке. Объекты, на которые нет ссылок, считаются недостижимыми и могут быть удалены.<br><br>    Корни (roots): Это ссылки, которые доступны непосредственно, например, переменные в методах, статические поля и т.д. Если объект достижим от этих корней, он остается в памяти.<br>    Путь к объекту: Если от корня можно пройти по ссылкам, следуя от одного объекта к другому, то все эти объекты считаются достижимыми.<br><br>Пример:<br><br>Object obj1 = new Object();<br>Object obj2 = new Object();<br>obj1 = obj2;  // obj1 теперь указывает на тот же объект, что и obj2<br><br>В этом примере объект, на который указывает obj1, стал недостижимым (потому что теперь obj1 указывает на тот же объект, что и obj2), и его можно удалить.<br>Этап 2: Удаление объектов (сборка мусора)<br><br>Как только сборщик мусора определяет, что объект недостижим, он освобождает память, занятую этим объектом, с помощью процесса, называемого сборкой мусора. Для этого JVM использует различные алгоритмы, и каждый из них имеет свои особенности.<br><br>Сборщик мусора работает на фоне, не влияя напрямую на выполнение программы, но иногда он может замедлять выполнение, особенно когда программа нуждается в большом количестве памяти.<br>4. Как работает сборщик мусора в JVM?<br><br>JVM использует несколько алгоритмов и техник для выполнения сборки мусора. Разберем основные из них.<br>4.1. Алгоритмы сборщика мусора<br><br>    Маркировка и удаление (Mark-and-Sweep):<br>        Маркировка: Сначала сборщик мусора проходит по всем объектам и &quot;метит&quot; те, которые достижимы (к которым можно добраться через ссылки).<br>        Удаление: Затем он проходит по всем объектам и удаляет те, которые не были помечены (т.е. которые недостижимы).<br><br>    Молодая и старая память (Young and Old Generation):<br><br>        В JVM память делится на молодую (Young) и старую (Old) генерации. Это разделение улучшает производительность, так как большинство объектов живут недолго и могут быть собраны быстрее в молодой памяти.<br><br>        Молодая память — это пространство для объектов, которые недавно были созданы. Здесь также используется алгоритм копирования (Copying), при котором живые объекты копируются в другую часть памяти, а мертвыми удаляются.<br><br>        Старая память — это пространство для объектов, которые существуют долго (например, глобальные объекты). Здесь обычно применяется маркировка и удаление.<br><br>4.2. Основные этапы работы GC в JVM<br><br>    Аллокация: JVM выделяет память для новых объектов.<br>    Молодая сборка мусора (Minor GC):<br>        Когда молодая память переполняется, происходит Minor GC, который собирает мусор только в молодой памяти.<br>    Основная сборка мусора (Major GC или Full GC):<br>        Когда старая память переполняется, происходит Major GC, который затрагивает как старую, так и молодую память.<br>    Освобождение памяти: После выполнения сборщика мусора, память освобождается для новых объектов.<br><br>5. Типы сборщиков мусора в Java<br><br>Существует несколько видов сборщиков мусора, каждый из которых оптимизирован под разные сценарии:<br><br>    Serial Garbage Collector:<br>        Работает с одной нитью, что делает его простым, но медленным.<br>        Подходит для небольших приложений с ограниченными требованиями к памяти.<br><br>    Parallel Garbage Collector (или Throughput Collector):<br>        Использует несколько потоков для сборки мусора и предназначен для серверных приложений с большим количеством процессорных ядер.<br>        Работает быстрее, чем Serial GC, но может вызвать паузы в работе приложения.<br><br>    CMS (Concurrent Mark-Sweep) Garbage Collector:<br>        Использует несколько потоков для минимизации пауз.<br>        Хорошо подходит для приложений, которые требуют минимальных пауз при сборке мусора (например, для приложений с реальным временем).<br><br>    G1 Garbage Collector:<br>        Более современный сборщик мусора, который предоставляет сбалансированное решение для минимизации пауз и хорошей производительности.<br>        Разбивает память на регионы и адаптируется под нужды программы.<br>        По умолчанию используется в более новых версиях Java.<br><br>6. Процесс сборки мусора и паузы (GC Pause)<br><br>Сборка мусора может вызывать паузы (GC Pause), когда JVM останавливает выполнение программы для освобождения памяти. В зависимости от выбранного сборщика мусора и конфигурации, паузы могут быть короткими или долгими:<br><br>    Minor GC вызывает небольшие паузы, так как она работает только с молодой памятью.<br>    Major GC или Full GC вызывает более длинные паузы, так как затрагиваются все области памяти.<br><br>7. Когда происходит сборка мусора?<br><br>Сборка мусора не происходит постоянно. JVM решает, когда проводить GC, исходя из разных факторов:<br><br>    Нехватка памяти: Когда JVM понимает, что в куче не хватает памяти для новых объектов.<br>    Отсутствие ссылок на объект: Когда объект больше не нужен и на него не осталось ссылок.<br><br>8. Какие проблемы могут возникать?<br><br>    Утечка памяти: Иногда может случиться, что объекты, которые должны быть собраны, остаются в памяти, потому что на них есть скрытые ссылки.<br>    Паузы: Если GC настроен неправильно, может возникать заметное замедление работы приложения.<br></td></tr><tr style="height: 20px"><th id="1989704007R36" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">37</div></th><td class="s9" rowspan="6">Виды ссылок в Java</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">1) </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">StrongReference </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">— это самые обычные ссылки которые мы создаем каждый день, любая переменная ссылочного типа.<br>        StringBuilder builder = new StringBuilder(); - builder это и есть strong-ссылка на объект StringBuilder.Любой объект что имеет strong ссылку запрещен для удаления сборщиком мусора.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R37" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">38</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">2) </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">SoftReference </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">—  GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем как бросит OutOfMemoryError. SoftReference это наш механизм кэширования объектов в памяти, но в критической ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует спасти JVM от завершения работы.<br>        StringBuilder builder = new StringBuilder();<br>        SoftReference&lt;StringBuilder&gt; softBuilder = new SoftReference(builder);<br><br>softBuilder.get() — вернет strong-ссылку на объект StringBuilder в случае если GC не удалил этот объект из памяти. В другом случае вернется null.<br>softBuilder.clear() — удалит ссылку на объект StringBuilder<br>То же самое работает для </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">WeakReference</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.</span></td><td class="s3"></td></tr><tr style="height: 20px"><th id="1989704007R38" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">39</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">3) </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">WeakReference </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">— если GC видит, что объект доступен только через цепочку weak-ссылок (исчезнули strong-ссылки), то он удалит его из памяти.</span></td><td></td></tr><tr style="height: 160px"><th id="1989704007R39" style="height: 160px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 160px">40</div></th><td class="s4">4) <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">PhantomReference </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">— если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из памяти. После нескольких запусков GC.<br>Особенностей у этого типа ссылок две.<br>Первая это то, что метод get() всегда возвращает null. Именно из-за этого PhantomReference имеет смысл использовать только вместе с ReferenceQueue.<br>Вторая особенность – в отличие от SoftReference и WeakReference, GC добавит phantom-ссылку в ReferenceQueue </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">после </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">того как выполниться метод finalize().Вернемся к PhantomReference.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"> Этот тип ссылок в комбинации с ReferenceQueue позволяет нам узнать, когда объект более недоступен и на него нет других ссылок. Это позволяет нам сделать очистку ресурсов, используемых объектом, на уровне приложения. В отличии от finalize() мы сами контролируем процесс очистки ресурсов.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R40" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">41</div></th><td class="s7">So in brief: Soft references try to keep the reference. Weak references don’t try to keep the reference. Phantom references don’t free the reference until cleared.</td><td></td></tr><tr style="height: 20px"><th id="1989704007R41" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">42</div></th><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">ReferenceQueue</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. Он позволяет отслеживать момент, когда GC определит что объект более не нужен и его можно удалить. Именно сюда попадает Reference объект после того как объект на который он ссылается удален из памяти. При создании Reference мы можем передать в конструктор ReferenceQueue, в который будут помещаться ссылки после удаления.</span></td><td class="s8">finalize(). Этот метод вызывается Java-машиной у объекта перед тем, как объект будет уничтожен</td></tr><tr style="height: 20px"><th id="1989704007R42" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">43</div></th><td class="s11" rowspan="5"> Stack и Heap</td><td class="s3">Память процесса делится на Stack (стек) и Heap (куча) :<br>- <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Stack</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">  </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">отвечает за хранение ссылок на объекты кучи содержит staсk frame&#39;ы, они делятся на три части: параметры метода, указатель на предыдущий фрейм и локальные переменные.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>Stack это область хранения данных, находящееся в общей оперативной памяти (RAM). Всякий раз, когда вызывается метод, в памяти стека создается новый блок-фрейм, который содержит локальные переменные метода и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Стек в Java работает по схеме LIFO      </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>- Структура Heap зависит от выбранного сборщика мусора. Читай про GC!<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">PermGen (Permanent Generation) — это специальное место в куче, отделенное от основной памяти. В PermGen виртуальная машина хранит метаданные загруженных классов. Также здесь находятся всё статическое содержимое приложения, переменные примитивных типов и ссылки на статические объекты, хранит данные о байткоде и JIT информацию. </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">По умолчанию, максимальный размер этой области памяти для 32-х битной JVM равен 64 Мб, а для 64-х битной версии — 82 Мб. -XX:PermSize=[размер] для установки минимального размера PermGen области • -XX:MaxPermSize=[размер] для установки максимального размера  </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Из-за своего ограниченного размера, PermGen является причиной возникновения ошибки java.lang.OutOfMemoryError: PermGen space. Metaspace – новая область памяти, появившаяся в 8 версии Java и заменившая устаревшую PermGen. Основное их отличие заключается в способе распределения памяти. По умолчанию, Metaspace увеличивается автоматически. </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Однако и здесь у нас есть возможность управления памятью: • При помощи MetaspaceSize и MaxMetaspaceSize можно задать границы Metaspace области. В результате появления Metaspace, процесс очистки памяти получил некоторые преимущества. Теперь сборщик мусора автоматически удаляет из памяти ненужные классы, когда емкость, выделенная для хранения метаданных, достигает максимального значения. Вместе с этим, уменьшилась<br>Вкратце, при Serial/Parallel/CMS GC будет следующая структура:</span></td><td class="s3" rowspan="2">Последний зашел первый вышел работа стека. Стек создается при ининцилизации метода заполняет себя примит.типами ссылки на объекты после окончаения метода он освобождается</td></tr><tr style="height: 86px"><th id="1989704007R43" style="height: 86px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 86px">44</div></th><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Heap</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - Эта область памяти разбита на несколько более мелких частей, называемых поколениями: Young Generation — область где размещаются недавно созданные объекты. Когда она заполняется, происходит быстрая сборка мусора Old (Tenured) Generation — здесь хранятся долгоживущие объекты. Когда объекты из Young Generation достигают определенного порога «возраста», они перемещаются в Old Generation Permanent Generation — эта область содержит метаинформацию о классах и методах приложения, но начиная с Java 8 данная область памяти была упразднена. (классы и методы)</span></td></tr><tr style="height: 20px"><th id="1989704007R44" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">45</div></th><td class="s3">А при G1 GC:</td><td></td></tr><tr style="height: 78px"><th id="1989704007R45" style="height: 78px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 78px">46</div></th><td class="s3"></td><td class="s15"></td></tr><tr style="height: 20px"><th id="1989704007R46" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">47</div></th><td class="s16">С помощью опций Xms и Xmx можно настроить начальный и максимально допустимый размер кучи соответственно. Существуют опции для настройки величины стека.<br><br>- Heap - используется всем приложением, Stack - одним потоком исполняемой программы.<br>- Новый обьект создается в heap, в stack размещается ссылка на него. В стеке размещаются локальные переменные примитивных типов. <br>- Обьекты в куче доступны из любого места программы, стековая память не доступна для других потоков.<br>- Если память стека закончилась JRE вызовет исключение StackOverflowError, если куча заполнена OutOfMemoryError<br>- Размер памяти стека, меньше памяти кучи. Стековая память быстрее памяти кучи.<br>- В куче есть ссылки между объектами и их классами. На этом основана рефлексия.<br><br>Обе области хранятся в RAM.</td><td class="s15"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">На мою оперативу в 16 Гб - (268_435_456 байт миниму) (4_280_287_232 байт максимум)       Куча</span><span style="font-size:10pt;font-family:Arial;"> Эта область памяти используется для динамического выделения памяти для объектов и классов JRE во время выполнения. Новые объекты всегда создаются в куче, а ссылки на них хранятся в стеке. Эти объекты имеют глобальный доступ и могут быть получены из любого места программы.</span></td></tr><tr style="height: 20px"><th id="1989704007R47" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">48</div></th><td class="s0" colspan="2">Процедурная Java</td><td></td></tr><tr style="height: 180px"><th id="1989704007R48" style="height: 180px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 180px">49</div></th><td class="s17">Какие примитивные типы данных есть в Java?</td><td class="s4">Вещественные, целочисленные, логические и строковые.<br>&quot;Вещественные, целочисленные, логические и строковые.<br>byte          8 бит      от -128 до 127<br>short        16 бит     от -32768 до 32767<br>int            32 бит     от -2147483648 до 2147483647<br>long         64 бит     от -9223372036854775808L до 9223372036854775807L<br>float         32            от 1.4e-45f до 3.4e+38f<br>double     64            от 4.9e-324 до 1.7e+308<br>char<br>boolean&quot;</td><td></td></tr><tr style="height: 20px"><th id="1989704007R49" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">50</div></th><td class="s17">Что такое char?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">16-разрядное беззнаковое целое</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, представляющее собой символ UTF-16 (буквы и цифры)</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R50" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">51</div></th><td class="s17">Сколько памяти занимает boolean?</td><td class="s7"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Зависит от реализации JVM<br></span><span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#3e5656;">В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int. Однако, в определенных версия JVM имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту.<br></span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R51" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">52</div></th><td class="s17">Что такое классы-обертки?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Обертка — это специальный </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">класс</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">который хранит внутри </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">себя </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">значение примитива(объекты классов-оберток являются неизменяемыми (Immutable))</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.<br>Нужны для реализации дженериков.</span></td><td></td></tr><tr style="height: 132px"><th id="1989704007R52" style="height: 132px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 132px">53</div></th><td class="s17">Что такое автоупаковка и автораспаковка?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Автоупаковка </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">присвоение классу </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">обертки </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">значения примитивного типа</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">;<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Автораспаковка </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">присвоение переменной примитивного типа значение класса </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">обертки.<br><br>для присваивания ссылок-примитивов объектам их классов-оберток (и наоборот) не требуется ничего делать, все происходит автоматически.<br>Для того, чтобы иметь возможность оперировать с простыми числами (и boolean) как с объектами были придуманы классы-обёртки.</span></td><td class="s15"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Автоупаковка</span><span style="font-size:10pt;font-family:Arial;"><br><br>Integer integer = 9; </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Распаковка</span><span style="font-size:10pt;font-family:Arial;"><br><br>int in = 0;<br>in = new Integer(9);</span></td></tr><tr style="height: 126px"><th id="1989704007R53" style="height: 126px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 126px">54</div></th><td class="s17">Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Неявное приведение </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">– автоматическое </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">расширение </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">типа переменной </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">от меньшего к большему.<br><br>Явное приведение</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> -  </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">явное сужение от большего к меньшему.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> Необходимо явно указать сужаемый тип.long l = (long)d; //explicit type casting int i = (int)l;<br><br>В случае с объектами мы можем делать неявное(автоматическое) приведение от наследника к родителю, но не наоборот, иначе получим ClassCastException.</span></td><td class="s15"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Расширение приведения</span><span style="font-size:10pt;font-family:Arial;"> (автоматически) – преобразование меньшего типа данных в больший размер типа. byte -&gt; short -&gt; char -&gt; int -&gt; long -&gt; float -&gt; double</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;"> Сужение приведения</span><span style="font-size:10pt;font-family:Arial;"> (вручную) – преобразование данных большего размера в тип меньшего размера. double -&gt; float -&gt; long -&gt; int -&gt; char -&gt; short -&gt; byte Источник: https://java-blog.ru/osnovy/privedeniya-tipov-java</span></td></tr><tr style="height: 20px"><th id="1989704007R54" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">55</div></th><td class="s17">Что такое пул интов?</td><td class="s4">В Java есть пул(pool) целых чисел в промежутке [-128;127], так как это самый часто вречающийся диапазон. Т.е. если мы создаем Integer в этом промежутке, то вместо того, чтобы каждый раз создавать новый объект, JVM берет их из пула. <br>Изменить размер кэша в HotSpot вы можете, указав ключ -XX:AutoBoxCacheMax=&lt;размер&gt;. ( внастройках JVM)</td><td class="s8">Пул есть у всех целочисленных и у char размер у них менять нельзя</td></tr><tr style="height: 20px"><th id="1989704007R55" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">56</div></th><td class="s11">Какие нюансы у строк в Java?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Класс </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">String </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">в Java -  </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">неизменяемый</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> из-за модификатора final и отсутствия сеттера. Это нужно для реализации пула стрингов. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">При редактировании </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">будет создаваться </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">новая строка</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">При копировании </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">новая строка не создается, а создается </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">ссылка на существующую </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">строку.</span></td><td class="s8">Конкатенация - складывание строк. String с java 7 можно исользовать в swith</td></tr><tr style="height: 20px"><th id="1989704007R56" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">57</div></th><td class="s17">Что такое пул строк?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Область памяти где хранятся обьекты строк</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">При создании </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">в пуле идет </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">поиск строки:<br>-если НЕ находит - </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">создается строка, возращается ссылка<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">-</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">если находит - возращает ссылку найденной </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">строки.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"><br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">При этом использование оператора new заставляет класс String создать новый объект, даже если такая строка уже есть в пуле. После этого можем использовать метод intern(), чтобы поместить этот объект в пул строк.<br><br>Пул строк и Integer хранится в heap, но ссылки на объекты хранятся в stack.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R57" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">58</div></th><td class="s17">Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Т.к. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">строка неизменяемый класс</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, потребление ресурсов при редактировании, т.к. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">каждую итерацию </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">при редактировании </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">будет создаваться новый обьект </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">строки. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Рекомендуется </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">использовать </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">StringBuilder или StringBuffer</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R58" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">59</div></th><td class="s11">Почему строки не рекомендуется использовать для хранения паролей?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">1. Пул строк</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>Так как строки в Java хранятся в пуле строк, то ваш пароль в виде обычного текста будет доступен в памяти, пока сборщик мусора не очистит её. И поскольку String используются в String pool для повторного использования, существует довольно высокая вероятность того, что пароль останется в памяти надолго, что совсем не безопасно. <br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">2. Рекомендации авторов</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>Java сама по себе рекомендует использовать метод getPassword () из класса JPasswordField, который возвращает char [].<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">3. Случайная печать в логах</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>С типом String всегда существует опасность того, что текст, хранящийся в строке будет напечатан в файле логов или в консоли. В то же время в случае использования Array, вы не будете печатать содержимое массива, а только его расположение в памяти.</span></td><td class="s8">intern добавить в pool</td></tr><tr style="height: 20px"><th id="1989704007R59" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">60</div></th><td class="s11">Почему String неизменяемый и финализированный класс?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-style:italic;color:#3e5656;">1. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#3e5656;">Для </span><span style="font-size:10pt;font-family:Arial;font-style:italic;color:#3e5656;">возможности </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#3e5656;">реализации строкового пула (String pool)</span><span style="font-size:10pt;font-family:Arial;font-style:italic;color:#3e5656;"><br><br>Виртуальная машина имеет возможность сохранить много места в памяти (heap space) т.к. разные строковые переменные указывают на одну переменную в пуле. При изменяемости строк было бы невозможно реализовать интернирование, поскольку если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.<br><br>2. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#3e5656;">Безопасность</span><span style="font-size:10pt;font-family:Arial;font-style:italic;color:#3e5656;"><br><br>Изменяемость строк несло бы в себе потенциальную угрозу безопасности приложения. Поскольку в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. — неизменяемость позволяет избежать проблем с доступом.<br><br>3. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#3e5656;">Для многопоточности</span><span style="font-size:10pt;font-family:Arial;font-style:italic;color:#3e5656;">. Неизменяемые </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#3e5656;">строки потокобезопасны<br></span><span style="font-size:10pt;font-family:Arial;font-style:italic;color:#3e5656;"><br>Так как строка неизменяемая то, она безопасна для много поточности и один экземпляр строки может быть совместно использован различными потоками. Это позволяет избежать синхронизации для потокобезопасности. Таким образом, строки в Java полностью потокобезопасны.<br><br>4. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#3e5656;">Ключ для HashMap<br></span><span style="font-size:10pt;font-family:Arial;font-style:italic;color:#3e5656;"><br>Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет никакой необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Поэтому строка наиболее часто используется в качестве ключа HashMap.<br><br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- можно передавать строку между потоками не опасаясь, что она будет изменена<br>- отсутствуют проблемы с синхронизацией потоков<br>- отсутствие проблем с  утечкой памяти<br>- отсутствие проблем с доступом и безопасностью при использовании строк для передачи параметров авторизации, открытия файлов и т.д.<br>- кэширование hashcode<br>- Экономия памяти при использовании пула строк для хранения повторяющихся строк.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R60" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">61</div></th><td class="s11">Почему строка является популярным ключом в HashMap в Java?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Поскольку </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">строки неизменны</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">их хэшкод кэшируется</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> в момент создания, и </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">не требует повторного пересчета.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R61" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">62</div></th><td class="s17">Что делает метод intern() в классе String?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Помещает</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> строку </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">в pool строк.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R62" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">63</div></th><td class="s17">Можно ли использовать строки в конструкции switch?</td><td class="s13"><a target="_blank" href="https://javarush.ru/groups/posts/759-java-string-voprosih-k-sobesedovaniju-i-otvetih-na-nikh-ch1">Да, начиная с Java 7 в операторе switch можно использовать строки, ранние версии Java не поддерживают этого. <br><br>Более подробно: https://javarush.ru/groups/posts/759-java-string-voprosih-k-sobesedovaniju-i-otvetih-na-nikh-ch1 (10)<br>При этом:<br>- участвующие строки чувствительны к регистру;<br>- использование строк в конструкции switch делает код читабельнее, убирая множественные цепи условий if-else<br>- оператор switch использует метод String.equals() для сравнения полученного значения со значениями case, поэтому добавьте проверку на NULL во избежание NullPointerException.</a></td><td></td></tr><tr style="height: 20px"><th id="1989704007R63" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">64</div></th><td class="s11">Какая основная разница между String, StringBuffer, StringBuilder?</td><td class="s4">String - неизменяемый, потокобезопасный;<br>StringBuffer - изменяемый, потокобезопасный;<br>StringBuilder - изменяемый, потоконебезопасный.</td><td></td></tr><tr style="height: 20px"><th id="1989704007R64" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">65</div></th><td class="s17">Существуют ли в java многомерные массивы?</td><td class="s4">Многомерные массивы в их классическом понимании в java не существуют.<br>Многомерный массив всегда прямоугольный и неразрывен в памяти. А то, что в java считается мнгомерным - в других языках ещё называют &quot;зубчатым массивом&quot; или массивом массивов.</td><td></td></tr><tr style="height: 20px"><th id="1989704007R65" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">66</div></th><td class="s17">Какими значениями инициируются переменные по умолчанию?</td><td class="s7">byte 0<br>short 0<br>int 0<br>long 0L<br>float 0.0f<br>double 0.0d<br>char &#39;\u0000&#39; <br>boolean false<br>Обьекты null<br><span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#3e5656;">Локальные (в методе) переменные не имеют значений по умолчанию, их имеют поля класса.<br>Не static-поле класса будет инициализировано после того, как будет создан объект этого класса. А static-поле будет инициализировано тогда, когда класс будет загружен виртуальной Java машиной.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R66" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">67</div></th><td class="s17">Что такое сигнатура метода?</td><td class="s18"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Это </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">имя метода </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">плюс </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">параметры </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">(порядок параметров имеет значение из-за множественной передачи данных через троеточие, которое должно располагаться последним). В сигнатуру метода не входит возвращаемое значение, а также бросаемые им исключения.<br>А сигнатура метода в сочетании с типом возвращаемого значения и бросаемыми исключениями называется </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">контрактом метода.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R67" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">68</div></th><td class="s17">Расскажите про метод main</td><td class="s19"><span style="font-size:11pt;font-family:Arial;font-weight:bold;color:#3e5656;">Является</span><span style="font-size:11pt;font-family:Arial;color:#3e5656;">, как правило, </span><span style="font-size:11pt;font-family:Arial;font-weight:bold;color:#3e5656;">точкой входа</span><span style="font-size:11pt;font-family:Arial;color:#3e5656;"> в программу и </span><span style="font-size:11pt;font-family:Arial;font-weight:bold;color:#3e5656;">вызывается</span><span style="font-size:11pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:11pt;font-family:Arial;font-weight:bold;color:#3e5656;">JVM</span><span style="font-size:11pt;font-family:Arial;color:#3e5656;">. <br>Как только </span><span style="font-size:11pt;font-family:Arial;font-weight:bold;color:#3e5656;">заканчивается выполнение</span><span style="font-size:11pt;font-family:Arial;color:#3e5656;"> метода </span><span style="font-size:11pt;font-family:Arial;font-weight:bold;color:#3e5656;">main()</span><span style="font-size:11pt;font-family:Arial;color:#3e5656;">, так сразу же </span><span style="font-size:11pt;font-family:Arial;font-weight:bold;color:#3e5656;">завершается</span><span style="font-size:11pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:11pt;font-family:Arial;font-weight:bold;color:#3e5656;">работа </span><span style="font-size:11pt;font-family:Arial;color:#3e5656;">самой </span><span style="font-size:11pt;font-family:Arial;font-weight:bold;color:#3e5656;">программы</span><span style="font-size:11pt;font-family:Arial;color:#3e5656;">.<br>static - чтобы JVM смогла загрузить его во время компиляции.<br>public static void и сигнатура - обязательное декларирование.<br>Мэйнов может быть много и может не быть вообще.<br>Может быть перегружен.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R68" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">69</div></th><td class="s17">Каким образом переменные передаются в методы, по значению или по ссылке?</td><td class="s13"><a target="_blank" href="https://javarush.ru/groups/posts/857-peredacha-parametrov-v-java">Java передает параметры по значению. Всегда.<br>С примитивами, мы получаем копию содержимого. Со ссылками мы тоже получаем копию ссылки.<br><br>https://javarush.ru/groups/posts/857-peredacha-parametrov-v-java</a></td><td></td></tr><tr style="height: 20px"><th id="1989704007R69" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">70</div></th><td class="s0" colspan="2">ООП в Java</td><td></td></tr><tr style="height: 20px"><th id="1989704007R70" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">71</div></th><td class="s11">Какие виды классов есть в java?</td><td class="s13"><a target="_blank" href="https://ru.stackoverflow.com/questions/515940/%D0%9B%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B8-%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B5%D0%BD%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B">1. Вложенные классы – нестатические классы внутри внешнего класса.<br>2. Вложенные статические классы – статические классы внутри внешнего класса.<br>3. Локальные классы Java – классы внутри методов. разница между локальным и внутреним<br>4. Анонимные Java классы – классы, которые создаются на ходу. Анонимные классы доступно<br>5. Final, abstract, enum - классы</a></td><td></td></tr><tr style="height: 319px"><th id="1989704007R71" style="height: 319px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 319px">72</div></th><td class="s11">Расскажите про вложенные классы. В каких случаях они применяются?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Нужны для обслуживания внешних классов</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"><br><br>1. Статические вложенные классы (Static nested classes)<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">o        Есть возможность обращения к внутренним статическим полям и методам класса обертки.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">2. Вложенные классы<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">o        Есть возможность обращения к внутренним полям и методам класса обертки.<br>o        Не может иметь статических объявлений.<br>o        Внутри такого класса нельзя объявить перечисления.<br>o        Если нужно явно получить this внешнего класса — OuterClass.this<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">3. Локальный класс<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">o        Видны только в пределах блока, в котором объявлены.<br>o        Не могут быть объявлены как private/public/protected или static (по этой причине интерфейсы нельзя объявить локально).<br>o        Не могут иметь внутри себя статических объявлений (полей, методов, классов), но могут иметь константы (static final)<br>o        Имеют доступ к полям и методам обрамляющего класса.<br>o        Можно обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final или являются effectively final.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">4.        Анонимные классы<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">o        Локальный класс без имени.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R72" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">73</div></th><td class="s11">- Что такое «локальный класс»? Каковы его особенности?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Данные классы </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">объявляются внутри других методов</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. Они </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">обладают всеми свойствами нестатического вложенного класса</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, только </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">создавать их экземпляры можно только в методе</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Особенности:</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>Локальные классы </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">способны работать</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> только с </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">final переменными </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">метода. <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">С 8+ версий Java</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">можно использовать</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">не final переменные в локальных класса</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">х, но только при условии, что они </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">не будут изменяться</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.<br>Локальные классы </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">нельзя объявлять с модификаторами доступа</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.<br>Локальные классы</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"> обладают доступом к переменным метода.<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Может быть создан внутри блоков инициализации.</span></td><td></td></tr><tr style="height: 418px"><th id="1989704007R73" style="height: 418px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 418px">74</div></th><td class="s11">Что такое «анонимные классы»? Где они применяются?</td><td class="s4">Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. <br><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Создание экземпляра анонимного класса происходит одновременно с его объявлением. </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Анонимные классы имеют несколько ограничений:<br>Их использование разрешено только в одном месте программы - месте его создания;<br>Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;<br>Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br><br>Анонимные классы обычно применяются для:<br>создания объекта функции (function object), например реализация интерфейса Comparator;<br>создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;<br>в статическом методе генерации;<br>инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"><br><br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Анонимные классы всегда являются конечными классами. <br>Каждое объявление анонимного класса уникально. Видны только внутри того метода, в котором определены. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">В документации Oracle приведена хорошая рекомендация: «Применяйте анонимные классы, если вам нужен локальный класс для одноразового использования». </span></td><td class="s20">public interface MonitoringSystem {<br><br>   public void startMonitoring();<br>}                                                                                                          public<span style="font-size:14pt;font-family:Consolas,Arial;color:#c3cbd2;"> </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#d07b34;">class</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#c3cbd2;"> Main { </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#d07b34;">public</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#c3cbd2;"> </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#d07b34;">static</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#c3cbd2;"> </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#d07b34;">void</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#c3cbd2;"> </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#ffc66d;">main</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#c3cbd2;">(String[] args) {                                                       MonitoringSystem generalModule = </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#d07b34;">new</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#c3cbd2;"> MonitoringSystem() { </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#bbb529;">@Override</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#c3cbd2;"> </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#d07b34;">public</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#c3cbd2;"> </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#d07b34;">void</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#c3cbd2;"> </span><span style="font-size:14pt;font-family:Consolas,Arial;color:#ffc66d;">startMonitoring</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#c3cbd2;">() { System.out.</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#ffc66d;">println</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#c3cbd2;">(</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#2ca433;">&quot;Мониторинг общих показателей стартовал!&quot;</span><span style="font-size:14pt;font-family:Consolas,Arial;color:#c3cbd2;">); } }; </span></td></tr><tr style="height: 20px"><th id="1989704007R74" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">75</div></th><td class="s11">- Каким образом из вложенного класса получить доступ к полю внешнего класса?</td><td class="s4">Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса.<br>Простой вложенный класс, может обратиться к любому полю внешнего класса напрямую. <br><br>В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к внешнему полю следует через имя внешнего класса. Например: Outer.this.field.</td><td></td></tr><tr style="height: 297px"><th id="1989704007R75" style="height: 297px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 297px">76</div></th><td class="s11">Что такое перечисления (enum)?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Перечисления представляют </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">набор логически связанных констант. <br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>Перечисление фактически представляет новый класс, поэтому мы можем определить переменную данного типа и использовать ее.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Перечисления</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, как и обычные классы, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">могут определять конструкторы, поля и методы.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> <br>Следует отметить, что</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"> конструктор по умолчанию приватный.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> Также можно определять методы для отдельных констант.<br>Методы:<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">-ordinal() </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">возвращает порядковый </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">номер определенной константы</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> (нумерация начинается с 0)<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">-values() </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">возвращает </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">массив всех констант</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> перечисления<br>Еnum имеет ряд преимуществ при использовании в сравнении с static final int. <br>Главным отличием является то что</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"> используя enum вы можете проверить тип данных</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Недостатки</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>-  К ним </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">не применимы операторы &gt;, &lt;, &gt;=, &lt;=</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>- enum также </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">требует больше памяти для хранения</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> чем обычная константа.<br><br>Нужны для ограничения области допустимых значений: например, времена года, дни недели</span></td><td class="s3">public final String <span style="font-size:10pt;font-family:Arial;font-weight:bold;">name()</span><span style="font-size:10pt;font-family:Arial;"> – возвращает задекларированное имя константы. public String </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">toString()</span><span style="font-size:10pt;font-family:Arial;"> – по умолчанию возвращает задекларированное имя константы, однако в отличие от name() может быть переопределен. public final int </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">ordinal()</span><span style="font-size:10pt;font-family:Arial;"> – порядковый номер в котором экземпляр перечисления обозначен внутри enum. public final int </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">compareTo(E</span><span style="font-size:10pt;font-family:Arial;"> o) — имитирует порядок, предоставляемый методом ordinal(). Т.О. enum ограничивает сравнения только порядком их объявления. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">String name = &quot;WINTER&quot;;<br>Season season = Season.valueOf(name);</span></td></tr><tr style="height: 229px"><th id="1989704007R76" style="height: 229px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 229px">77</div></th><td class="s11">Как проблема ромбовидного наследования решена в java?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">В Java нет поддержки множественного наследования классов.<br><br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Предположим, что SuperClass — это абстрактный класс, описывающий некоторый метод, а классы ClassA и ClassB — обычные классы наследники SuperClass, а класс ClassC наследуется от ClassA и ClassB одновременно. Вызов метода родительского класса приведет к неопределенности, так как компилятор не знает о том, метод какого именно суперкласса должен быть вызван. Это и есть основная причина, почему в Java нет поддержки множественного наследования классов.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">1. Классы всегда побеждают</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">: Определенный в классе / суперклассе метод всегда имеет высший приоритет перед дефолтными методами интерфейсов.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">2.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> Если не срабатывает правило 1, то </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">побеждают саб-интерфейсы (more specific)</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. Т.е. если интерфейс B наследует A, и у обоих есть методы с одинаковой сигнатурой, то побеждает B.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">3.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> Если оба правила не работают, то класс, наследующий конфликтующие интерфейсы, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">должен явно через super определить</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, какой именно метод вызвать, иначе компилятор будет сильно материться.</span></td><td></td></tr><tr style="height: 229px"><th id="1989704007R77" style="height: 229px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 229px">78</div></th><td class="s11">Что такое конструктор по умолчанию?</td><td class="s4">Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый «конструктор по умолчанию».<br>Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.</td><td></td></tr><tr style="height: 20px"><th id="1989704007R78" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">79</div></th><td class="s11">Могут ли быть приватные конструкторы? Для чего они нужны?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Да, могут. Приватный конструктор </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">запрещает создание экземпляра класса вне методов самого класса.<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Нужен для реализации паттернов, например singleton.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R79" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">80</div></th><td class="s11">Расскажите про классы-загрузчики и про динамическую загрузку классов.</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">При запуске JVM, используются три загрузчика классов:<br><br>- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Bootstrap ClassLoader</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - главный загрузчик<br>- загружает платформенные классы JDK из архива rt.jar<br><br>- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">AppClassLoader </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- системный загрузчик<br>- загружает классы приложения, определенные в CLASSPATH <br><br>- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Extension ClassLoader </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- загрузчик расширений <br>- загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Динамическая загрузка</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> происходит &quot;на лету&quot; </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">в ходе выполнения программы </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">с помощью статического метода </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">класса Class.forName</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">(имя класса). Для чего нужна динамическая загрузка? Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R80" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">81</div></th><td class="s17">Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?</td><td class="s4">-У конструктора по умолчанию отсутствуют какие-либо аргументы. <br>-Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона.<br>-Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).</td><td></td></tr><tr style="height: 20px"><th id="1989704007R81" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">82</div></th><td class="s17">Какие модификаторы доступа есть в Java? Какие применимы к классам?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Private </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">– </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">доступ </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">к компоненту только </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">из этого класса</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, в котором объявлен.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Default </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">– Переменная или метод будут доступны </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">для любого другого класса в том же пакете.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Protected </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">– Поля protected </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">доступны всем классам внутри пакета,</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> а также </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">всем классам-наследникам вне пакета</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Public </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">– доступ к компоненту из экземпляра </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">любого класса и любого пакета.<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Класс может быть объявлен с модификатором public и default.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R82" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">83</div></th><td class="s17">Что означает модификатор static?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Статическая </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">переменная </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- это переменная, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">принадлежащая классу</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, а не объекту. <br>А статический класс- это вложенный </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">класс</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, который </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">может обращаться только к статическим полям обертывающего его класса</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. <br>Внутри static </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">метода нельзя вызвать не статический метод по имени класса.<br></span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R83" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">84</div></th><td class="s17">Может ли статический метод быть переопределён или перегружен?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Нельзя переопределять статические методы. <br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса  вместо переопределения. Это явление известно как</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"> сокрытие методов</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> (hiding methods). <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Перегружен - да.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> Всё работает точно так же как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R84" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">85</div></th><td class="s17">Могут ли нестатические методы перегрузить статические?</td><td class="s4">Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.</td><td></td></tr><tr style="height: 20px"><th id="1989704007R85" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">86</div></th><td class="s17">Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">При переопределении метода </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">нельзя сузить модификатор доступа к методу </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">(например, с public до private), но можно расширить.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Изменить тип возвращаемого значения</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">нельзя</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, но </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">можно сузить </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">возвращаемое значение, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">если они совместимы</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. Например, если метод возвращает объект класса, а переопределенный метод возвращает класс-наследник.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R86" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">87</div></th><td class="s17">Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">В сигнатуре(имя + параметры) менять ничего нельзя.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Возможно расширение уровня доступа.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Изменять тип возвращаемого значения</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> при переопределении метода разрешено только </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">в сторону сужения типа</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> (вместо родительского класса - наследника).<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Секцию throws </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">метода можно не указывать, но стоит помнить, что </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">она остаётся действительной, если уже определена у метода родительского класса. </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R87" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">88</div></th><td class="s17">Могут ли классы быть статическими?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Класс можно объявить статическим за исключением классов верхнего уровня.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>Такие классы известны как «вложенные статические классы» (nested static class). </span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R88" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">89</div></th><td class="s17">Что означает модификатор final? К чему он может быть применим?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Для класса это означает, что </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">класс</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> не сможет </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">иметь подклассов</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, т.е. запрещено наследование. <br>Следует также отметить, что к </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">abstract-классам нельзя применить модификатор final</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, т.к. это взаимоисключающие понятия.<br>Для </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">переменных примитивного типа</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> это означает, что </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">однажды присвоенное значение не может быть изменено<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Для</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"> ссылочных переменных</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект. Важно: </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Ссылку изменить нельзя, но состояние объекта изменять можно.<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Т.к. массив – это объект, то final означает, что после присвоения ссылки на объект, уже нельзя ее изменить, но можно изменять состояние объекта.<br></span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R89" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">90</div></th><td class="s17">Что такое абстрактные классы? Чем они отличаются от обычных?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Абстрактным называется класс, на основе которого не могут создаваться объекты.<br>Как обычный класс, но </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">с абстрактными методами</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Нельзя создать </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">объект или </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">экземпляр абстрактного класса</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.<br><br>Наследниками абстрактного класса могут быть другие абстрактные классы</span></td><td></td></tr><tr style="height: 67px"><th id="1989704007R90" style="height: 67px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 67px">91</div></th><td class="s17">Может ли быть абстрактный класс без абстрактных методов?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Класс </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">может </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">быть абстрактным без единого абстрактного метода, если у него указан модификатор abstract.</span></td><td class="s21">Нет, в <span style="font-size:12pt;font-family:Arial;font-weight:bold;color:#333333;">абстрактном</span><span style="font-size:12pt;font-family:Arial;color:#333333;"> </span><span style="font-size:12pt;font-family:Arial;font-weight:bold;color:#333333;">классе</span><span style="font-size:12pt;font-family:Arial;color:#333333;"> может не </span><span style="font-size:12pt;font-family:Arial;font-weight:bold;color:#333333;">быть</span><span style="font-size:12pt;font-family:Arial;color:#333333;"> ни одного </span><span style="font-size:12pt;font-family:Arial;font-weight:bold;color:#333333;">абстрактного</span><span style="font-size:12pt;font-family:Arial;color:#333333;"> </span><span style="font-size:12pt;font-family:Arial;font-weight:bold;color:#333333;">метода</span><span style="font-size:12pt;font-family:Arial;color:#333333;">.</span></td></tr><tr style="height: 94px"><th id="1989704007R91" style="height: 94px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 94px">92</div></th><td class="s17">Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?</td><td class="s22"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Да. Необходимы для наследников.<br><br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">В абстрактном классе в Java можно объявить и определить конструкторы. Даже если вы не объявили никакого конструктора, компилятор добавит в абстрактный класс конструктор по умолчанию без аргументов. Абстрактные конструкторы будут часто использоваться для обеспечения ограничений класса или инвариантов, таких как минимальные поля, необходимые для настройки класса.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R92" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">93</div></th><td class="s17">Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Интерфейс </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">— это план класса или, можно сказать, набор абстрактных методов и статических констант. В интерфейсе каждый метод является открытым и абстрактным, но не содержит конструктора. Таким образом, интерфейс в основном представляет собой группу связанных методов с пустыми телами. Другими словами, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">интерфейс определяет как элементы будут взаимодействовать между собой</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. <br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- методы интерфейса </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">являются публичными (</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">public</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">) и абстрактными (</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">abstract</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">), <br>- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">поля </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">— </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">public static final</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. <br></span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R93" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">94</div></th><td class="s17">Чем интерфейсы отличаются от абстрактных классов? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?</td><td class="s13"><a target="_blank" href="https://javahelp.online/osnovy/voprosy-otvety-sobesedovanie-java">1.        Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (кроме public static final), в то время как у абстрактного класса они могут быть.<br>2.        Мы можем наследовать только один класс, а реализовать интерфейсов — сколько угодно. Интерфейс может наследовать (extends) другой интерфейс/интерфейсы.<br>3.        Абстрактные классы используются, когда есть отношение &quot;is-a&quot;, то есть класс-наследник расширяет базовый абстрактный класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом.<br>4.        Абстрактный класс может реализовывать методы; интерфейс может реализовывать статические методы начиная с 8й версии.<br><br><br>https://javahelp.online/osnovy/voprosy-otvety-sobesedovanie-java (Q5)</a></td><td></td></tr><tr style="height: 84px"><th id="1989704007R94" style="height: 84px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 84px">95</div></th><td class="s17">Может ли один интерфейс наследоваться от другого? От двух других?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Да</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, может. Используется ключевое слово </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">extends</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R95" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">96</div></th><td class="s17">Что такое дефолтные методы интерфейсов? Для чего они нужны?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">В </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">JDK 8 </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">была добавлена такая функциональность как </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">методы по умолчанию с модификатором default.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> И теперь интерфейсы могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод. Это </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">нужно для обратной совместимости</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. <br>(Если один или несколько методов добавляются к интерфейсу, все реализации также будут вынуждены их реализовывать. Методы интерфейса по умолчанию являются эффективным способом решения этой проблемы.) </span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R96" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">97</div></th><td class="s17">Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">класс, наследующий конфликтующие интерфейсы, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">должен явно через super определить</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, какой именно метод вызвать:<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">InterfaceB.super.method();</span></td><td class="s23"></td></tr><tr style="height: 20px"><th id="1989704007R97" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">98</div></th><td class="s17">Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?</td><td class="s22"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">1. Статические блоки</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> от первого до последнего предка(от предка до наследника)<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">2. Попарно динамической блок инициализации и конструктор</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> от первого до последнего предка</span></td><td class="s24"></td></tr><tr style="height: 20px"><th id="1989704007R98" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">99</div></th><td class="s17">Зачем нужны и какие бывают блоки инициализации?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Инициализация - это когда мы впервые задаем переменной какое-либо значение.<br>Существуют </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">статические </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">и </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">нестатические </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">блоки инициализации.<br><br></span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R99" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">100</div></th><td class="s17">Для чего в Java используются статические блоки инициализации?</td><td class="s4">Статические блоки инициализация используются <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">для выполнения кода</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">который должен выполняться </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">один раз </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">при инициализации класса загрузчиком классов</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, в момент предшествующий созданию объектов этого класса при помощи конструктора. Такой блок принадлежит только самому классу.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R100" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">101</div></th><td class="s17">Что произойдет, если в блоке инициализации возникнет исключительная ситуация?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Для нестатических </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">блоков инициализации, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">если выбрасывание исключения прописано явным образом, требуется</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, чтобы </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">объявления </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">этих исключений были перечислены</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"> в throws всех конструкторов класса</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Иначе </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">будет </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">ошибка компиляции</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. <br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Для статического </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">блока выбрасывание исключения в явном виде, приводит к </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">ошибке компиляции</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.</span></td><td></td></tr><tr style="height: 128px"><th id="1989704007R101" style="height: 128px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 128px">102</div></th><td class="s17">Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Если </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">возникшее исключение - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">наследник RuntimeException</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">:<br>-</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">для статических </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">блоков инициализации будет выброшено java.lang.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">ExceptionInInitializerError</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">;<br>-</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">для нестатических </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">будет проброшено </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">исключение</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">-</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">источник</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Если </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">возникшее исключение - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">наследник Error</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">то </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">в обоих случаях будет выброшено java.lang.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Error</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Если </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">исключение: java.lang.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">ThreadDeath </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- смерть потока. В этом случае никакое </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">исключение </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">выброшено </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">не будет</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R102" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">103</div></th><td class="s17">Что такое класс Object?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы<br><br>Все</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">классы являются наследниками </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">суперкласса </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Object</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. Это не нужно указывать явно. В результате объект </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Object может ссылаться на объект любого </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">другого </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">класса</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Рефлексия </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">(от позднелат. reflexio - обращение назад) - это </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">механизм исследования данных </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">о программе </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">во время её выполнения.</span></td><td></td></tr><tr style="height: 264px"><th id="1989704007R103" style="height: 264px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 264px">104</div></th><td class="s17">Какие методы есть у класса Object (перечислить все)? Что они делают?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- equals()</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - проверка на равенство двух обьектов<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- hashCode() </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- изначально случайно число int<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- toString()</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - представления данного объекта в виде строки.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- getClass()</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - получение типа данного обьекта<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- clone() -  </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">клонирует объект</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">методом.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"><br>- finalize() - </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">deprecated, вызывается GC перед удалением. (нет гарантии что будет вызван)<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">для многопоточки<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- notify()</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - «размораживает» одну случайную нить<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- notifyAll()</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - «размораживает» все нити данного монитора<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- wait()</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - нить освобождает монитор и «становится на паузу»<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- wait(long timeOut)</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- wait(long timeOut, int nanos)</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> - нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах, дополнительное время, в диапазоне наносекунд 0-999999.</span></td><td class="s25"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;">1</span><span style="font-size:10pt;font-family:Arial;"> Если два объекта равны (т.е. метод equals() возвращает true), у них должен быть одинаковый хэш-код. Иначе наши методы будут лишены смысла. Проверка по hashCode(), как мы и сказали, должна идти первой для повышения быстродействия. Если хэш-коды будут разными, проверка вернет false, хотя объекты на самом деле равны (согласно нашему определению в методе equals()). </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">2</span><span style="font-size:10pt;font-family:Arial;"> Если метод hashCode() вызывается несколько раз на одном и том же объекте, каждый раз он должен возвращать одно и то же число. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">3</span><span style="font-size:10pt;font-family:Arial;">  Правило 1 не работает в обратную сторону. Одинаковый хэш-код может быть у двух разных объектов.</span></td></tr><tr style="height: 20px"><th id="1989704007R104" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">105</div></th><td class="s17">Расскажите про equals и hashcode</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Хеш-код </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">— это </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">целочисленный результат </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">работы </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">метода</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">которому </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">в качестве входного параметра </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">передан объект.<br>Если более точно, то это битовая строка фиксированной длины, полученная из массива произвольной длины. <br><br>Equals </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">- это метод, определенный в Object, который служит для сравнения объектов. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">При</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">сравнении объектов при помощи == </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">идет </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">сравнение по ссылкам</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">При сравнении по equals</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">() идет </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">сравнение по состояниям </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">объектов. <br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Свойства equals</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">():<br>•        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Симметричность</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">: Для двух ссылок, a и b, a.equals(b) тогда и только тогда, когда b.equals(a)<br>•        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Рефлексивность</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">: для любого заданного значения x, выражение x.equals(x) <br>                                         должно возвращать true.<br>                                         Заданного — имеется в виду такого, что x != null</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"><br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">•        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Постоянство</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">: повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено.<br>•        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Транзитивность</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">: Если a.equals(b) и b.equals(c), то тогда a.equals(c)<br>•        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Совместимость с</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">hashCode</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">(): Два тождественно равных объекта должны иметь одно и то же значение hashCode()<br><br><br>При переопределении equals() обязательно нужно переопределить метод hashCode(). Равные объекты должны возвращать одинаковые хэш коды.<br></span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R105" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">106</div></th><td class="s17"></td><td class="s4"></td><td></td></tr><tr style="height: 382px"><th id="1989704007R106" style="height: 382px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 382px">107</div></th><td class="s17">Каким образом реализованы методы hashCode() и equals() в классе Object?</td><td class="s4">1 - Реализация метода Object.<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">equals</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">() сводится к </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">проверке на равенство двух ссылок</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">:<br><br>public boolean equals(Object obj) {<br>  return (this == obj);<br>}<br><br>2 - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">HashCode </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">реализован таким образом, что для одного и того же входного объекта, хеш-код всегда будет одинаковым.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>Реализация метода Object.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">hashCode</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">() описана как native, т.е. написана не на Java. Непереопределенный hashCode возвращает идентификационный хеш, основанный на состоянии потока, объединённого с xorshift (в OpenJDK8). А вообще, функция предлагает шесть методов на базе значения переменной hashCode.<br><br>0. Случайно сгенерированное число.<br>1. Функция адреса объекта в памяти.<br>2. Жёстко запрограммированное значение 1 (используется при тестировании на чувствительность (sensitivity testing)).<br>3. Последовательность.<br>4. Адрес объекта в памяти, приведённый к целочисленному значению.<br>5. Состояние потока, объединённое с xorshift (https://en.wikipedia.org/wiki/Xorshift)<br><br>public native int hashCode();<br><br>Ситуация, когда у разных объектов одинаковые хеш-коды называется — коллизией. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R107" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">108</div></th><td class="s17">Зачем нужен equals(). Чем он отличается от операции ==?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">equals</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">() -  сравнение </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">по состоянию</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">==</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> -  </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">по ссылкам</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R108" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">109</div></th><td class="s17">Правила переопределения equals()</td><td class="s4">1.        Проверить на равенство ссылки объектов this и параметра метода o.<br>if (this == o) return true;<br>2.        Проверить, определена ли ссылка o, т. е. является ли она null.<br>Если в дальнейшем при сравнении типов объектов будет использоваться оператор instanceof, этот пункт можно пропустить, т. к. этот параметр возвращает false в данном случае null instanceof Object.<br>3.        Сравнить типы объектов this и o с помощью оператора instanceof или метода getClass(), руководствуясь описанием выше и собственным чутьем.<br>4.        Если метод equals переопределяется в подклассе, не забудьте сделать вызов super.equals(o)<br>5.        Выполнить преобразование типа параметра <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">o </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">к требуемому классу.<br>6.        Выполнить сравнение всех значимых полей объектов:<br>o        для примитивных типов (кроме float и double), используя оператор ==<br>o        для ссылочных полей необходимо вызвать их метод equals<br>o        для массивов можно воспользоваться перебором по циклу, либо методом Arrays.equals()<br>o        для типов float и double необходимо использовать методы сравнения соответствующих оберточных классов Float.compare() и Double.compare()<br></span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R109" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">110</div></th><td class="s17">Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?</td><td class="s4">Нарушится контракт. Классы и методы, которые использовали правила этого контракта могут некорректно работать. Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.</td><td></td></tr><tr style="height: 20px"><th id="1989704007R110" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">111</div></th><td class="s17">Какой контракт между hashCode() и equals()?</td><td class="s4">1) Если два объекта возвращают разные значения hashcode(), то они не могут быть равны<br>2) Если equals объектов true, то и хэшкоды должны быть равны.  <br>3) Переопределив equals, всегда переопределять и hashcode.</td><td></td></tr><tr style="height: 20px"><th id="1989704007R111" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">112</div></th><td class="s17">Для чего нужен метод hashCode()?</td><td class="s4">вычисляет целочисленное значение для конкретного элемента класса, чтобы использовать его для быстрого поиска и доступа к этому элементу в hash-структурах данных, например, HashMap, HashSet и прочих.</td><td></td></tr><tr style="height: 20px"><th id="1989704007R112" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">113</div></th><td class="s17">- Правила переопределения метода hashcode().</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Если хеш-коды разные, то и входные объекты гарантированно разные.<br>Если хеш-коды равны, то входные объекты не всегда равны.<br>При вычислении хэш-кода следует использовать те же поля, которые сравниваются в equals и которые не вычисляются на основе других значений.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br><br>- вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.<br>- вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода equals для этих объектов возвращает true).<br>- вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R113" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">114</div></th><td class="s17">- Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?</td><td class="s4">Выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().<br></td><td class="s15"></td></tr><tr style="height: 20px"><th id="1989704007R114" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">115</div></th><td class="s17">Могут ли у разных объектов быть одинаковые hashCode()?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Когда у разных объектов одинаковые хеш-коды называется — </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">коллизией</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R115" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">116</div></th><td class="s17">Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?</td><td class="s4">В Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено.<br>Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть</td><td></td></tr><tr style="height: 20px"><th id="1989704007R116" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">117</div></th><td class="s17">Есть класс Point{int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?</td><td class="s4">Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию.</td><td class="s15">Это связано с тем, что число 31 имеет хорошее свойство — его умножение можно заменить побитовым сдвигом, который выполняется быстрее, чем стандартное умножение: 31 * i == (i &lt;&lt; 5) - i</td></tr><tr style="height: 20px"><th id="1989704007R117" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">118</div></th><td class="s17">Чем a.getClass().equals(A.class) отличается от a instanceOf A.class</td><td class="s4">getClass() получает только класс, а оператор instanceof проверяет является ли объект экземпляром класса или его потомком</td><td></td></tr><tr style="height: 20px"><th id="1989704007R118" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">119</div></th><td class="s0" colspan="2">Исключения</td><td></td></tr><tr style="height: 20px"><th id="1989704007R119" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">120</div></th><td class="s17">Что такое исключения?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Исключение — </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">это ошибка (является объектом),</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> возникающая во время выполнения программы. </span></td><td></td></tr><tr style="height: 300px"><th id="1989704007R120" style="height: 300px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 300px">121</div></th><td class="s17">Опишите иерархию исключений.</td><td class="s4">1. класс <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Throwable </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">(checked)<br><br>2. от </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Throwable  -&gt;</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Error </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">(</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">ошибки JVM</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">) и </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Exception </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">(</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">checked </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">общие)<br><br>3. от </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Exception <br>    - &gt; RuntimeException (unchecked)<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">    </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- &gt; IOException, SQLException, ReflectiveOperationException (checked)<br><br>4.RuntimeException (unchecked):<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">  ClassCastExceptiuon<br>  IndexOutOfBoundException<br>  AritthmeticException<br>  NullPointerException<br><br><br></span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R121" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">122</div></th><td class="s17">Расскажите про обрабатываемые и необрабатываемые исключения</td><td class="s4">1. Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.<br>2. Unchecked исключения в Java — наследованные от RuntimeException, checked — от Exception.<br>Checked исключения отличаются от Unchecked исключения в Java, тем что<br><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">наличие\обработка Checked исключения проверяются компилятором на этапе компиляции.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Наличие\обработка Unchecked исключения происходит на этапе выполнения</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.<br></span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R122" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">123</div></th><td class="s17">Можно ли обработать необрабатываемые исключения?</td><td class="s4">Можно, чтобы в некотрых случаях программа не прекратила работу</td><td></td></tr><tr style="height: 20px"><th id="1989704007R123" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">124</div></th><td class="s17">Какой оператор позволяет принудительно выбросить исключение?</td><td class="s4">Throw</td><td></td></tr><tr style="height: 20px"><th id="1989704007R124" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">125</div></th><td class="s17">О чем говорит ключевое слово throws?</td><td class="s4">Метод потенциально может выбросить исключение с указанным типом. <br>Передаёт обработку исключения вышестоящему методу.</td><td></td></tr><tr style="height: 20px"><th id="1989704007R125" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">126</div></th><td class="s17">Как создать собственное («пользовательское») исключение?</td><td class="s4">Необходимо унаследоваться от базового класса требуемого типа исключений (например, от Exception или RuntimeException).<br>и переопределит методы</td><td></td></tr><tr style="height: 20px"><th id="1989704007R126" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">127</div></th><td class="s17">Расскажите про механизм обработки исключений в java (Try-catch-finally)</td><td class="s7">Try - блок в котором может появиться исключение;<br>Catch - блок в котором мы указываем исключение и логику его обработки;<br>Finally - блок который обязательно отработает</td><td></td></tr><tr style="height: 20px"><th id="1989704007R127" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">128</div></th><td class="s17">Возможно ли использование блока try-finally (без catch)?</td><td class="s4">try может быть в паре с finally, без catch. Работает это точно так же - после выхода из блока try выполняется блок finally</td><td></td></tr><tr style="height: 20px"><th id="1989704007R128" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">129</div></th><td class="s17">Может ли один блок catch отлавливать сразу несколько исключений?</td><td class="s7">Да</td><td></td></tr><tr style="height: 20px"><th id="1989704007R129" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">130</div></th><td class="s17">Всегда ли выполняется блок finally? Существуют ли ситуации, когда блок finally не будет выполнен?</td><td class="s4">Да, кроме случаев завершения работы программы или JVM:<br><br>1 - Finally может не выполниться в случае если в блоке try вызывает System.exit(0), <br>2 - Runtime.getRuntime().exit(0), Runtime.getRuntime().halt(0) и если во время исполнения блока try виртуальная машина выполнила недопустимую операцию и будет закрыта. <br>3 - В блоке try{} бесконечный цикл.</td><td></td></tr><tr style="height: 20px"><th id="1989704007R130" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">131</div></th><td class="s17">Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?</td><td class="s4">Может и оно будет передано в виртуальную машину Java (JVM).<br>Для случая с методом main произойдет две вещи:<br><br>- будет завершен главный поток приложения;<br>- будет вызван ThreadGroup.uncaughtException.</td><td></td></tr><tr style="height: 20px"><th id="1989704007R131" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">132</div></th><td class="s17">В каком порядке следует обрабатывать исключения в catch блоках?</td><td class="s7">От наследника к предку</td><td></td></tr><tr style="height: 161px"><th id="1989704007R132" style="height: 161px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 161px">133</div></th><td class="s17">Что такое механизм try-with-resources?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Дает </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">возможность объявлять </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">один или </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">несколько ресурсов в блоке try,</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">которые будут закрыты автоматически </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">без использования finally блока.<br>В </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">качестве ресурса </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">можно использовать любой </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">объект</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, класс </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">которого реализует </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">интерфейс java.lang.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">AutoCloseable или </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">java.io.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Closeable</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Closeable extends AutoCloseable</span></td><td class="s15"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">До Java 7 уже существовал похожий интерфейс – Closeable(добавлен в java 5). Смысл его точно такой же. Он всё еще доступен в стандартной библиотеке для обратной совместимости</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, но в новом коде рекомендуется использовать AutoCloseable. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Чтобы экземпляры старого Closeable тоже можно было использовать в try-with-resource, новый интерфейс был добавлен его родителем.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> Проблема старого интерфейса Closeable была в узости типа исключений, которые может выбрасывать close(). Ковариантность позволила расширить тип в базовом интерфейсе</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"> AutoCloseable с IOException до Exception.</span></td></tr><tr style="height: 20px"><th id="1989704007R133" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">134</div></th><td class="s17">Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">finally</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">-секция </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">может </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">«</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">перебить</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">» </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">throw</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">/</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">return при помощи </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">другого </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">throw</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">/</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">return</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R134" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">135</div></th><td class="s26">Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with-resources?</td><td class="s16"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">В </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">try-with-resources</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> добавленна возможность хранения &quot;подавленных&quot; исключений, и брошенное try-блоком исключение </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">имеет больший приоритет</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">чем исключения </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">получившиеся </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">во время закрытия</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R135" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">136</div></th><td class="s0" colspan="2">Сериализация и копирование</td><td></td></tr><tr style="height: 20px"><th id="1989704007R136" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">137</div></th><td class="s17">Что такое сериализация и как она реализована в Java?</td><td class="s4">Сериализация это процесс сохранения состояния объекта в последовательность байт;  <br><br>Реализована через интерфейс - маркер Serializable. </td><td></td></tr><tr style="height: 20px"><th id="1989704007R137" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">138</div></th><td class="s17">Для чего нужна сериализация?</td><td class="s4">Для компактного сохранения состояния объекта и считывание этого состояния.</td><td></td></tr><tr style="height: 101px"><th id="1989704007R138" style="height: 101px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 101px">139</div></th><td class="s17">Опишите процесс сериализации/десериализации с использованием Serializable.</td><td class="s4">1) Класс объекта должен реализовывать интерфейс Serializable<br>2) Создать поток ObjectOutputStream (oos), который записывает объект в переданный OutputStream.<br>3) Записать в поток: oos.writeObject(Object);<br>4) Сделать oos.flush() и oos.close()</td><td></td></tr><tr style="height: 20px"><th id="1989704007R139" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">140</div></th><td class="s17">Как изменить стандартное поведение сериализации/десериализации?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Использовать интерфейс </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Externalizable. <br><br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Переопределить методы<br> writeExternal(ObjectOutput out) throws IOException<br> readExternal(ObjectInput in) throws IOException, ClassNotFoundException</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R140" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">141</div></th><td class="s17">Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">1) Добавить к полю модификатор </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">transient</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. В таком случае после восстановления его значение будет null.<br><br>2) Сделать поле </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">static</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. Значения статических полей автоматически не сохраняются. <br><br>3) Поля с модификатором </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">final </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">сериализуются </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">как </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">и </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">обычные</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">За </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">одним </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">исключением </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">– их </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">невозможно десериализовать при </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">использовании </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Externalizable</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, поскольку final-поля должны быть инициализированы в конструкторе, а после этого в readExternal изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект с final-полем неоходимо использовать только стандартную сериализацию.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R141" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">142</div></th><td class="s17">Как создать собственный протокол сериализации?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Для создания собственного протокола нужно просто </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">переопределить writeExternal</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">() и </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">readExternal</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">(). <br><br>В отличие от двух других вариантов сериализации, здесь ничего не делается автоматически. Протокол полностью в ваших руках. </span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R142" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">143</div></th><td class="s17">Какая роль поля serialVersionUID в сериализации?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Поле private static final long serialVersionUID содержит </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">уникальный идентификатор </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">версии сериализованного класса. Оно вычисляется по содержимому класса - полям, их порядку объявления, методам, их порядку объявления. Соответственно, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">при</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">любом изменении </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">в классе </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">это поле поменяет </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">свое </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">значение</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.<br>Если мы не объявляем его явно, Java делает это за нас.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R143" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">144</div></th><td class="s17">Когда стоит изменять значение поля serialVersionUID?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Вы должны изменить serialVersionUID только тогда, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">когда </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">вы </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">сознательно хотите нарушить совместимость со </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">всеми </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">существующими сериализациями </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, например, когда изменения в вашем классе сделают его настолько семантически отличным, что у вас не будет выбора - в этом случае вы действительно должны несколько раз подумать о том, что вы на самом деле делаете.</span></td><td></td></tr><tr style="height: 194px"><th id="1989704007R144" style="height: 194px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 194px">145</div></th><td class="s17">В чем проблема сериализации Singleton?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- Проблема  -<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">в том что </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">после десериализации </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">мы </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">получим другой объект</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">. <br><br>Таким образом, сериализация дает возможность создать Singleton еще раз, что не совсем нужно. <br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- Решение  -<br>В классе</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">определяется метод с сигнатурой <br>&quot;Object readResolve() throws ObjectStreamException&quot;</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">- Назначение  -<br></span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">этого метода - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">возвращать замещающий объект вместо объекта</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">на котором </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">он </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">вызван</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R145" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">146</div></th><td class="s17">Расскажите про клонирование объектов.</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">в Java, есть 3 способа клонирования объекта:<br><br>1. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">С использованием</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> интерфейса </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Cloneable</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">;<br>Первый способ подразумевает, что вы будете использовать механизм так называемого «поверхностного клонирования» и сами позаботитесь о клонировании полей-объектов. Метод clone() в родительском классе Object является protected, поэтому требуется переопределение его с объявлением как public. Он возвращает экземпляр объекта с копированными полями-примитивами и ссылками. И получается что у оригинала и его клона поля-ссылки указывают на одни и те же объекты. <br><br>2. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">С использованием</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">конструктора </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">клонирования </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">объекта</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">;<br>В классе описывается конструктор, который принимает объект этого же класса и инициализирует значениями его полей поля нового объекта.<br><br>3. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">С использованием сериализации.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>Он заключается в сохранении объекта в поток байтов с последующей эксгумацией его от туда.</span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R146" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">147</div></th><td class="s17">В чем отличие между поверхностным и глубоким клонированием?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Поверхностное копирование</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">копирует настолько малую часть информации, насколько это возможно. По умолчанию</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">клонирование </span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">в Java </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">является поверхностным</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, т.е. Object class не знает о структуре класса, которого он копирует. <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">Глубокое копирование дублирует все.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> Глубокое копирование — это</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;"> две коллекции</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;">, в </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">одну</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> из которых </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">дублируются все элементы оригинальной коллекции.</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> </span></td><td></td></tr><tr style="height: 20px"><th id="1989704007R147" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">148</div></th><td class="s17">Какой способ клонирования предпочтительней?</td><td class="s4">Наиболее безопасным и следовательно предпочтительным способом клонирования является использование специализированного конструктора копирования:<br>Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод clone());<br>Поля для клонирования указываются явно;<br>Возможность клонировать даже final поля.<br></td><td></td></tr><tr style="height: 20px"><th id="1989704007R148" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">149</div></th><td class="s17">Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?</td><td class="s4">Метод clone() объявлен в классе Object с сигнатурой <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">native,</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> чтобы обеспечить </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">доступ к стандартному механизму &quot;поверхностного копирования&quot; объектов</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> (копируются значения всех полей, включая ссылки на сторонние объекты); он объявлен, как protected, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. </span></td><td></td></tr><tr style="height: 213px"><th id="1989704007R149" style="height: 213px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 213px">150</div></th><td class="s17">Как создать глубокую копию объекта? (2 способа)</td><td class="s4"><span style="font-size:10pt;font-family:Arial;color:#3e5656;">Глубокое клонирование требует выполнения следующих правил: <br>-Нет необходимости копировать отдельно примитивные данные;<br>-Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться super.clone() при переопределении метода clone();<br>-Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">1 Сериализация</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"> – это еще один способ глубокого копирования. Мы просто сериализуем нужный объект и десериализуем его. Очевидно, объект должен поддерживать интерфейс Serializable. Мы сохраняет объект в массив байт и потом прочитать из него.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#3e5656;">2 При помощи библиотеки DeepCloneable</span><span style="font-size:10pt;font-family:Arial;color:#3e5656;"><br>Глубокое клонирование с этой библиотекой сводится с двум строкам кода:<br>Cloner cloner = new Cloner();<br>DeepCloneable clone = cloner.deepClone(this);</span></td><td></td></tr></tbody></table></div><div id='embed_1943075090' class='waffle-embedded-object-overlay' style='width: 396px; height: 79px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17FiRcPLGdpCS846VLOS4ajj3aBPZ_fQYNs9JQ6BtCW11bX1IrpfaC-nTJP9XhzkWUaUFnnJYJi0SbqF6WKxJ0j-TDRiwksFKAexcs7MjXp8I99dhqTxVDVD9EU27yMikTFsJEXEhsoWrbAiii05drHinXAxZ73-H4a9zhvu?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='79' width='396'></div><div id='embed_1510778156' class='waffle-embedded-object-overlay' style='width: 541px; height: 54px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17ETy7Q0lliSbHIkz6AdbxOlKXfo9KqIHlsWN6-DMoYcb9fETjgUXLY2adpsqe17jBYLV9HzbXZov0YG4IV8rzAiXkS4aUXnN32NmfK7IKzgkzyvaDFIHygvaYDa6QcqPh1KnPAn24i_Cd5IZkyb5izBQ3W7nU_P1KpBv4S2Gg?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='54' width='541'></div><div id='embed_147637350' class='waffle-embedded-object-overlay' style='width: 533px; height: 75px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17FW3oAmsCZgpHlr89U9R0tjauuzWwPb8G0M71-cTZ6PGYBW4VMF0IiCpmEGL_XRI9IJ7b-kuBx40CetMtoIJBaHJCAEDw70y8LMZQqDX3kTd57CptpIX_VRgYFD4k4ZXl0ltwEo2uZjq3uymNkxcbQ-1UiMn-Fs8NaZuT3G8g?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='75' width='533'></div><div id='embed_1611536805' class='waffle-embedded-object-overlay' style='width: 520px; height: 72px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17GUrfeIH3i5d1icipBpkx37mFIK25m_ytjmtkXaNi_OC5PbC_Mof5mdJrq7rgBNvKQVMmvmma6qEwfAtKSqR34lNDaAkt_2Gm6EiPVfF-XITySN3YNzLZTgWQBoZmXy5rvYzCY4cNzoyRkbNpoldRLI2ywZNmlmQzV5sGBGYw?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='72' width='520'></div><div id='embed_360508485' class='waffle-embedded-object-overlay' style='width: 904px; height: 366px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17H9fFPhzR0MLp0vrz9gG_EsidEmxqr1i7ooC-dmOHt2iZ7hj1y6vHEpGDuQlvvBub-OQKqpzCyk1yoZYgb3d1JZlnL7fEd9EZrbhUma7nNGZen0odl9IQtO5x7iH-_TczByVHawUKZv-bqzhqVQdb9hu8d3togCQzyz3wCn?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='366' width='904'></div><div id='embed_1391620718' class='waffle-embedded-object-overlay' style='width: 447px; height: 219px; display: block;'><img src='https://lh7-rt.googleusercontent.com/sheetsz/AHOq17EOGz1U6rBK2Y3Bscby4tHeJuvIv4-kGYG9GgrqZn2FiDpj20Jc3cfO3RxOc979yjB_tYQ6giJODwXjzN7rNzKUi0yK4uMGQwC-K7zGdWoaGs2S0t5kmXyJ0ywNJDE_ADLe7E_BhzfpNO7sqSrQX5uX1eM6-1HDJ9P7xnEumA?key=hmZU6X5bC09eoSadsn6fkQ' style='display: block;' height='219' width='447'></div><script>
  function posObj(sheet, id, row, col, x, y) {
      var rtl = false;
      var sheetElement = document.getElementById(sheet);
      if (!sheetElement) {
        sheetElement = document.getElementById(sheet + '-grid-container');
      }
      if (sheetElement) {
        rtl = sheetElement.getAttribute('dir') == 'rtl';
      }
      var r = document.getElementById(sheet+'R'+row);
      var c = document.getElementById(sheet+'C'+col);
      if (r && c) {
        var objElement = document.getElementById(id);
        var s = objElement.style;
        var t = y;
        while (r && r != sheetElement) {
          t += r.offsetTop;
          r = r.offsetParent;
      }
      var offsetX = x;
      while (c && c != sheetElement) {
        offsetX += c.offsetLeft;
        c = c.offsetParent;
      }
      if (rtl) {
        offsetX -= objElement.offsetWidth;
      }
      s.left = offsetX + 'px';
      s.top = t + 'px';
      s.display = 'block';
      s.border = '1px solid #000000';
    }
  }

  function posObjs() {
  posObj('1989704007', 'embed_1943075090', 35, 1, 11, 1478);posObj('1989704007', 'embed_1510778156', 42, 2, 6, 44);posObj('1989704007', 'embed_147637350', 45, 2, 5, 41);posObj('1989704007', 'embed_1611536805', 46, 2, 4, 41);posObj('1989704007', 'embed_360508485', 117, 1, 624, 30);posObj('1989704007', 'embed_1391620718', 48, 2, 0, 0);}posObjs();</script>