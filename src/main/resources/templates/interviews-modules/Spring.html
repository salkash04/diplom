<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="../../../../../../../../Users/Салават/Downloads/Spring/resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s1{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s6{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s4{border-right:none;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s3{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s5{border-left:none;border-right:none;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s7{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s16{border-bottom:1px SOLID transparent;border-right:1px SOLID transparent;background-color:#ffff00;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s0{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#3d85c6;text-align:left;font-weight:bold;color:#ffffff;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s18{background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s9{border-left:none;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s17{background-color:#ffffff;text-align:left;color:#111111;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s14{border-bottom:1px SOLID transparent;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s11{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s2{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#c9daf8;text-align:left;font-weight:bold;color:#1c4587;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s12{background-color:#ffffff;text-align:left;color:#ff0000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s15{border-right:1px SOLID transparent;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s8{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s20{background-color:#ffffff;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s21{background-color:#ffffff;text-align:left;color:#111111;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s10{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s13{background-color:#ffffff;text-align:left;font-weight:bold;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#8b8948;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s19{background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-origin-ltr"></th><th id="0C0" style="width:159px;" class="column-headers-background">A</th><th id="0C1" style="width:841px;" class="column-headers-background">B</th><th id="0C2" style="width:459px;" class="column-headers-background">C</th><th id="0C3" style="width:100px;" class="column-headers-background">D</th></tr></thead><tbody><tr style="height: 20px"><th id="0R0" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">1</div></th><td class="s0" colspan="2"> </td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R1" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">2</div></th><td class="s2">Что такое инверсия контроля (IoC) и внедрение зависимостей (DI)? Как эти принципы реализованы в Spring?</td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Inversion of Control</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">это принцип ООП или набор рекомендаций в разработке программы, при котором управление объектами или частями программы передается контейнеру или фреймворку.(с помощью рефлексии)</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">.</span><span style="font-size:10pt;font-family:Arial;"> Вместо ручного внедрения зависимостей, фреймворк забирает ответственность за это посредством IoC-контейнера.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Задача - уменьшить связываемость между классами.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Dependency Injection</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">является одним из способов реализации принципа IoC в Spring</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Это шаблон проектирования, в котором контейнер передает экземпляры объектов по их типу другим объектам с помощью конструктора или метода класса(setter), что позволяет писать слабосвязный код. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">                                             </span><span style="font-size:10pt;font-family:Arial;">(Конфигурации для внедрения - scope,factory method, Можно внедрить через XML или аннотации JAVA, процесс внедрения можно автоматизировать Autowiring)</span></td><td class="s4 softmerge"><div class="softmerge-inner" style="width:657px;left:-1px">В Spring Framework инверсия контроля и внедрение зависимостей считаются одним и тем же.</div></td><td class="s5"></td></tr><tr style="height: 20px"><th id="0R2" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">3</div></th><td class="s2">Что такое IoC контейнер?</td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">В среде Spring IoC-контейнер представлен интерфейсом ApplicationContext, который является оберткой над BeanFactory,</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> предоставляющей дополнительные возможности, например AOP и транзакции. Интерфейс BeanFactory предоставляет фабрику для бинов, которая в то же время и является IoC-контейнером приложения. Управление бинами основано на конфигурации(аннотации или xml). Контейнер создает бъекты на основе конфигураций и управляет их жизненным циклом от создания объекта до уничтожения.&quot;                                                                                                                                                                                                                               </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">IoC Контейнер</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">это приложение, которое отвечает за управление жизненным циклом объекта:</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой.Объекты, создаваемые контейнером, называются beans.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Конфигурирование контейнера осуществляется путём внедрения аннотаций, но также, есть возможность, по старинке, загрузить XML-файлы, содержащие определение bean’ов и предоставляющие информацию, необходимую для создания bean’ов.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R3" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">4</div></th><td class="s2" rowspan="2">Расскажите про ApplicationContext и BeanFactory, чем отличаются? В каких случаях что стоит использовать?</td><td class="s6"></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R4" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">5</div></th><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ApplicationContext </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">является наследником BeanFactory и полностью реализует его функционал, добавляя больше специфических enterprise-функций. Может работать с бинами всех скоупов.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">BeanFactory </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">это фактический контейнер,</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> который создает, настраивает и управляет рядом bean-компонентов. Эти</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> бины обычно взаимодействуют друг с другом и, таким образом, имеют зависимости между собой. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Эти зависимости отражены в данных конфигурации, используемых BeanFactory. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Может работать с бинами singleton и prototype.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">BeanFactory обычно используется тогда, когда ресурсы ограничены</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> (мобильные устройства), так как он легче по сравнению с ApplicationContext. Поэтому, если ресурсы не сильно ограничены, то лучше использовать ApplicationContext.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ApplicationContext загружает все бины при запуске, а BeanFactory по требованию. </span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R5" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">6</div></th><td class="s2">Расскажите про аннотацию @Bean?</td><td class="s7"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Аннотация @Bean используется для указания того, что метод создает, настраивает и инициализирует новый объект, управляемый IoC-контейнером.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Такие методы можно использовать как в классах с аннотацией @Configuration, так и в классах с аннотацией @Component(или её наследниках).<br>Имеет следующие свойства:<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">destroyMethod, initMethod</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — варианты переопределения методов удаления и инициализации бина, указав их имена в аннотации.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">name</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — имя бина. По умолчанию именем бина является имя метода.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">value</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — алиас для name()</span></td><td class="s8">Bean id в аннотации @Bean будет имя метода.                                                                                             <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Область видимости бинов:                                                                                                                            Singleton</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Область видимости по умолчанию. В контейнере находится всего 1 экземпляр бина<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Prototype</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>В контейнере может находится любое количество экземпляров бина</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R6" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">7</div></th><td class="s2">Расскажите про аннотацию @Component?</td><td class="s3">Аннотация <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Component</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - помечаем ей класс чтобы Spring Framework создал бин из этого класса.Именно эту аннотацию ищет Spring.F когда сканирует наши классы. @Component имеет наследников: @Repository, @Service и @Controller, их также называют стереотипными аннотациями</span></td><td class="s4 softmerge"><div class="softmerge-inner" style="width:557px;left:-1px">Предпочтительно для сканирования компонентов и автоматического подключения</div></td><td class="s9"></td></tr><tr style="height: 20px"><th id="0R7" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">8</div></th><td class="s2">Чем отличаются аннотации @Bean и @Component?</td><td class="s3">Аннотация <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Component </span><span style="font-size:10pt;font-family:Arial;color:#000000;">(как и @Service и @Repository) используется для автоматического обнаружения и автоматической настройки бинов в ходе сканирования путей к классам. Аннотация </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Bean</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> используется для явного объявления бина, а не для того, чтобы Spring делал это автоматически в ходе сканирования путей к классам</span></td><td class="s10">Аннотация @Bean возвращает объект. Когда мы хотим связать компоненты из сторонних библиотек (нет исходного кода, поэтому мы не можем аннотировать его классы с помощью @Component), поэтому автоматическая настройка невозможна.<br>Аннотация @Component - Spring 2.5, избавиться от XML Bean definition. @Bean - Spring 3.0</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R8" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">9</div></th><td class="s2">Расскажите про аннотации @Service и @Repository. Чем они отличаются?</td><td class="s3"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Repository</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - указывает, что класс используется для работы с поиском, получением и хранением данных. Аннотация может использоваться для реализации шаблона DАО.<br> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Service</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - указывает, что класс является сервисом для реализации бизнес-логики.<br><br>Задача @Repository заключается в том, чтобы </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">отлавливать определенные исключения персистентности и пробрасывать их как одно непроверенное исключение Spring Framework.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Для этого в контекст должен быть добавлен класс PersistenceExceptionTranslationPostProcessor.</span></td><td class="s10">Jpa и CRUD</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R9" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">10</div></th><td class="s2">Расскажите про аннотацию @Autowired</td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> @Autowired</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> – автоматическое внедрение подходящего бина(конструктор, поле, сеттер-метод или<br>метод конфигурации):<br>1) Контейнер определяет тип объекта для внедрения<br>2) Контейнер ищет соответствующий тип бина в контексте(он же контейнер)<br>3) Если есть несколько кандидатов, и один из них помечен как @Primary, то внедряется он<br>4) Если используется @Qualifier, то контейнер будет использовать информацию из @Qualifier, чтобы понять, какой компонент внедрять<br>5) В противном случае контейнер внедрит бин, основываясь на его имени или ID<br>6) Если ни один из способов не сработал, то будет выброшено исключение<br>Контейнер обрабатывает DI с помощью AutowiredAnnotationBeanPostProcessor. В связи с этим, аннотация не может быть использована ни в одном BeanFactoryPP или BeanPP.<br>В аннотации есть один параметр </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">required = true/false - указывает, обязательно ли делать DI. По умолчанию true. Либо можно не выбрасывать исключение, а оставить поле c null, если нужный бин не был найден - false.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>При циклической зависимости, когда объекты ссылаются друг на друга, нельзя ставить над конструктором.<br>    </span><span style="font-size:10pt;font-family:Arial;">Однако при внедрении прямо в поля вы не предоставляете прямого способа создания экземпляра класса со всеми необходимыми зависимостями. Это означает, что</span><span style="font-size:10pt;font-family:Arial;color:#000000;">:<br>    Существует способ (путем вызова конструктора по-умолчанию) создать объект с использованием new в состоянии, когда ему не хватает некоторых из его обязательных зависимостей, и использование приведет к NullPointerException<br>    Такой класс не может быть использован вне DI-контейнеров (тесты, другие модули) и нет способа кроме рефлексии предоставить ему необходимые зависимости<br>    Неизменность<br>В отличие от способа с использованием конструктора, внедрение через поля не может использоваться для присвоения зависимостей final-полям, что приводит к тому, что ваши объекты становятся изменяемыми</span></td><td class="s8">Аннотация @Autowired является альтернативой Java-аннотации @Inject, не имеющей required = false (зависимость должна быть обязательно внедрена). Начиная со Spring Framework 4.3, аннотация @Autowired для конструктора больше не требуется, если целевой компонент определяет только один конструктор. Однако, если доступно несколько конструкторов и нет основного/стандартного конструктора, по крайней мере один из конструкторов должен быть аннотирован @Autowired, чтобы указать контейнеру, какой из них использовать.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R10" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">11</div></th><td class="s2">Расскажите про аннотацию @Resource</td><td class="s3">Аннотация <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Resource</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> пытается получить зависимость: по имени, по типу, затем по описанию (Qualifier). Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name.<br><br>    </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Resource //По умолчанию поиск бина с именем &quot;context&quot;</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>    private ApplicationContext context;<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">    @Resource</span><span style="font-size:10pt;font-family:Arial;color:#000000;">(</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">name=&quot;greetingService&quot;</span><span style="font-size:10pt;font-family:Arial;color:#000000;">)</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> //Поиск бина с именем &quot;greetingService&quot;<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;">    public void setGreetingService(GreetingService service) {<br>        this.greetingService = service;<br>    }<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Разница с @Autowired:</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>❖        ищет бин сначала по имени, а потом по типу;<br>❖        не нужна дополнительная аннотация для указания имени конкретного бина;<br>❖        @Autowired позволяет отметить место вставки бина как<br>необязательное @Autowired(required = false);<br>❖        при замене Spring Framework на другой фреймворк, менять аннотацию @Resource не нужно.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R11" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">12</div></th><td class="s2">Расскажите про аннотацию @Inject</td><td class="s3">Аннотация @Inject входит в пакет javax.inject и, чтобы её использовать, нужно добавить зависимость:<br>&lt;dependency&gt;<br>   &lt;groupId&gt;javax.inject&lt;/groupId&gt;<br>   &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;<br>   &lt;version&gt;1&lt;/version&gt;<br>&lt;/dependency&gt;<br><br>@Inject (аннотация java) аналог @Autowired (аннотация spring) в первую очередь пытается подключить зависимость по типу, затем по описанию и только потом по имени. В ней нет параметров. Поэтому при использовании конкретного имени (Id) бина используем @Named:<br><br>@Inject<br>@Named(&quot;yetAnotherFieldInjectDependency&quot;)<br>private ArbitraryDependency yetAnotherFieldInjectDependency;</td><td class="s10">Аннотация @Inject является частью стандарта Java CDI (внедрение контекстов и зависимостей),<br>представленного в Java EE 6 (JSR-299). Spring решила поддерживать использование<br>аннотации @Inject как синоним своей собственной аннотации @Autowired.<br>В приложении Spring две аннотации работают так же. Spring решила поддерживать некоторые аннотации JSR-299 в дополнение к своим собственным.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R12" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">13</div></th><td class="s2">Расскажите про аннотацию @Lookup</td><td class="s3">Обычно бины в приложении Spring являтся синглтонами, и для внедрения зависимостей мы используем конструктор или сеттер.<br>Но <span style="font-size:10pt;font-family:Arial;color:#ff0000;">бывает и другая ситуация</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">имеется бин Car – синглтон (singleton bean), и ему требуется каждый раз</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">новый экземпляр бина Passenger</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. То есть Car – синглтон, а </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Passenger – так называемый прототипный бин (prototype bean).</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Жизненные циклы бинов разные. Бин</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> Car создается контейнером только раз, а бин Passenger создается каждый раз новый – допустим, это происходит каждый раз при вызове какого-то метода бина Car. Вот здесь то и пригодится внедрение бина с помощью Lookup метода. Оно происходит не при инициализации контейнера, а позднее: каждый раз, когда вызывается метод.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Суть в том, что вы создаете метод-заглушку в бине Car и помечаете его специальным образом – аннотацией @Lookup</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Этот метод должен возвращать бин Passenger, каждый раз новый. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Контейнер Spring под капотом создаст прокси-подкласс и переопределит этот метод и будет нам выдавать новый экземпляр бина Passenger при каждом вызове аннотированного метода</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">. Даже если в нашей заглушке он возвращает null (а так и надо делать - всё равно этот метод будет переопределен в прокси-подклассе)</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R13" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">14</div></th><td class="s2">Можно ли вставить бин в статическое поле? Почему?</td><td class="s3">Spring не позволяет внедрять бины напрямую в статические поля. Это связано с тем, что<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> когда загрузчик классов загружает статические значения, контекст Spring ещё не загружен</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Чтобы исправить это, создайте нестатический сеттер-метод с @Autowired:<br><br>   private static OrderItemService orderItemService;<br><br>   @Autowired<br>   public void setOrderItemService(OrderItemService orderItemService) {<br>       TestDataInit.orderItemService = orderItemService;<br>   }</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R14" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">15</div></th><td class="s2" rowspan="3">Расскажите про аннотации @Primary и @Qualifier</td><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Qualifier</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> применяется если кандидатов для автоматического связывания несколько, она позволяет указать в качестве аргумента имя конкретного бина, который следует внедрить. Она может быть применена к отдельному полю класса, к отдельному аргументу метода или конструктора:</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R15" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">16</div></th><td class="s10">public class AutowiredClass {<br><br>    @Autowired //к полям класса<br>    @Qualifier(&quot;main&quot;)<br>    private GreetingService greetingService;<br><br>    @Autowired //к отдельному аргументу конструктора или метода<br>    public void prepare(@Qualifier(&quot;main&quot;) GreetingService greetingService){<br>        /* что-то делаем... */<br>    };<br>}<br>Соответственно, у одной из реализации GreetingService должна быть установлена соответствующая аннотация @Qualifier:<br>@Component<br>@Qualifier(&quot;main&quot;)<br>public class GreetingServiceImpl implements GreetingService {<br>    //...<br>}</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R16" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">17</div></th><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Primary</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> тоже используется, чтобы отдавать предпочтение бину, когда есть несколько бинов одного типа, но в ней нельзя задать имя бина, она определяет значение по умолчанию, в то время как @Qualifier более специфичен.<br>Если присутствуют аннотации @Qualifier и @Primary, то аннотация </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Qualifier будет иметь приоритет</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. </span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R17" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">18</div></th><td class="s2">Как заинжектить примитив?</td><td class="s3">Для этого можно использовать аннотацию <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Value. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Можно ставить над полем, конструктором, методом.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;color:#000000;">Такие значения можно получать из property файлов, из бинов, и т.п.<br><br>@Value(&quot;${some.key}&quot;)<br>public String stringWithDefaultValue;<br><br>В эту переменную будет внедрена строка, например из property или из view.<br>Кроме того, для внедрения значений мы можем использовать язык SpEL (Spring Expression Language)</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R18" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">19</div></th><td class="s2">Как заинжектить коллекцию?</td><td class="s3">Если внедряемый объект массив, коллекция, или map с дженериком, то используя аннотацию @Autowired, Spring внедрит все бины подходящие по типу в этот массив(или другую структуру данных). <span style="font-size:10pt;font-family:Arial;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#000000;">В случае с map значениями будут сами бины, а ключами будут имена бинов:</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Используя аннотацию @Qualifier можно настроить тип искомого бина.(Мы использовали параметр &#39;name&#39; у аннотации @Bean, чтобы указать конкретный классификатор для бина. Но элемент &#39;name&#39;, на самом деле, является не столько именем, сколько идентификатором бина, который должен быть уникальным, потому что все бины хранятся в контейнере в Map. В случае с коллекцией мы хотим, чтобы несколько бинов имели одно и то же имя квалификатора, чтобы их можно было внедрить в одну коллекцию с одним и тем же квалификатором. В этом случае мы должны использовать аннотацию @Qualifier вместе с @Bean вместо элемента name.)</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Бины могут быть упорядочены, когда они вставляются в списки (не Set или Map) или массивы. Поддерживаются как аннотация @Order, так и интерфейс Ordered.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R19" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">20</div></th><td class="s2">Расскажите про аннотацию @Conditional</td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Spring предоставляет возможность на основе вашего алгоритма включить или выключить определение бина или всей конфигурации через @Conditional, в качестве параметра которой указывается класс, реализующий интерфейс Condition, с единственным методом matches(ConditionContext var1, AnnotatedTypeMetadata var2), возвращающий boolean.<br>Для создания более сложных условий можно использовать классы AnyNestedCondition, AllNestedConditions и NoneNestedConditions.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Аннотация @Conditional указывает, что компонент имеет право на регистрацию в контексте только тогда, когда все условия соответствуют.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-style:italic;color:#000000;">Условия проверяются непосредственно перед тем, как должен быть зарегистрирован BeanDefinition компонента, и они могут помешать регистрации данного BeanDefinition. Поэтому нельзя допускать, чтобы при проверке условий мы взаимодействовали с бинами, которых еще не существует, с их BeanDefinition-ами можно.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Для того, чтобы проверить несколько условий, можно передать в @Conditional несколько классов с условиями:<br>@Conditional(HibernateCondition.class, OurConditionClass.class)<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Если класс @Configuration помечен как @Conditional, то на все методы @Bean, аннотации @Import и аннотации @ComponentScan, связанные с этим классом, также будут распространяться указанные условия.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R20" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">21</div></th><td class="s2">Расскажите про аннотацию @Profile</td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Профили - это ключевая особенность Spring Framework, позволяющая нам относить наши бины к разным профилям (логическим группам), например, dev, test, prod.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Мы можем активировать разные профили в разных средах, чтобы загрузить только те бины, которые нам нужны.<br>Используя аннотацию @Profile, мы относим бин к конкретному профилю. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Её можно применять на уровне класса или метода.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Аннотация @Profile принимает в качестве аргумента имя одного или нескольких профилей. Она фактически реализована с помощью гораздо более гибкой аннотации @Conditional.<br>Ее можно ставить на @Configuration и Component классы. </span><span style="font-size:10pt;font-family:Arial;">В Spring Boot есть возможность иметь один файл настроек application.properties, в котором будут основные настройки для всех профилей, и иметь по файлу настроек для каждого профиля application-dev.properties и application-prod.properties, содержащие свои собственные дополнительные настройки.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R21" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">22</div></th><td class="s2" rowspan="20">Расскажите про жизненный цикл бина, аннотации @PostConstruct и @PreDestroy()</td><td class="s11">1) Парсирование конфигурации и создание BeanDefinition</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R22" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">23</div></th><td class="s3">1. <span style="font-size:10pt;font-family:Arial;color:#ff0000;">Xml конфигурация</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — ClassPathXmlApplicationContext(“context.xml”) <br>2. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Конфигурация через аннотации с указанием пакета для сканирования</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — AnnotationConfigApplicationContext(“package.name”)<br>3. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Конфигурация через аннотации с указанием класса</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> (или массива классов) помеченного аннотацией @Configuration -AnnotationConfigApplicationContext(JavaConfig.class). Этот способ конфигурации называется — </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">JavaConfig</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. <br>4. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Groovy конфигурация</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — GenericGroovyApplicationContext(“context.groovy”)  <br> Если заглянуть внутрь AnnotationConfigApplicationContext, то можно увидеть два поля.  </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">private final AnnotatedBeanDefinitionReader reader</span><span style="font-size:10pt;font-family:Arial;color:#000000;">; </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">private final ClassPathBeanDefinitionScanner scanner</span><span style="font-size:10pt;font-family:Arial;color:#000000;">;  ClassPathBeanDefinitionScanner сканирует указанный пакет на наличие классов помеченных аннотацией @Component (или её алиаса). Найденные классы парсируются и для них создаются BeanDefinition. Чтобы было запущено сканирование, в конфигурации должен быть указан пакет для сканирования @ComponentScan({&quot;package.name&quot;}). AnnotatedBeanDefinitionReader работает в несколько этапов. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">1. Первый этап</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — это регистрация всех @Configuration для дальнейшего парсирования. Если в конфигурации используются Conditional, то будут зарегистрированы только те конфигурации, для которых Condition вернет true.  </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">2. Второй этап</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — это регистрация BeanDefinitionRegistryPostProcessor, который при помощи класса ConfigurationClassPostProcessor парсирует JavaConfig и создает BeanDefinition. <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Цель первого этапа — это создание всех BeanDefinition.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> BeanDefinition — это специальный интерфейс, через который можно получить доступ к метаданным будущего бина. В зависимости от того, какая у вас конфигурация, будет использоваться тот или иной механизм парсирования конфигурации. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">BeanDefinition — это набор метаданных будущего бина, макет, по которому нужно будет создавать бин в случае необходимости. То есть для каждого бина создается свой объект BeanDefinition, в котором хранится описание того, как создавать и управлять этим конкретным бином. Проще говоря, сколько бинов в программе - столько и объектов BeanDefinition, их описывающих.</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Сюда входит: </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">из какого класса бин надо создать, scope, установлена ли ленивая инициализация, нужно ли перед данным бином инициализировать другой, init и destroy методы, зависимости.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Все полученные <br>BeanDefinition’ы складываются в ConcurrentHashMap, в которой ключём является имя бина, а объект - сам BeanDefinition. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">При старте приложения, в IoC контейнер попадут бины, которые имеют scope Singleton</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> (устанавливается по-умолчанию), остальные же создаются, тогда когда они нужны.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R23" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">24</div></th><td class="s11">2) Настройка созданных BeanDefinition</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R24" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">25</div></th><td class="s3"><span style="font-size:10pt;font-family:Arial;">Есть возможность повлиять на бины до их создания, иначе говоря мы имеем доступ к метаданным класса. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Для этого существует специальный интерфейс BeanFactoryPostProcessor, реализовав который, мы получаем доступ к созданным BeanDefinition и можем их изменять.</span><span style="font-size:10pt;font-family:Arial;"> В нем один метод. <br>Метод postProcessBeanFactory принимает параметром ConfigurableListableBeanFactory. Данная фабрика содержит много полезных методов, в том числе getBeanDefinitionNames, через который мы можем получить все BeanDefinitionNames, а уже потом по конкретному имени получить BeanDefinition для дальнейшей обработки метаданных.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Разберем одну из родных реализаций интерфейса BeanFactoryPostProcessor. Обычно, настройки подключения к базе данных выносятся в отдельный property файл, потом при помощи PropertySourcesPlaceholderConfigurer они загружаются и делается inject этих значений в нужное поле. Так как inject делается по ключу, то до создания экземпляра бина нужно заменить этот ключ на само значение из property файла. Эта замена происходит в классе, который реализует интерфейс BeanFactoryPostProcessor. Название этого класса — PropertySourcesPlaceholderConfigurer. Он должен быть объявлен как static<br>@Bean<br>public static PropertySourcesPlaceholderConfigurer configurer() {<br>    return new PropertySourcesPlaceholderConfigurer();<br>}</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R25" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">26</div></th><td class="s11">3) Создание кастомных FactoryBean (только для XML-конфигурации)<br></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R26" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">27</div></th><td class="s3"><span style="font-size:10pt;font-family:Arial;color:#ff0000;">FactoryBean — это generic интерфейс, которому можно делегировать процесс создания бинов</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> типа . В те времена, когда конфигурация была исключительно в xml, разработчикам был необходим механизм с помощью которого они бы могли управлять процессом создания бинов. Именно для этого и был сделан этот интерфейс.<br>Создадим фабрику которая будет отвечать за создание всех бинов типа — Color.<br></span><span style="font-size:10pt;font-family:Arial;color:#0070c0;">public class ColorFactory implements FactoryBean&lt;Color&gt; {<br>    @Override<br>    public Color getObject() throws Exception {<br>        Random random = new Random();<br>        Color color = new Color(random.nextInt(255), random.nextInt(255), random.nextInt(255));<br>        return color;<br>    }<br><br>    @Override <br>    public Class&lt;?&gt; getObjectType() {<br>        return Color.class;<br>    }<br><br>    @Override<br>    public boolean isSingleton() {<br>        return false;<br>    }<br>}<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;">Теперь создание бина типа Color.class будет делегироваться ColorFactory, у которого при каждом создании нового бина будет вызываться метод getObject.<br>Для тех кто пользуется JavaConfig, этот интерфейс будет абсолютно бесполезен.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R27" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">28</div></th><td class="s11">4) Создание экземпляров бинов</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R28" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">29</div></th><td class="s3"><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Сначала</span><span style="font-size:10pt;font-family:Arial;"> BeanFactory из коллекции Map с объектами BeanDefinition достаёт те из них, из которых </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">создаёт все BeanPostProcessor-ы (Инфраструктурные бины), необходимые для настройки обычных бинов.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Создаются экземпляры бинов через BeanFactory на основе ранее созданных BeanDefinition.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Созданием экземпляров бинов занимается BeanFactory</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> на основе ранее созданных BeanDefinition.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;"> Из Map&lt;BeanName, BeanDefinition&gt; получаем Map&lt;BeanName, Bean&gt;</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Создание бинов может делегироваться кастомным FactoryBean. О их создании читай выше.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R29" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">30</div></th><td class="s11"><a target="_blank" href="http://java-online.ru/concurrent.xhtml">5) Настройка созданных бинов</a></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R30" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">31</div></th><td class="s12">На данном этапе бины уже созданы, мы можем лишь их донастроить.<br>Интерфейс BeanPostProcessor позволяет вклиниться в процесс настройки наших бинов до того, как они попадут в контейнер.<span style="font-size:10pt;font-family:Arial;"> ApplicationContext автоматически обнаруживает любые бины с реализацией BeanPostProcessor и помечает их как “post-processors” для того, чтобы создать их определенным способом. Например, в Spring есть реализации BeanPostProcessor-ов, которые обрабатывают аннотации @Autowired, @Inject, @Value и @Resource.<br>Интерфейс несет в себе два метода: postProcessBeforeInitialization(Object bean, String beanName) и postProcessAfterInitialization(Object bean, String beanName). У обоих методов параметры абсолютно одинаковые. Разница только в порядке их вызова. Первый вызывается до init-метода, второй - после.</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"><br>Как правило, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">BeanPostProcessor</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">-ы, которые </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">заполняют бины через маркерные интерфейсы</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> или тому подобное, реализовывают метод </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">postProcessBeforeInitialization</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> (Object bean, String beanName), тогда как </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">BeanPostProcessor-ы, которые оборачивают бины в прокси, обычно реализуют postProcessAfterInitialization </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">(Object bean, String beanName).<br></span><span style="font-size:10pt;font-family:Arial;color:#002060;">Прокси — это класс-декорация над бином. Например, мы хотим добавить логику нашему бину, но джава-код уже скомпилирован, поэтому нам нужно на лету сгенерировать новый класс. Этим классом мы должны заменить оригинальный класс так, чтобы никто не заметил подмены.<br>Есть два варианта создания этого класса:<br>1. либо он должен наследоваться от оригинального класса (CGLIB) и переопределять его методы, добавляя нужную логику;<br>2. либо он должен имплементировать те же самые интерфейсы, что и первый класс (Dynamic Proxy).<br>По конвенции спринга, если какой-то из BeanPostProcessor-ов меняет что-то в классе, то он должен это делать на этапе postProcessAfterInitialization(). Таким образом мы уверены, что initMethod у данного бина, работает на оригинальный метод, до того, как на него накрутился прокси.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R31" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">32</div></th><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;">Хронология событий:</span><span style="font-size:10pt;font-family:Arial;"><br>1. Сначала сработает метод postProcessBeforeInitialization() всех имеющихся BeanPostProcessor-ов.<br>2. Затем, при наличии, будет вызван метод, аннотированный @PostConstruct.<br>3. Если бин имплементирует InitializingBean, то Spring вызовет метод afterPropertiesSet() - не рекомендуется к использованию как устаревший.<br>4. При наличии, будет вызван метод, указанный в параметре initMethod аннотации @Bean.<br>5. В конце бины пройдут через postProcessAfterInitialization (Object bean, String beanName). Именно на данном этапе создаются прокси стандартными BeanPostProcessor-ами. Затем отработают наши кастомные BeanPostProcessor-ы и применят нашу логику к прокси-объектам. После чего все бины окажутся в контейнере, который будет обязательно обновлен методом refresh().<br>6. Но даже после этого мы можем донастроить наши бины ApplicationListener-ами.<br>7. Теперь всё.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R32" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">33</div></th><td class="s11">6) Бины созданы</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R33" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">34</div></th><td class="s3">Их можно получить с помощью метода ApplicationContext.getBean().</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R34" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">35</div></th><td class="s11">7. Закрытие контекста</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R35" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">36</div></th><td class="s3">Когда контекст закрывается (метод close() из ApplicationContext), бин уничтожается. Если в бине есть метод, аннотированный @PreDestroy, то перед уничтожением вызовется этот метод.<br>Если в аннотации @Bean определен метод destroyMethod, то будет вызван и он.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R36" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">37</div></th><td class="s11">Аннотация PostConstruct</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R37" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">38</div></th><td class="s3">Spring вызывает методы, аннотированные @PostConstruct, только один раз, сразу после инициализации свойств компонента. За данную аннотацию отвечает один из BeanPostProcessorов.<br>Метод, аннотированный @PostConstruct, может иметь любой уровень доступа, может иметь любой тип возвращаемого значения (хотя тип возвращаемого значения игнорируется Spring-ом), метод не должен принимать аргументы. Он также может быть статическим, но<br>преимуществ такого использования метода нет, т.к. доступ у него будет только к статическим полям/методам бина, и в таком случае смысл его использования для настройки бина пропадает.<br>Одним из примеров использования @PostConstruct является заполнение базы данных. Например, во время разработки нам может потребоваться создать пользователей по умолчанию.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R38" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">39</div></th><td class="s11">Аннотация PreDestroy</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R39" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">40</div></th><td class="s10">Метод, аннотированный @PreDestroy, запускается только один раз, непосредственно перед тем, как Spring удаляет наш компонент из контекста приложения.<br>Как и в случае с @PostConstruct, методы, аннотированные @PreDestroy, могут иметь любой уровень доступа, но не могут быть статическими. Целью этого метода может быть освобождение ресурсов или выполнение любых других задач очистки до уничтожения бина, например, закрытие соединения с базой данных.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R40" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">41</div></th><td class="s3">Класс, имплементирующий BeanPostProcessor, обязательно должен быть бином, поэтому мы его помечаем аннотацией @Component.<br>SCOPE_SINGLETON — инициализация произойдет один раз на этапе поднятия контекста. SCOPE_PROTOTYPE — инициализация будет выполняться каждый раз по запросу. Причем во втором случае ваш бин будет проходить через все BeanPostProcessor-ы что может значительно ударить по производительности.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R41" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">42</div></th><td class="s2">Расскажите про скоупы бинов? Какой скоуп используется по умолчанию? Что изменилось в Spring 5?</td><td class="s3">Существует 2 области видимости по умолчанию.<br><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Singleton </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- область видимости по умолчанию. В контейнере будет создан только один бин, и все запросы на него будут возвращать один и тот же бин.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Prototype </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- приводит к созданию нового бина каждый раз, когда он запрашивается.<br>Для бинов со scope “prototype” Spring не вызывает метод destroy(), так как не берет на себя контроль полного жизненного цикла этого бина. Spring не хранит такие бины в своём контексте ( контейнере), а отдаёт их клиенту и больше о них не заботится (в отличие от синглтон-бинов).<br><br>И 4 области видимости в веб-приложении.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Request </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Область видимости — 1 HTTP запрос. На каждый запрос создается новый бин<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Session </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Область видимости — 1 сессия. На каждую сессию создается новый бин<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Application </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Область видимости — жизненный цикл ServletContext <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">WebSocket </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Область видимости — жизненный цикл WebSocket<br>Жизненный цикл web csope полный.<br><br>В пятой версии Spring Framework не стало </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Global session</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> scope. И появились Application и WebSocket</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R42" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">43</div></th><td class="s2">Расскажите про аннотацию @ComponentScan</td><td class="s3">Первый шаг для описания конфигурации Spring это добавление аннотаций — @Component или наследников.<br>Однако, Spring должен знаеть где искать их. В <span style="font-size:10pt;font-family:Arial;color:#ff0000;">@ComponentScan вы указываете пакеты, которые должны сканироваться</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Можно указать массив строк.<br>Spring будет искать бины и в их подпакетах.<br>Мы можем расширить это поведение с помощью includeFilters и excludeFilters параметров в аннотации.<br>Для ComponentScan.Filter доступно пять типов фильтров:<br>ANNOTATION<br>ASSIGNABLE_TYPE<br>ASPECTJ<br>REGEX<br>CUSTOM<br>Нужно для того, что например, имея какой-то ненужный класс в не нашей библиотеке, мы можем создать для него фильтр, чтобы его бин не инициализировался.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R43" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">44</div></th><td class="s2" rowspan="11">Как спринг работает с транзакциями? Расскажите про аннотацию @Transactional.</td><td class="s13"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth">Хорошая статья - marcobehler.com/guides/spring-transaction-management-transactional-in-depth</a></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R44" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">45</div></th><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Коротко</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: Spring создает прокси для всех классов, помеченных @Transactional (либо если любой из методов класса помечен этой аннотацией), что позволяет вводить транзакционную логику до и после вызываемого метода. При вызове такого метода происходит следующее:<br>- proxy, который создал Spring, создаёт persistence context (или соединение с базой),<br>- открывает в нём транзакцию и сохраняет всё это в контексте нити исполнения (натурально, в ThreadLocal).<br>- По мере надобности всё сохранённое достаётся и внедряется в бины.<br><br>Таким образом, если в вашем коде есть несколько параллельных нитей, у вас будет и несколько параллельных транзакций, которые будут взаимодействовать друг с другом согласно уровням изоляции.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Что произойдёт, если один метод с @Transactional вызовет другой метод с @Transactional?</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Если это происходит в рамках одного сервиса, то второй транзакционный метод будет считаться частью первого, так как вызван у него изнутри, а так как спринг не знает о внутреннем вызове, то не создаст прокси для второго метода.(Обернуто в проски будет а вот транзакция создана не будет если из 2 класса вызван метод то транзакция будет)<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Что произойдёт, если один метод БЕЗ @Transactional вызовет другой метод с @Transactional?</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Так как spring не знает о внутреннем вызове, то не создаст прокси для второго метода.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Будет ли транзакция откачена, если будет брошено исключение, которое указано в контракте метода?</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Если в контракте описано это исключение, то она не откатится. Unchecked исключения в транзакционном методе можно ловить, а можно и не ловить.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R45" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">46</div></th><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Значения атрибута propagation у аннотации:<br>REQUIRED </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— применяется по умолчанию. При входе в @Transactional метод </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">будет использована уже существующая транзакция или создана новая транзакция</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, если никакой ещё нет<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">REQUIRES_NEW </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">новая транзакция</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> всегда создаётся при входе метод,</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> ранее созданные транзакции приостанавливаются</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> до момента возврата из метода.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">NESTED </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">корректно работает только с базами данных, которые умеют savepoints</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. При входе в метод в уже существующей транзакции создаётся savepoint, который по результатам выполнения метода будет либо сохранён, либо откачен. Все изменения, внесённые методом, подтвердятся только поздее, с подтверждением всей транзакции. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Если текущей транзакции не существует, будет создана новая.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">MANDATORY</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">всегда используется существующая транзакция</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> и кидается исключение, если текущей транзакции нет.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">SUPPORTS</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — метод с этим правилом</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> будет использовать текущую транзакцию</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, если она есть, либо </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">будет исполнятся без транзакции</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, если её нет.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">NOT_SUPPORTED </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— при входе в метод текущая транзакция, если она есть,</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> будет приостановлена и метод будет выполняться без транзакции</span><span style="font-size:10pt;font-family:Arial;color:#000000;">.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">NEVER</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">явно запрещает исполнение в контексте транзакции</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Если при входе в метод будет существовать транзакция, будет выброшено исключение.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R46" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">47</div></th><td class="s8"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Остальные атрибуты:</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">rollbackFor</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">= Exception.class - если какой-либо метод выбрасывает указанное исключение, контейнер всегда откатывает текущую транзакцию. По умолчанию отлавливает RuntimeException<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">noRollbackFor</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">= Exception.class - указание того, что любое исключение, кроме заданных, должно приводить к откату транзакции.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">rollbackForClassName </span><span style="font-size:10pt;font-family:Arial;color:#000000;">и </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">noRollbackForClassName </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- для задания имен исключений в строковом виде.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">readOnly</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- разрешает только операции чтения.<br>В свойстве </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">transactionManager </span><span style="font-size:10pt;font-family:Arial;color:#000000;">хранится ссылка на менеджер транзакций, определенный в конфигурации Spring.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">timeOut</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- По умолчанию используется таймаут, установленный по умолчанию для базовой транзакционной системы. Сообщает менеджеру tx о продолжительности времени, чтобы дождаться простоя tx, прежде чем принять решение об откате не отвечающих транзакций.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">isolation </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">- </span><span style="font-size:10pt;font-family:Arial;color:#000000;">уровень изолированности транзакций<br><br></span></td><td class="s14"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R47" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">48</div></th><td class="s15"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/">Подробно:</a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/"><br></a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/">Для работы с транзакциями Spring Framework использует AOP-прокси:</a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/"><br>Для включения возможности управления транзакциями нужно разместить аннотацию </a></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/">@EnableTransactionManagement у класса конфигурации @Configuration.<br>Она означает, что классы, помеченные @Transactional, должны быть обернуты аспектом транзакций. Отвечает за регистрацию необходимых компонентов Spring, таких как TransactionInterceptor и советы прокси. </a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/">Регистрируемые компоненты помещают перехватчик в стек вызовов при вызове методов @Transactional. Если мы используем Spring Boot и имеем зависимости spring-data-* или spring-tx, то управление транзакциями будет включено по умолчанию.<br>Пропагейшн работает только если метод вызывает другой метод в другом сервисе. Если метод вызывает другой метод в этом же сервисе, то используется this и вызов проходит мимо прокси. Это ограничение можно обойти при помощи self-injection.</a></span></td><td class="s16"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R48" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">49</div></th><td class="s10">Слой логики(Service) - лучшее место для @Transactional.<br>Помечая @Transactional класс @Service, то все его методы станут транзакционными. Так, при вызове, например, метода save() произойдет примерно следующее:<br><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">1. Вначале мы имеем:</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>❖        класс </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">TransactionInterceptor, у которого вызывается метод invoke(...)</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, внутри которого вызывается метод класса-родителя TransactionAspectSupport: invokeWithinTransaction(...), в рамках которого происходит магия транзакций.<br>❖        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">TransactionManager: решает, создавать ли новый EntityManager и/или транзакцию.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>❖        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">EntityManager proxy: EntityManager - это интерфейс, и то, что внедряется в бин в слое DAO на самом деле не является реализацией EntityManager. В это поле внедряется EntityManager proxy, который будет перехватывать обращение к полю EntityManager и  делегировать выполнение  конкретному EntityManager в рантайме. Обычно EntityManager proxy представлен классом SharedEntityManagerInvocationHandler.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R49" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">50</div></th><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">2. Transaction  Interceptor</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">В TransactionInterceptor отработает код до работы метода save(), в котором будет определено, выполнить ли метод save() в пределах уже существующей транзакции БД или должна стартовать новая отдельная транзакция.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">TransactionInterceptor сам не содержит логики по принятию решения, решение начать новую транзакцию, если это нужно, делегируется TransactionManager.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Грубо говоря, на данном этапе наш метод будет обёрнут в try-catch и будет добавлена логика до его вызова и после:<br>     try {<br>        transaction.begin();         // логика до<br>        service.save();         <br>        transaction.commit();      // логика после<br>      } catch(Exception ex) {<br>       transaction.rollback();<br>       throw ex;<br>      }</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R50" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">51</div></th><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">3. TransactionManager</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Менеджер транзакций должен предоставить ответ на два вопроса:<br>❖        Должен ли создаться новый EntityManager?<br>❖        Должна ли стартовать новая транзакция БД?<br>Решение принимается, основываясь на следующих фактах:<br>❖        выполняется ли хоть одна транзакция в текущий момент или нет;<br>❖        атрибута «propagation» в @Transactional.<br>Если TransactionManager решил создать новую транзакцию, тогда:<br>❖        Создается новый EntityManager;<br>❖        EntityManager «привязывается» к текущему потоку (Thread);<br>❖        «Получается» соединение из пула соединений БД; <br>❖        Соединение «привязывается» к текущему потоку.<br>И EntityManager и это соединение привязываются к текущему потоку, используя  переменные ThreadLocal.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R51" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">52</div></th><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">4. EntityManager proxy</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Когда метод save() слоя Service делает вызов метода save() слоя DAO, внутри которого вызывается, например, entityManager.persist(), то не происходит вызов метода persist() напрямую у EntityManager, записанного в поле класса DAO. Вместо этого метод вызывает EntityManager proxy, который достает текущий EntityManager для нашего потока, и у него вызывается метод persist().<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">5. Отрабатывает DAO-метод save().</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R52" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">53</div></th><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">6. TransactionInterceptor</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Отработает код после работы метода save(), а именно будет принято решение по коммиту/откату транзакции.<br><br>Кроме того, если мы в рамках одного метода сервиса обращаемся не только к методу save(), а к разным методам Service и DAO, то все они буду работать в рамках одной транзакции, которая оборачивает этот метод сервиса.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R53" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">54</div></th><td class="s3">Вся работа происходит через прокси-объекты разных классов. Представим, что у нас в классе сервиса только один метод с аннотацией @Transactional, а остальные нет. Если мы вызовем метод с @Transactional, из которого вызовем метод без @Transactional, то оба будут отработаны в рамках прокси и будут обернуты в нашу транзакционную логику. Однако, если мы вызовем метод без @Transactional, из которого вызовем метод с @Transactional, то они уже не будут работать в рамках прокси и не будут обернуты в нашу транзакционную логику.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R54" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">55</div></th><td class="s2">Расскажите про аннотации @Controller и @RestController. Чем они отличаются? Как вернуть ответ со своим статусом (например 213)?</td><td class="s3">@<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Controller </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- специальный тип класса, обрабатывает HTTP-запросы и часто используется с аннотацией @RequestMapping.<br>@</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">RestController </span><span style="font-size:10pt;font-family:Arial;color:#000000;">ставится на класс-контроллер вместо @Controller. Она указывает, что этот класс оперирует не моделями, а данными. Она состоит из аннотаций @Controller и @ResponseBody. Была введена в Spring 4.0 для упрощения создания RESTful веб-сервисов.<br><br>@</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ResponseBody </span><span style="font-size:10pt;font-family:Arial;color:#000000;">сообщает контроллеру, что возвращаемый объект автоматически сериализуется (используя Jackson message converter) в json или xml и передается обратно в объект HttpResponse.<br><br>ResponseEntity используется для формирования кастомизированного HTTP-ответа с пользовательскими параметрами (заголовки, код статуса и тело ответа). Во всех остальных случаях достаточно использовать @ResponseBody.<br>Если мы хотим использовать ResponseEntity, то просто должны вернуть его из метода, Spring позаботится обо всем остальном.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">return ResponseEntity.status(213);</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R55" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">56</div></th><td class="s2">Что такое ViewResolver?</td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ViewResolver</span><span style="font-size:10pt;font-family:Arial;color:#000000;">  - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">распознаватель представлений</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">это способ работы с представлениями(html-файлы), который поддерживает их распознавание на основе имени, возвращаемого контроллером.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Spring Framework поставляется с большим количеством реализаций ViewResolver. Например, класс UrlBasedViewResolver поддерживает прямое преобразование логических имен в URL.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">InternalResourceViewResolver — реализация ViewResolver по умолчанию</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, которая позволяет находить представления, которые возвращает контроллер для последующего перехода к ним. Ищет по заданному пути, префиксу, суффиксу и имени.<br>Любым реализациям ViewResolver желательно поддерживать интернационализацию, то есть множество языков.<br>Существует также несколько реализаций для интеграции с различными технологиями представлений, такими как FreeMarker (FreeMarkerViewResolver), Velocity (VelocityViewResolver) и JasperReports (JasperReportsViewResolver).</span></td><td class="s17">При помощи интерфейса <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#111111;">ViewResolver</span><span style="font-size:10pt;font-family:Arial;color:#111111;"> DispatcherServlet определяет, какой Вид нужно использовать на основании полученного имени, возвращаемого контроллером.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R56" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">57</div></th><td class="s2">Чем отличаются Model, ModelMap и ModelAndView?</td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Model</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Интерфейс, лежит в пакете spring-context. В методах контроллера мы можем<br>использовать объекты Model для того, чтобы складывать туда данные, предназначенные для<br>формирования представлений. Кроме того, в Model мы можем передать даже Map с<br>атрибутами</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Содержимое модели используется для отображения данных во View.<br>Например, если View выводит информацию об объекте Customer, то она может ссылаться к ключам модели, например customerName, customerPhone, и получать значения для этих ключей.<br>Объекты-значения из модели также могут содержать бизнес-логику.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ModelMap - Этот класс наследуется от LinkedHashMap&lt;String, Object&gt; и по сути служит общим<br>контейнером модели для Servlet MVC, но не привязан к нему, и лежит в пакете spring-context.<br>Имеет все преимущества LinkedHashMap плюс несколько удобных методов</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ModelAndView </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Этот класс лежит в пакете spring-webmvc и может одновременно хранить модели и<br>представление, чтобы контроллер мог отдавать их в одном возвращаемом значении. Внутри<br>содержит поле private Object view, куда записывает нужное представление, а также поле private<br>ModelMap model, куда и складывает все атрибуты модели</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">View </span><span style="font-size:10pt;font-family:Arial;color:#000000;">используется для отображения данных приложения пользователю.<br>Spring MVC поддерживает несколько поставщиков View(они называются шаблонизаторы) — JSP, JSF, Thymeleaf, и т.п.<br>Интерфейс View преобразует объекты в обычные сервлеты.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R57" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">58</div></th><td class="s2">Расскажите про паттерн Front Controller, как он реализован в Spring?</td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Front controller - паттерн, где центральный сервлет, DispatcherServlet, принимает все запросы и распределяет их между контроллерами, обрабатывающими разные URL.</span><span style="font-size:10pt;font-family:Arial;color:#000000;">обеспечивает единую точку входа для всех входящих запросов. Все запросы обрабатываются одним обработчиком – DispatcherServlet с маппингом “/”. Этот обработчик может выполнить аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем распределяет их между контроллерами, обрабатывающими разные URL. Это и есть реализация паттерна Front Controller.<br>Веб-приложение может определять любое количество DispatcherServlet-ов. Каждый из них будет работать в своем собственном пространстве имен, загружая свой собственный дочерний WebApplicationContext с вьюшками, контроллерами и т.д.<br>❖        Один из контекстов будет корневым, а все остальные контексты будут дочерними.<br>❖        Все дочерние контексты могут получить доступ к бинам, определенным в корневом контексте, но не наоборот. <br>❖        Каждый дочерний контекст внутри себя может переопределить бины из корневого контекста</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">.<br>WebApplicationContext </span><span style="font-size:10pt;font-family:Arial;color:#000000;">расширяет ApplicationContext (создаёт и управляет бинами и т.д.), но помимо этого он имеет дополнительный метод getServletContext(), через который у него есть возможность получать доступ</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">к</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">ServletContext-у.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><br>ContextLoaderListener </span><span style="font-size:10pt;font-family:Arial;color:#000000;">создает корневой контекст приложения и будет использоваться всеми дочерними контекстами, созданными всеми DispatcherServlet.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R58" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">59</div></th><td class="s2" rowspan="7">Расскажите про паттерн MVC, как он реализован в Spring?</td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">MVC — это шаблон проектирования, делящий программу на 3 вида компонентов:</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Model </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— модель отвечает за хранение данных.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">View </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— отвечает за вывод данных на фронтенде.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Controller </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— оперирует моделями и отвечает за обмен данными model с view.<br>Основная цель следования принципам MVC — отделить реализацию бизнес-логики приложения (модели) от ее визуализации (view).<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Spring MVC</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - это веб-фреймворк, основанный на Servlet API, с использованием двух шаблонов проектирования - Front controller и MVC.<br>Spring MVC реализует четкое разделение задач, что позволяет нам легко разрабатывать и тестировать наши приложения. Данные задачи разбиты между разными компонентами: Dispatcher Servlet, Controllers, View Resolvers, Views, Models, ModelAndView, Model and Session Attributes, которые полностью независимы друг от друга, и отвечают только за одно направление. Поэтому MVC дает нам довольно большую гибкость. Он основан на интерфейсах (с предоставленными классами реализации), и мы можем настраивать каждую часть фреймворка с помощью пользовательских интерфейсов.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R59" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">60</div></th><td class="s11">Основные интерфейсы для обработки запросов:</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R60" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">61</div></th><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">DispatcherServlet </span><span style="font-size:10pt;font-family:Arial;color:#000000;">является главным контроллером, который получает запросы и распределяет их между другими контроллерами. @RequestsMapping указывает, какие именно запросы будут обрабатываться в конкретном контроллере. Может быть несколько экземпляров DispatcherServlet, отвечающих за разные задачи (обработка запросов пользовательского интерфейса, REST служб и т.д.). Каждый экземпляр DispatcherServlet имеет собственную конфигурацию WebApplicationContext.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">HandlerMapping</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Выбор класса и его метода, которые должны обработать данный входящий запрос на основе любого внутреннего или внешнего для этого запроса атрибута или состояния.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Controller </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— оперирует моделями и отвечает за обмен данными model с view.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ViewResolver</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Выбор, какое именно View должно быть показано клиенту на основе имени, полученного от контроллера.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R61" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">62</div></th><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">View</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Отвечает за возвращение ответа клиенту в виде текстов и изображений. Используются встраиваемые шаблонизаторы (Thymeleaf, FreeMarker и т.д.), так как у Spring нет родных. Некоторые запросы могут идти прямо во View, не заходя в Model, другие проходят через все слои.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">HandlerAdapter</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Помогает DispatcherServlet вызвать и выполнить метод для обработки входящего запроса.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ContextLoaderListener </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- слушатель при старте и завершении корневого класса Spring WebApplicationContext. Основным назначением является связывание жизненного цикла ApplicationContext и ServletContext, а также автоматического создания ApplicationContext. Можно использовать этот класс для доступа к бинам из различных контекстов спринг.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R62" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">63</div></th><td class="s11">Ниже приведена последовательность событий, соответствующая входящему HTTP-запросу:</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R63" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">64</div></th><td class="s6"></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R64" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">65</div></th><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">❖        После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет, какой Контроллер (Controller) должен быть вызван, после чего HandlerAdapter, отправляет запрос в нужный метод Контроллера.<br>❖        Контроллер принимает запрос и вызывает соответствующий метод. Вызванный метод формирует данные Model и возвращает их в DispatcherServlet вместе с именем View (как правило имя html-файла).<br>❖        При помощи интерфейса ViewResolver DispatcherServlet определяет, какое View нужно использовать на основании имени, полученного от контроллера.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>➢        если это REST-запрос на сырые данные (JSON/XML), то<br>DispatcherServlet сам его отправляет, минуя ViewResolver;<br>➢        если обычный запрос, то DispatcherServlet отправляет данные Model в виде атрибутов во View - шаблонизаторы Thymeleaf, FreeMarker и т.д., которые сами отправляют ответ.<br> <br>Как видим, все действия происходят через один DispatcherServlet.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R65" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">66</div></th><td class="s2">Что такое АОП? Как реализовано в спринге?</td><td class="s3"><span style="font-weight:bold;color:#3e5656;">Аспектно-ориентированное программирование (АОП) — это парадигма программирования, целью которой является разделениее основного и служебного функционала, служебный функционал записывается в Аспект-классы(в основе Аспект заключается сквозная логика) Примеры Аспекта - логирование, проверка прав, обработка транзакций, обработка исключений, кэширование и т.д. </span><span style="color:#ff0000;">Это достигается путем добавления дополнительного поведения к существующему коду без изменения самого кода.</span><span style="color:#3e5656;"><br></span><span style="font-weight:bold;color:#ff0000;">АОП предоставляет возможность реализации сквозной логики в одном месте - т.е. логики, которая применяется к множеству частей приложения - и обеспечения автоматического применения этой логики по всему приложению.</span><span style="color:#3e5656;"><br></span><span style="font-weight:bold;color:#3e5656;">Аспект </span><span style="color:#3e5656;">в АОП - это модуль или класс, реализующий сквозную функциональность. Аспект изменяет поведение остального кода, применяя совет в точках соединения, определённых некоторым срезом.<br></span><span style="font-weight:bold;color:#3e5656;">Совет </span><span style="color:#3e5656;">(advice) – дополнительная логика — код, который должен быть вызван из точки соединения.<br></span><span style="font-weight:bold;color:#3e5656;">Точка соединения</span><span style="color:#3e5656;"> (join point) — место в выполняемой программе (вызов метода, создание объекта, обращение к переменной), где следует применить совет;<br></span><span style="font-weight:bold;color:#3e5656;">Срез </span><span style="color:#3e5656;">(pointcut) — набор точек соединения.<br></span><span style="font-weight:bold;color:#3e5656;">Подход Spring к АОП заключается в создании &quot;динамических прокси&quot; для целевых объектов и &quot;привязывании&quot; объектов к конфигурированному совету для выполнения сквозной логики.<br></span><span style="color:#3e5656;">Есть два варианта создания прокси-класса:<br>1. либо он должен наследоваться от оригинального класса (</span><span style="font-weight:bold;color:#3e5656;">CGLIB</span><span style="color:#3e5656;">) и переопределять его методы, добавляя нужную логику;<br>2. либо он должен имплементировать те же самые интерфейсы, что и первый класс (</span><span style="font-weight:bold;color:#3e5656;">Dynamic Proxy</span><span style="color:#3e5656;">).</span></td><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Прокси</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — это класс-декорация над бином. Например, мы хотим добавить логику нашему бину, но джава-код уже скомпилирован, поэтому нам нужно на лету сгенерировать новый класс. Этим классом мы должны заменить оригинальный класс так, чтобы никто не заметил подмены. Есть два варианта создания этого класса: 1. либо он должен наследоваться от оригинального класса (CGLIB) и переопределять его методы, добавляя нужную логику; 2. либо он должен имплементировать те же самые интерфейсы, что и первый класс (Dynamic Proxy). По конвенции спринга, если какой-то из BeanPostProcessor-ов меняет что-то в классе, то он должен это делать на этапе postProcessAfterInitialization(). Таким образом мы уверены, что initMethod у данного бина, работает на оригинальный метод, до того, как на него накрутился прокси.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R66" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">67</div></th><td class="s2" rowspan="4">В чем разница между Filters, Listeners and Interceptors?</td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Filter выполняет задачи фильтрации либо по пути запроса к ресурсу, либо по пути ответа от ресурса, либо в обоих направлениях.(Это интерфейс из пакета javax.servlet)</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Фильтры выполняют фильтрацию в методе doFilter. Каждый фильтр имеет доступ к объекту FilterConfig, из которого он может получить параметры инициализации, и ссылку на ServletContext. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Фильтры настраиваются в дескрипторе развертывания веб-приложения.<br>При создании цепочки фильтров, веб-сервер решает, какой фильтр вызывать первым, в соответствии с порядком регистрации фильтров.<br>Когда вызывается метод doFilter(ServletRequest request, ServletResponse response,<br>FilterChain chain) первого фильтра, веб-сервер создает объект FilterChain, представляющий цепочку фильтров, и передаёт её в метод.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Зависят от контейнера сервлетов. Могут работать с js, css.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R67" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">68</div></th><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Interceptor </span><span style="font-size:10pt;font-family:Arial;color:#000000;">являются аналогом Filter в Spring. Перехватить запрос клиента можно в трех местах: preHandle, postHandle и afterCompletion.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Перехватчики работают с HandlerMapping и поэтому должны реализовывать интерфейс HandlerInterceptor</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> или наследоваться от готового класса HandlerInterceptorAdapter, после чего переопределить указанные методы.<br>Чтобы добавить наши перехватчики в конфигурацию Spring, нам нужно переопределить метод addInterceptors () внутри класса, который реализует WebMvcConfigurer.<br>Interceptor основан на механизме Reflection, а фильтр основан на обратном вызове функции.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R68" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">69</div></th><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">preHandle </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— метод используется для обработки запросов, которые еще не были переданы в метод контроллера. Должен вернуть true для передачи следующему перехватчику или в handler method. False укажет на обработку запроса самим обработчиком и отсутствию необходимости передавать его дальше. Метод имеет возможность выкидывать исключения и пересылать ошибки к представлению.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">postHandle </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— вызывается после handler method, но до обработки DispatcherServlet для передачи представлению. Может использоваться для добавления параметров в объект ModelAndView. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Вы можете<br>добавить больше объектов модели в представление, но вы не можете изменить<br>HttpServletResponse, так как он уже зафиксирован.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">afterCompletion </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— вызывается после отрисовки представления.</span></td><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">public boolean preHandle</span><span style="font-size:10pt;font-family:Arial;color:#000000;">(HttpServletRequest request, HttpServletResponse response,<br>Object handler) </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">public void postHandle</span><span style="font-size:10pt;font-family:Arial;color:#000000;">(HttpServletRequest request, HttpServletResponse response, Object<br>handler, ModelAndView modelAndView) </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">public void afterCompletion</span><span style="font-size:10pt;font-family:Arial;color:#000000;">(HttpServletRequest request, HttpServletResponse response,<br>Object handler, Exception ex)  Следует знать, что HandlerInterceptor связан с бином DefaultAnnotationHandlerMapping,<br>который отвечает за применение перехватчиков к любому классу, помеченному аннотацией<br>@Controller.<br></span></td><td class="s8">Filter vs. Interceptor ❖ Перехватчик основан на механизме Reflection, а фильтр основан на обратном вызове функции. ❖ Фильтр зависит от контейнера сервлета, тогда как перехватчик не зависит от него. ❖ Перехватчики могут работать только с запросами к контроллерам, в то время как фильтры могут работать почти со всеми запросами (например, js, .css и т.д.). ❖ Перехватчики в отличии от фильтров могут обращаться к объектам в контейнере Spring, что даёт им более изощренный функционал</td></tr><tr style="height: 20px"><th id="0R69" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">70</div></th><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Listener </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">это класс, имплементирующий интерфейс ServletContextListener с аннотацией @WebListener. Listener ждет когда произойдет указанное событие, затем «перехватывает» событие и запускает собственное событие.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Он инициализируется только один раз при запуске веб-приложения и уничтожается при остановке веб-приложения. Все ServletContextListeners уведомляются об инициализации контекста до инициализации любых фильтров или сервлетов в вебприложении и об уничтожении контекста после того, как все сервлеты и фильтры уничтожены</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">.Основным назначением является связывание жизненного цикла ApplicationContext и ServletContext, а также автоматического создания ApplicationContext.</span></td><td class="s18">Концептуально всё просто, фильтры сервлетов могут перехватывать только HTTPServlets. Listeners могут перехватывать специфические события. Как перехватить события которые относятся ни к тем не другим? Фильтры и перехватчики делают по сути одно и тоже: они перехватывают какое-то событие, и делают что-то до или после. Java EE использует термин Filter, Spring называет их Interceptors. Именно здесь AOP используется в полную силу, благодаря чему возможно перехватывание вызовов любых объектов</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R70" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">71</div></th><td class="s2">Можно ли передать в запросе один и тот же параметр несколько раз? Как?</td><td class="s3">Да, можно принять все значения, используя массив в методе контроллера:<br><br>http://localhost:8080/login?name=Ranga&amp;name=Ravi&amp;name=Sathish<br>public String method(@RequestParam(value=&quot;name&quot;) <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">String[] names</span><span style="font-size:10pt;font-family:Arial;color:#000000;">){...}<br><br>http://localhost:8080/api/foos?id=1,2,3<br>public String getFoos(@RequestParam </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">List&lt;String&gt; id</span><span style="font-size:10pt;font-family:Arial;color:#000000;">){...}</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R71" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">72</div></th><td class="s2" rowspan="5">Как работает Spring Security? Как сконфигурировать? Какие интерфейсы используются?</td><td class="s3"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">В кратце</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, основными блоками Spring Security являются:<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">SecurityContextHolder</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, чтобы обеспечить доступ к SecurityContext.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">SecurityContext</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, содержит объект Authentication и в случае необходимости информацию системы безопасности, связанную с запросом.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Authentication</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> представляет принципала с точки зрения Spring Security.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">GrantedAuthority</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> отражает разрешения выданные доверителю в масштабе всего приложения.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">UserDetails</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> предоставляет необходимую информацию для построения объекта Authentication из DAO объектов приложения или других источника данных системы безопасности.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">UserDetailsService</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, чтобы создать UserDetails, когда передано имя пользователя в виде String (или идентификатор сертификата или что-то подобное).<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Подробно</span><span style="font-size:10pt;font-family:Arial;color:#000000;">:</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R72" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">73</div></th><td class="s10">Самым фундаментальным явлется <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">SecurityContextHolder</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. В нем мы храним информацию о текущем контексте безопасности приложения, который включает в себя подробную информацию о пользователе, работающем с приложением. По умолчанию SecurityContextHolder использует </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">MODE_THREADLOCAL </span><span style="font-size:10pt;font-family:Arial;color:#000000;">для хранения такой информации, что означает, что контекст безопасности всегда доступен для методов исполняющихся в том же самом потоке, даже если контекст безопасности явно не передается в качестве аргумента этих методов:<br><br>SecurityContextHolder.getContext().getAuthentication().getPrincipal();<br>UserDetails выступает в качестве принципала.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R73" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">74</div></th><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">MODE_GLOBAL </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- все потоки Java-машины используют один контекст безопасности.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">MODE_INHERITABLETHREADLOCAL </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- потоки порожденные от одного защищенного потока, наличие аналогичной безопасности.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R74" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">75</div></th><td class="s10">Интерфейс <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">UserDetailsService </span><span style="font-size:10pt;font-family:Arial;color:#000000;">-</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">подход к загрузке информации о пользователе в Spring Security. Единственный метод этого интерфейса принимает имя пользователя в виде String и возвращает </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">UserDetails.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Он представляет собой принципала, но в расширенном виде и с учетом специфики приложения.<br>В случае успешной аутентификации, UserDetails используется для создания Authentication объекта, который хранится в SecurityContextHolder.<br>Ещё одним важным методом Authentication явлется getAuthorities() - предоставляет массив объектов GrantedAuthority(роли).<br>Credentials - под ними понимаются пароль пользователя, но им может быть и отпечаток пальца, фото сетчатки и т.п.</span></td><td class="s19">AuthenticationManager - основной стратегический интерфейс для аутентификации.ProviderManager, который содержит поле private List&lt;AuthenticationProvider&gt;.AuthenticationProvider - интерфейс объекта, выполняющего аутентификацию. Имеет<br>массу готовых реализаций. Т<br>providers со списком AuthenticationProvider-ов и итерирует запрос аутентификации по этому<br>списку AuthenticationProvider-ов.<br><br>https://habr.com/ru/company/otus/blog/453664/</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R75" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">76</div></th><td class="s7">❖ Пользователь вводит в форму и отправляет логин и пароль. ❖ UsernamePasswordAuthenticationFilter создает объект Authentication - UsernamePasswordAuthenticationToken, где в качестве Principal - логин, а в качестве Credentials - пароль. ❖ Затем UsernamePasswordAuthenticationToken передаёт объект Authentication с логином и паролем AuthenticationManager-у. ❖ AuthenticationManager в виде конкретного класса ProviderManager внутри своего списка объектов AuthenticationProvider, имеющих разные логики аутентификации, пытается аутентифицировать посетителя, вызывая его метод authenticate(). У каждого AuthenticationProvider-а: ➢ Метод authenticate() принимает в качестве аргумента незаполненный объект Authentication, например только с логином и паролем, полученными в форме логина на сайте. Затем с помощью UserDetailsService метод идёт в БД и ищет такого пользователя. ➢ Если такой пользователь есть в БД, AuthenticationProvider получает его из базы в виде объекта UserDetails. Объект Authentication заполняется данными из UserDetails - в него включаются Authorities, а в Principal записывается сам объект UserDetails, содержащий пользователя. ➢ Затем этот метод возвращает заполненный объект Authentication (прошли аутентификацию). Вызывается AuthenticationSuccessHandler. ➢ Если логин либо пароль неверные, то выбрасывается исключение. Вызывается AuthenticationFailureHandler. ❖ Затем этот объект Authentication передается в AccessDecisionManager и получаем решение на получение доступа к запрашиваемой странице (проходим авторизацию).</td><td class="s18">PasswordEncoder - интерфейс для шифрования/расшифровывания паролей. Одна из популярных реализаций - BCryptPasswordEncoder.                                                                   В случае, если нам необходимо добавить логику при успешной/неудачной аутентификации, мы можем создать класс и имплементировать интерфейсы AuthenticationSuccessHandler и AuthenticationFailureHandler соответственно, переопределив их методы.</td><td class="s10">Процесс аутентификации: 1. UsernamePasswordAuthenticationFilter получают имя пользователя и пароль и создает экземпляр класса UsernamePasswordAuthenticationToken (экземпляр интерфейса Authentication). 2. Токен передается экземпляру AuthenticationManager для проверки. 3. AuthenticationManager возвращает полностью заполненный экземпляр Authentication в случае успешной аутентификации. 4. Устанавливается контекст безопасности путем вызова SecurityContextHolder.getContext().setAuthentication(...), куда передается вернувшийся экземпляр Authentication. 5. При успешной аутентификации можно использовать successHandler</td></tr><tr style="height: 20px"><th id="0R76" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">77</div></th><td class="s2" rowspan="17">Что такое SpringBoot? Какие у него преимущества? Как конфигурируется? Подробно.</td><td class="s3"><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Spring Boot - это модуль Spring-а, который предоставля</span><span style="font-size:10pt;font-family:Arial;color:#000000;">ет функцию RAD для среды Spring (Rapid Application Development - </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Быстрая разработка приложений</span><span style="font-size:10pt;font-family:Arial;color:#000000;">). Он обеспечивает более простой и быстрый способ настройки и запуска как обычных, так и веб-приложений. Он просматривает наши пути к классам и настроенные нами бины, делает разумные предположения о том, чего нам не хватает, и добавляет эти элементы.<br><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Ключевые особенности и преимущества Spring Boot:</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R77" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">78</div></th><td class="s18">1. Простота управления зависимостями (spring-boot-starter-* в pom.xml).</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R78" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">79</div></th><td class="s10">Чтобы ускорить процесс управления зависимостями Spring Boot неявно упаковывает необходимые сторонние зависимости для каждого типа приложения на основе Spring и предоставляет их разработчику в виде так называемых starter-пакетов.<br>Starter-пакеты представляют собой набор удобных дескрипторов зависимостей, которые можно включить в свое приложение. Это позволяет получить универсальное решение для всех технологий, связанных со Spring, избавляя программиста от лишнего поиска необходимых зависимостей, библиотек и решения вопросов, связанных с конфликтом версий различных библиотек.<br>Например, если вы хотите начать использовать Spring Data JPA для доступа к базе данных, просто включите в свой проект зависимость spring-boot-starter-data-jpa.<br>Starter-пакеты можно создавать и свои.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R79" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">80</div></th><td class="s18">2. Автоматическая конфигурация.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R80" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">81</div></th><td class="s10"><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Автоматическая конфигурация включается аннотацией @EnableAutoConfiguration.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> (входит в состав аннотации<br>@SpringBootApplication)<br>После выбора необходимых для приложения starter-пакетов Spring Boot попытается автоматически настроить Spring-приложение на основе выбранных jar-зависимостей, доступных в classpath классов, свойств в application.properties и т.п. Например, если добавим springboot-starter-web, то Spring boot автоматически сконфигурирует такие бины как DispatcherServlet, ResourceHandlers, MessageSource итд<br>Автоматическая конфигурация работает в последнюю очередь, после регистрации пользовательских бинов и всегда отдает им приоритет. Если ваш код уже зарегистрировал бин DataSource — автоконфигурация не будет его переопределять.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R81" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">82</div></th><td class="s18">3. Встроенная поддержка сервера приложений/контейнера сервлетов (Tomcat, Jetty).</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R82" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">83</div></th><td class="s10">Каждое Spring Boot web-приложение включает встроенный web-сервер. Не нужно беспокоиться о настройке контейнера сервлетов и развертывания приложения в нем. Теперь приложение может запускаться само как исполняемый .jar-файл с использованием встроенного сервера.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R83" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">84</div></th><td class="s18">4.        Готовые к работе функции, такие как метрики, проверки работоспособности, security и внешняя конфигурация.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R84" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">85</div></th><td class="s18">5.        Инструмент CLI (command-line interface) для разработки и тестирования приложения Spring Boot.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R85" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">86</div></th><td class="s11">6.        Минимизация boilerplate кода (код, который должен быть включен во многих местах практически без изменений), конфигурации XML и аннотаций.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R86" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">87</div></th><td class="s11">Как происходит автоконфигурация в Spring Boot:</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R87" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">88</div></th><td class="s10">1.        Отмечаем main класс аннотацией @SpringBootApplication (аннотация инкапсулирует в себе: @SpringBootConfiguration, @ComponentScan, @EnableAutoConfiguration), таким образом наличие @SpringBootApplication включает сканирование компонентов, автоконфигурацию и показывает разным компонентам Spring (например, интеграционным тестам), что это Spring Boot приложение.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R88" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">89</div></th><td class="s10">2.        @EnableAutoConfiguration         импортирует         класс EnableAutoConfigurationImportSelector. Этот класс не объявляет бины сам, а использует фабрики.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R89" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">90</div></th><td class="s10">3.        Класс EnableAutoConfigurationImportSelector импортирует ВСЕ (более 150) перечисленные в META-INF/spring.factories конфигурации,  Каждая из этих конфигураций пытается сконфигурировать различные аспекты приложения (web, JPA, AMQP и т.д.), регистрируя нужные бины в контекст приложения.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R90" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">91</div></th><td class="s10">4.        Логика при регистрации бинов управляется набором @ConditionalOn* аннотаций. Можно указать, чтобы бин создавался при наличии класса в classpath (@ConditionalOnClass), наличии существующего бина (@ConditionalOnBean), отсуствии бина (@ConditionalOnMissingBean) и т.п. Таким образом наличие конфигурации не значит, что бин будет создан и зачастую конфигурация ничего делать и создавать не будет.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R91" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">92</div></th><td class="s10">5.        Созданный в итоге <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">AnnotationConfig</span><span style="font-size:10pt;font-family:Arial;color:#000000;">EmbeddedWeb</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ApplicationContext</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> ищет в том же DI контейнере фабрику для запуска embedded servlet container.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R92" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">93</div></th><td class="s3">6.        Servlet container запускается, приложение готово к работе</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R93" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">94</div></th><td class="s2">Расскажите про нововведения Spring 5.</td><td class="s3">●        Используется JDK 8+ (Optional, CompletableFuture, Time API, java.util.function, default methods)<br>●        Поддержка Java 9 (Automatic-Module-Name in 5.0, module-info in 6.0+, ASM 6)<br>●        Поддержка HTTP/2 (TLS, Push), NIO/NIO.2<br>●        Поддержка Kotlin<br>●        Реактивность (веб-инфраструктура с реактивным стеком, «Spring WebFlux»)<br>●        Null-safety аннотации(@Nullable), новая документация<br>●        Совместимость с Java EE 8 (Servlet 4.0, Bean Validation 2.0, JPA 2.2, JSON Binding API 1.0)<br>●        Поддержка JUnit 5 + Testing Improvements (conditional and concurrent)<br>●        Удалена поддержка: Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R94" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">95</div></th><td class="s2"> Расскажите про аннотацию @ComponentScan</td><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Аннотация @ComponentScan используется вместе с аннотацией @Configuration для указания пакетов, которые мы хотим сканировать на наличие компонентов, из которых нужно сделать бины.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@ComponentScan без аргументов указывает Spring по умолчанию сканировать текущий пакет и все его подпакеты.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Текущий пакет - тот, в котором находится файл конфигурации с этой самой аннотацией @ComponentScan. В данном случае в контейнер попадут: ❖ бин конфигурационного класса; ❖ бины, объявленные в конфигурационном классе с помощью @Bean; ❖ все бины из пакета и его подпакетов. Аннотация @SpringBootApplication включает в себя аннотации @ComponentScan, @SpringBootConfiguration и @EnableAutoConfiguration, но это не мешает разместить её ещё раз отдельно для указания конкретного пакета. Если указать @ComponentScan с атрибутом basePackages, то это изменит пакет по умолчанию на указанный</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R95" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">96</div></th><td class="s1"></td><td class="s18">Java Servlet API — стандартизированный API, предназначенный для реализации на сервере и работе с клиентом по схеме запрос-ответ. Сервлет — это класс, который умеет получать запросы от клиента и возвращать ему ответы. Да, сервлеты в Java — именно те элементы, с помощью которых строится клиент-серверная архитектура.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R96" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">97</div></th><td class="s20">Что делает аннотация @RequestMapping?</td><td class="s21"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#111111;">Используется только для указания URI до класса-контроллера.</span><span style="font-size:10pt;font-family:Arial;color:#111111;"> @RestController<br>@RequestMapping(&quot;/api/coupon&quot;)</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R97" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">98</div></th><td class="s20">Аннотация @RequestParam?</td><td class="s10"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Эта аннотация используется для того, чтобы методы обработчики могли получить параметры из http-запроса. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Запрос с параметрами: http://localhost:8080/getByName/name=Ivan. Следующий код поместит в переменную name строку Ivan.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R98" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">99</div></th><td class="s20">Аннотация @PathVariable?</td><td class="s10">Эта <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">аннотация получает определенную часть из URI</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. URI: http://localhost:8080/getById/23 Следующий код поместит в переменную id значение 23.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R99" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">100</div></th><td class="s20">@RequestBody?</td><td class="s10">@RequestBody, Spring на лету попытается преобразовать содержимое тела входящего запроса в ваш объект параметра.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R100" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">101</div></th><td class="s20">Аннотация @ResponseStatus?</td><td class="s21">Она позволяет устанавливать код ответа. Обычно Spring сам устанавливает нужный код ответа, но бывают моменты, когда это нужно переопределить.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R101" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">102</div></th><td class="s20">RestTemplate? Какие у него преимущества?</td><td class="s10">RestTemplate это специальный клиент в Spring для отправки http-запросов. Он предоставляет удобные API для легкого вызова конечных точек REST’а в одну строку.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R102" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">103</div></th><td class="s20">GET_POST_PUT_DELETE_PATCH</td><td class="s10">@GetMapping — Обрабатывает get-запросы(чтение) @PostMapping — Обрабатывает post-запросы (создание)@DeleteMapping — Обрабатывает delete-запросы @PutMapping — Обрабатывает put-запросы(обновление) @PatchMapping — Обрабатывает patch-запросы</td><td class="s10">PUT — изначально существовавший в стандарте метод, предполагающий полную замену изменяемого объекта. Соответственно в методе PUT, как я и писал выше, придётся указать даже те атрибуты объекта, которые не меняются.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R103" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">104</div></th><td class="s20">@GetMapping</td><td class="s10">Аннотация @GetMapping — это просто аннотация которая содержит @RequestMapping(method = RequestMethod.GET). Она также позволяет более глубоко настроить метод-обработчик. Ее параметры(они конвертируются в аналогичные параметры @RequestMapping):<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> path — URI, headers — заголовки, name — имя обработчика params — параметры , produces — тип возвращаемых данных(JSON, XML, текст). Используется в REST, consumes — тип принимаемых данных. Используется в REST</span></td><td class="s1">@ApiOperation — описывает метод контроллера</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R104" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">105</div></th><td class="s20">Что обозначают разные коды для http-ответов?</td><td class="s10">GET — 200 OK POST — 200 OK, 201 Created, 204 No Content PUT — 200 OK, 201 Created, 204 No Content DELETE — 204 No Content, 202 Accepted</td><td class="s1"></td><td class="s1"></td></tr></tbody></table></div>