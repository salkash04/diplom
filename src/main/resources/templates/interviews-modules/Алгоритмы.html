<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link type="text/css" rel="stylesheet" href="../../../../../../../../Users/Салават/Downloads/_Алгоритмы_/resources/sheet.css" >
<style type="text/css">.ritz .waffle a { color: inherit; }.ritz .waffle .s18{border-right:none;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s24{background-color:#ffffff;text-align:left;color:#008000;font-family:docs-Consolas,Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s9{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s21{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s8{border-bottom:3px SOLID #3c78d8;border-right:1px SOLID #000000;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s19{border-left:none;border-right:none;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s2{border-bottom:1px SOLID #000000;border-right:1px SOLID transparent;background-color:#3d85c6;text-align:center;font-weight:bold;color:#ffffff;font-family:Arial;font-size:14pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s20{background-color:#ffffff;text-align:left;font-weight:bold;color:#333333;font-family:Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s15{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s27{border-right:1px SOLID transparent;background-color:#c9daf8;text-align:left;font-weight:bold;color:#1c4587;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s4{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s29{background-color:#ffffff;text-align:center;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s30{background-color:#ffffff;text-align:left;color:#111111;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s12{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#c9daf8;text-align:center;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s23{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#ff0000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s3{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID #000000;background-color:#c9daf8;text-align:center;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s1{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s25{border-right:none;background-color:#ffffff;text-align:left;color:#333333;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s10{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID #000000;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s16{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#d9d2e9;text-align:center;font-weight:bold;color:#1c4587;font-family:Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s0{border-bottom:1px SOLID transparent;border-right:1px SOLID transparent;background-color:#3d85c6;text-align:left;font-weight:bold;color:#ffffff;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s26{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s13{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s6{background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s22{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;font-weight:bold;color:#ff0000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s28{border-bottom:3px SOLID #4a86e8;border-right:1px SOLID transparent;background-color:#c9daf8;text-align:left;font-weight:bold;color:#1c4587;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s5{background-color:#ffffff;text-align:left;font-weight:bold;color:#000000;font-family:Arial;font-size:11pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s14{border-bottom:3px SOLID #4a86e8;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s17{background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s11{background-color:#ffffff;text-align:right;color:#000000;font-family:Arial;font-size:10pt;vertical-align:bottom;white-space:normal;overflow:hidden;word-wrap:break-word;direction:ltr;padding:2px 3px 2px 3px;}.ritz .waffle .s7{border-bottom:1px SOLID #000000;background-color:#ffffff;text-align:left;color:#000000;font-family:Arial;font-size:10pt;vertical-align:top;white-space:nowrap;direction:ltr;padding:2px 3px 2px 3px;}</style><div class="ritz grid-container" dir="ltr"><table class="waffle" cellspacing="0" cellpadding="0"><thead><tr><th class="row-header freezebar-origin-ltr"></th><th id="0C0" style="width:159px;" class="column-headers-background">A</th><th id="0C1" style="width:841px;" class="column-headers-background">B</th><th id="0C2" style="width:459px;" class="column-headers-background">C</th><th id="0C3" style="width:100px;" class="column-headers-background">D</th></tr></thead><tbody><tr style="height: 20px"><th id="0R0" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">1</div></th><td class="s0" colspan="2"> </td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R1" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">2</div></th><td class="s2" colspan="2"> Алгоритмы</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R2" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">3</div></th><td class="s3" rowspan="4">Что такое Big O? Как происходит оценка асимптотической сложности алгоритмов?</td><td class="s4">Big O (O большое / символ Ландау)  - математическое обозначение порядка функции для сравнения асимптотического поведения функций.  <br>Асимптотика - характер изменения функции при стремлении ее аргумента к определённой точке. <br>Любой алгоритм состоит из неделимых операций процессора(шагов), поэтому нужно измерять время в операциях процессора, вместо секунд.<br>DTIME - количество шагов(операций процессора), необходимых, чтобы алгоритм завершился.</td><td class="s5">Big O нотация нужна для описания сложности алгоритмов.Сложность алгоритма состоит из двух факторов: временная сложность и сложность по памяти.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R3" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">4</div></th><td class="s4">Временная сложность обычно оценивается путём подсчёта числа элементарных операций, осуществляемых алгоритмом. Время исполнения одной такой операции при этом берётся константой, то есть асимптотически оценивается как O(1).  С<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ложность алгоритма состоит из двух факторов: временная сложность и сложность по памяти.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Временная сложность - </span><span style="font-size:10pt;font-family:Arial;color:#000000;">функция, представляющая зависимость количество операций процессора, необходимых, чтобы алгоритм звершился, от размера входных данных. Все неделимые операции языка(операции сравнения, арифметические, логические, инициализации и возврата) считаются выполняемыми за 1 операцию процесора, эта погрешность считается приемлемой. При росте N, слагаемые с меньшей скорость роста всё меньше влияют на значение функции. Поэтому, вне зависимости от констант при слагаемых, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">слагаемое с большей скорость роста определяет значение функии. Данное слагаемое называют</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">порядком функции.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Пример: Т(N) = </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">5 * N^2</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> + 999 * N... Где (5 * N^2) и (9999 * N) являются слагаемыми функции. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Константы(5 и 999) не указываются в рамках нотации Big O, так как не показывают абсолютную сложность алгоритма, так как могут изменяться в зависимости от машины, поэтому сложность равна О(N^2)</span></td><td class="s6">c </td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R4" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">5</div></th><td class="s7"></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R5" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">6</div></th><td class="s8">В порядке возрастания сложности: <br>1. O(1) - константная, чтение по индексу из массива<br>2. O(log(n)) - логарифмическая, бинарный поиск в отсортированном массиве <br>3. O(√n) - сублинейная<br>4. O(n) - линейная, перебор массива в цикле, два цикла подряд, линейный поиск наименьшего или наибольшего элемента в неотсортированном массиве<br>5. O(n*log(n)) - квазилинейная,быстрая сортировка, сортировка слиянием, сортировка кучей<br>6. O(n^2) - полиномиальная(квадратичная), вложенный цикл, перебор двумерного массива, сортировка пузырьком, сортировка вставками<br>7. O(2^n) - экспоненциальная, алгоритмы разложения на множители целых чисел(последовательность фибоначи)<br>8. O(n!) - факториальная, решение задачи коммивояжёра полным перебором<br><br><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Алгоритм считается приемлемым, если сложность не превышает O(n*log(n)), иначе говнокод.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R6" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">7</div></th><td class="s3" rowspan="2">Что такое рекурсия? Сравните преимущества и недостатки итеративных и рекурсивных алгоритмов. С примерами.</td><td class="s8">Рекурсия - способ отображения какого-либо процесса внутри самого этого процесса, то есть ситуация, когда процесс является частью самого себя.<br>Рекурсия состоит из базового случая и шага рекурсии. Базовый случай представляет собой самую простую задачу, которая решается за одну итерацию, например, if(n == 0) return 1.<br>В базовом случае обязательно  присутствует условие выхода из рекурсии; <br>Смысл рекурсии в движении от исходной задачи к базовому случаю, пошагово уменьшая размер исходной задачи на каждом шаге рекурсии. <br><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">После того, как будет найден базовый случай, срабатывает условие выхода из рекурсии, и </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">стек рекурсивных вызовов разворачивается в обратном порядке</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">пересчитывая результат исходной задачи</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">, который основан на результате, найденном в базовом случае. </span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Так работает рекурсивное вычисление факториала:<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">int factorial(int n) {<br>        if(n == 1 || n == 0) return 1;                    </span><span style="font-size:10pt;font-family:Arial;color:#000000;">// базовый случай с условием выхода</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><br>        else return n * factorial(n - 1); </span><span style="font-size:10pt;font-family:Arial;color:#000000;">// шаг рекурсии (рекурсивный вызов)</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><br>    }<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;">Или даже так:<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">return (n == 1 || n == 0) ? 1 : n * factorial(n-1);<br>Рекурсия имеет линейную сложность O(n);</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R7" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">8</div></th><td class="s9"><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Циклы дают лучшую производительность, чем рекурсивные вызовы, поскольку вызовы методов потребляют больше ресурсов, чем исполнение обычных операторов. </span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Циклы гарантируют отсутствие переполнения стека, т.к. не требуется выделения доп. памяти.<br>В случае рекурсии стек вызовов разрастается, и его необходимо просматривать для получения конечного ответа. <br>При использовании головной рекурсии также необходимо принимать во внимание размер стека.<br>Если уровней вложненности много или изменятся, то предпочительна рекурсия. Если их несколько, то лучше цикл.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R8" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">9</div></th><td class="s3">Что такое жадные алгоритмы? Приведите пример.</td><td class="s10">Жадные алгоритмы являются одной из <span style="font-size:10pt;font-family:Arial;color:#ff0000;">3х техник создания алгоритмов, вместе с принципом &quot;Разделяй и властвуй&quot; и динамическим программированием.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Жадный алгоритм - это алгоритм, который на каждом шагу совершает локально оптимальные решения, т.е</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">. максимально возможное из допустимых, не учитывая предыдущие или следующие шаги</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">. Последовательность этих локально оптимальных решений приводит (не всегда) к глобально оптимальному решению.<br>Т.е. задача рабивается на подзадачи, в каждой подзадаче делается оптимальное решение и, в итоге, вся задача решается оптимально. При этом важно является ли каждое локальное решение безопасным шагом. Безопасный шаг - приводящий к оптимальному решению.<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;">К примеру, алгоритм Дейкстры нахождения кратчайшего пути в графе вполне себе жадный, потому что мы на каждом шагу ищем вершину с наименьшим весом, в которой мы еще не бывали, после чего обновляем значения других вершин. При этом можно доказать, что кратчайшие пути, найденные в вершинах, являются оптимальными.</span></td><td class="s1"></td><td class="s11">ON представляет собой одно или несколько условий JOIN благодаря которым мы можем сопоставлять записи из одной таблицы в другую.Это не оператор - это часть JOIN, которая является частью предложения FROM Он очень похож на предложение WHERE - за исключением того, что он предназначен только для фильтрации объединения двух таблиц (или наборов строк). В этом случае это условие, при котором строки из A и B сопоставляются. Если у вас были те же условия в WHERE, это повлияло бы на соединение - LEFT JOIN (здесь) разрешено находить несоответствующую строку в B но все равно будет вносить эту строку из A в результат (при этом столбцы B равны NULL). Если вы помещаете такое же условие в WHERE, это заставляет соединение стать INNER JOIN вместо LEFT JOIN.                                                                                                                                   NATURAL JOIN  - может работать без ON<br>        SELECT *<br>                FROM actor<br>        NATURAL JOIN film_actor<br>        NATURAL JOIN film</td></tr><tr style="height: 20px"><th id="0R9" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">10</div></th><td class="s12">Расскажите про пузырьковую сортировку.</td><td class="s13">Будем идти по массиву слева направо. Если текущий элемент больше следующего, меняем их местами. Делаем так, пока массив не будет отсортирован.<br>Aсимптотика в худшем и среднем случае – O(n^2), в лучшем случае – O(n) - массив уже отсортирован.  </td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R10" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">11</div></th><td class="s12">Расскажите про быструю сортировку.</td><td class="s13">Выберем некоторый опорный элемент(pivot). После этого перекинем все элементы, меньшие его, налево, а большие – направо. Для этого используются дополнительные переменные - значения слева и справа, которые сравниваются с pivot. Рекурсивно вызовемся от каждой из частей, где будет выбран новый pivot. В итоге получим отсортированный массив, так как каждый элемент меньше опорного стоял раньше каждого большего опорного. <br>Асимптотика: O(n*log(n)) в среднем и лучшем случае. Наихудшая оценка O(n^2) достигается при неудачном выборе опорного элемента. </td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R11" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">12</div></th><td class="s12">Расскажите про сортировку слиянием.</td><td class="s13"><span style="font-size:10pt;font-family:Arial;color:#000000;">Основана на парадигме «разделяй и властвуй». Будем делись массив пополам, пока не получим множество массивов из одного элемента. После чего выполним процедуру слияния: поддерживаем два указателя, один на текущий элемент первой части, второй – на текущий элемент второй части. Из этих двух элементов выбираем минимальный, вставляем в ответ и сдвигаем указатель, соответствующий минимуму. Так сделаем слияния массивов из 1го элемента в массивы по 2 элемента, затем из 2х в 4 и т.д. Слияние работает за O(n), уровней всего log(n), поэтому </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">асимптотика O(n*log(n))</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. </span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R12" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">13</div></th><td class="s12">Расскажите про бинарное дерево.</td><td class="s13">Бинарное дерево - иерархическая структура данных, в которой каждый узел может иметь двух потомков. Как правило, первый называется родительским узлом, а наследники называются левым и правым нодами/узлами. Каждый узел в дереве задаёт поддерево, корнем которого он является. Оба поддерева — левое и правое — тоже являются бинарными деревьями. Ноды, которые не имеют потомков, называются листьями дерева. У всех узлов левого поддерева произвольного узла X значения ключей данных меньше, нежели значение ключа данных самого узла X. У всех узлов правого поддерева произвольного узла X значения ключей данных больше либо равны, нежели значение ключа данных самого узла X. Этим достигается упорядоченная структура данных, то есть всегда отсортированная.<br>Поиск в лучшем случае - O(log(n)), худшем - O(n) -  при вырождении в связанный список.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R13" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">14</div></th><td class="s12">Расскажите про красно-черное дерево.</td><td class="s13">Усовершенствованная версия бинарного дерева. Каждый узел в к/ч дереве имеет дополнительное поле - цвет. К/ч дерево отвечает следующим требованиям:<br>1) Узел либо красный, либо черный.<br>2) Корень - черный.<br>3) Все листья - черные и не хранят данных.<br>4) Оба потомка каждого красного узла - черные.<br>5) Любой простой путь от узла-предка до листового узла-потомка содержит одинаковое число черных узлов. Если не одинаковое, то происходит переворот.<br>При добавлении постоянно увеличивающихся/уменьшающихся чисел в бинарное дерево, оно вырождается в связанный список и теряет свои преимущества. Тогда как к/ч дерево может потребовать до двух поворотов для поддержки сбалансированности, чтобы избежать вырождения.<br>При операциях удаления в бинарном дереве для удаляемого узла надо найти замену. К/ч дерево сделает тоже самое, но потребует до трёх поворотов для поддержки сбалансированности.<br>В этом и состоит преимущство.<br>Сложность поиска, вставки и удаления - O(log(n))</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R14" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">15</div></th><td class="s12" rowspan="2">Расскажите про линейный и бинарный поиск.</td><td class="s4">Линейный поиск - сложность O(n), так как все элементы проверяются по очереди.  <br>Бинарный поиск - O(log(n)). Массив должен быть отсортирован. Происходит поиск индекса в массиве, содержащего искомое значение.<br>1) Берем значение из середины массива и сраваем с искомым. Индекс середины считается по формуле mid = (high + low) / 2<br>low - индекс начала левого подмассива, high - индекс конца правого подмассива.<br>2) Если значение в середине больше искомого, то рассматриваем левый подмассив и high = middle - 1<br>3) Если меньше, то правый и low = middle + 1<br>4) Повторяем, пока mid не страновится равен искомому элементу или подмассив не станет пустым.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R15" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">16</div></th><td class="s13">    public static int binarySearch(int[] a, int key) {<br>        int low = 0;<br>        int high = a.length - 1;<br><br>        while (low &lt;= high) {<br>            int mid = (low + high)/2;<br><br>            if (key &gt; a[mid]) {<br>                low = mid + 1;<br>            } else if (key &lt; a[mid]) {<br>                high = mid - 1;<br>            } else return mid;<br>        }<br>        return -1;<br>    }</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R16" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">17</div></th><td class="s12">Расскажите про очередь и стек.</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Стек</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> реализует принцип «last in - first out», т.е. «последним пришёл - первым вышел». Аналогия из реального мира - это стопка книг на столе (сначала берём верхнюю). В Java есть одноимённый класс Stack. Добавление элементов осуществляется методом push(), а удаление методом pop().<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Queue </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- это очередь, которая обычно (но необязательно) строится по принципу FIFO (First-In-First-Out) - соответственно извлечение элемента осуществляется с начала очереди, вставка элемента - в конец очереди. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">(Добавляется в конец очереди используется из начала)</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Хотя этот принцип нарушает, к примеру PriorityQueue, использующая «natural ordering» или переданный Comparator при вставке нового элемента. <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Deque </span><span style="font-size:10pt;font-family:Arial;color:#000000;">(Double Ended Queue) расширяет Queue и согласно документации это линейная коллекция, поддерживающая вставку/извлечение элементов с обоих концов. Помимо этого реализации интерфейса Deque могут строится по принципу FIFO, либо LIFO.                                                                                Количество методов удваивается. Пример:<br> addFirst(E e);<br> addLast(E e);<br>Реализации и Deque, и Queue обычно не переопределяют методы equals() и hashCode(), вместо этого используются унаследованные методы класса Object, основанные на сравнении ссылок. </span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R17" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">18</div></th><td class="s12">Сравните сложность вставки, удаления, поиска и доступа по индексу в ArrayList и LinkedList.</td><td class="s14"></td><td class="s15"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R18" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">19</div></th><td class="s12">Расскажите про паттерн Цепочка обязанностей (Chain of Responsibility).</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Поведенческий паттерн проектирования, позволяет передавать запрос по цепочке потенциальных обработчиков, пока один из них не обработает запрос. Каждый обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи  </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Область применения цепочки обязанностей — всевозможные обработчики событий, последовательные проверки доступа и прочее.</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;color:#000000;">Базируется на том, чтобы превратить каждую проверку в отдельный класс с единственным методом выполнения. Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы.<br>Каждый из методов будет иметь ссылку на следующий метод-обработчик, что образует цепь. Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке. Может и не передавать, если проверка в одном из методов не прошла, например.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R19" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">20</div></th><td class="s12">Какие паттерны используются в Spring Framework?</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Singleton </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Bean scopes<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Factory </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Bean Factory classes<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Prototype </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Bean scopes<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Adapter </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Spring Web and Spring MVC<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Proxy </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Spring Aspect Oriented Programming support<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Template Method </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- JdbcTemplate, HibernateTemplate etc<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Front Controller </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- Spring MVC DispatcherServlet<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">DAO</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - Spring Data Access Object support<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Dependency Injection</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R20" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">21</div></th><td class="s12">Какие паттерны используются в Hibernate?</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Domain Model</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> – объектная модель предметной области, включающая в себя как поведение так и данные.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Data Mapper</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> – слой мапперов (Mappers), который передает данные между объектами и базой данных, сохраняя их независимыми друг от друга и себя.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Proxy  </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— применяется для ленивой загрузки.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Factory </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— используется в SessionFactory</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R21" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">22</div></th><td class="s16">Шаблоны GRASP: Low Coupling (низкая связанность) и High Cohesion (высокая сплоченность)</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Low Coupling</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - части системы, которые изменяются вместе, должны находиться близко друг к другу. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Необходимо распределить ответственности между классами так, чтобы обеспечить минимальную связанность.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">High Cohesion</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - если возвести Low Coupling в абсолют, то можно прийти к тому, чтобы разместить всю функциональность в одном единственном классе.</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">классы должны содержать связанную бизнес — логику</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. В таком случае связей не будет вообще, но что-то тут явно не так, ведь в этот класс попадет совершенно несвязанная между собой бизнес-логика. Принцип High Cohesion говорит следующее: части системы, которые изменяются параллельно, должны иметь как можно меньше зависимостей друг на друга.<br><br>Low Coupling и High Cohesion представляют из себя два связанных между собой паттерна, рассматривать которые имеет смысл только вместе. Их суть: </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">система должна состоять из слабо связанных классов, которые содержат связанную бизнес-логику.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Соблюдение этих принципов позволяет удобно переиспользовать созданные классы, не теряя понимания о их зоне ответственности.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R22" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">23</div></th><td class="s16">Расскажите про паттерн Saga</td><td class="s9"><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Сага — это механизм, обеспечивающий согласованность данных в микросервисах без применения распределенных транзакций.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br><br>Для каждой системной команды, которой надо обновлять данные в нескольких сервисах, создается некоторая сага. Сага представляет из себя некоторый «чек-лист», состоящий из последовательных локальных ACID-транзакций, каждая из которых обновляет данные в одном сервисе. Для обработки сбоев применяется компенсирующая транзакция. Такие транзакции выполняются в случае сбоя на всех сервисах, на которых локальные транзакции выполнились успешно.<br><br>Типов транзакций в саге четыре:<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Компенсирующая </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— отменяет изменение, сделанное локальной транзакцией.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Компенсируемая </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— это транзакция, которую необходимо компенсировать (отменить) в случае, если последующие транзакции завершаются неудачей.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Поворотная </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— транзакция, опеределяющая успешность всей саги. Если она выполняется успешно, то сага гарантированно дойдет до конца.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Повторяемая </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— идет после поворотной и гарантированно завершается успехом.</span></td><td class="s17"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Существует два способа координации саг: </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Хореография (Choreography) — каждая транзакция публикует события, которые запускают транзакции в других сервисах.<br>Существует два способа координации саг: Оркестровка (Orchestration) — оркестратор говорит участникам, какие транзакции должны быть запущены.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R23" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">24</div></th><td class="s12">Как мапятся даты (до java 8 и после)?</td><td class="s13">Аннотация <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Temporal</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> до Java 8, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">в которой надо было указать какой тип даты мы хотим использовать.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>В Java 8 и далее аннотацию ставить не нужно. java.time Все классы в новом API неизменяемые (immutable) и, как следствие,<br>потоко-безопасные. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Точность представления времени составляет одну наносекунду,</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>что в миллион раз точнее чем в пакете java.util.</span></td><td class="s18 softmerge"><div class="softmerge-inner" style="width:657px;left:-1px">Тип java.util.Date содержит информацию о дате и времени с точностью до миллисекунд.</div></td><td class="s19"></td></tr><tr style="height: 20px"><th id="0R24" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">25</div></th><td class="s12">Как “смапить” коллекцию примитивов?</td><td class="s13"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@ElementCollection<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;"> @OrderBy<br>Если у нашей сущности есть поле с коллекцией, то мы привыкли ставить над ним аннотации @OneToMany либо @ManyToMany. Но данные аннотации применяются в случае, когда это коллекция других сущностей (entities). </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Если у нашей сущности коллекция не других сущностей, а базовых или встраиваемых (embeddable) типов</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> для этих случаев в JPA имеется специальная аннотация </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@ElementCollection, которая указывается в классе сущности над полем коллекции</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">. Все записи коллекции хранятся в отдельной таблице, то есть в итоге получаем две таблицы: одну для сущности, вторую для коллекции элементов.<br>При добавлении новой строки в коллекцию, она полностью очищается и заполняется заново, так как у элементов нет id. Можно решить с помощью @OrderColumn<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;"> @CollectionTable - позволяет редактировать таблицу с коллекцией, прочитать</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R25" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">26</div></th><td class="s12" rowspan="3">Какие есть виды связей?</td><td class="s13">Существуют 4 типа связей:<br>1. OneToOne - когда один экземпляр Entity может быть связан не больше чем с одним экземпляром другого Entity.<br>2. OneToMany - когда один экземпляр Entity может быть связан с несколькими экземплярами других Entity.<br>3. ManyToOne - обратная связь для OneToMany. Несколько экземпляров Entity могут быть связаны с одним экземпляром другого Entity.<br>4. ManyToMany - экземпляры Entity могут быть связаны с несколькими экземплярами друг друга.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R26" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">27</div></th><td class="s13">Каждую из которых можно разделить ещё на два вида:<br><span style="font-size:10pt;font-family:Arial;font-weight:bold;">1. Bidirectional </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Владеемая сторона в двунаправленных отношениях должна ссылаться на владеющую сторону используя элемент mappedBy аннотаций @OneToOne, @OneToMany, или @ManyToMany. Элемент mappedBy определяет поле в объекте, который является владельцем отношения.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;">2. Undirectional</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">В однонаправленных отношениях только одна сущность имеет поле, которое ссылается на вторую сущность. Вторая сущность (сторона) не имеет поля первой сущности и не знает об отношениях. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Элемент mappedBy определяет поле в объекте, который является владельцем отношения.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R27" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">28</div></th><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Bidirectional (Двунаправленные отношения) </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— ссылка на связь устанавливается у всех Entity, то есть в случае OneToOne A-B в Entity A есть ссылка на Entity B, в Entity B есть ссылка на Entity A. Entity A считается владельцем этой связи (это важно для случаев каскадного удаления данных, тогда при удалении A также будет удалено B, но не наоборот).<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Undirectional</span><span style="font-size:10pt;font-family:Arial;color:#000000;">- ссылка на связь устанавливается только с одной стороны, то есть в случае OneToOne A-B только у Entity A будет ссылка на Entity B, у Entity B ссылки на A не будет.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R28" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">29</div></th><td class="s12">Что такое владелец связи?</td><td class="s13">В отношениях между двумя сущностями всегда есть одна владеющая сторона, а владеемой может и не быть, если это однонаправленные отношения.<br>По сути, <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">у кого есть внешний ключ на другую сущность - тот и владелец связи</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">То есть, если в таблице одной сущности есть колонка, содержащая внешние ключи от другой сущности, то первая сущность признаётся владельцем связи, вторая сущность - владеемой.<br>В однонаправленных отношениях сторона, которая имеет поле с типом другой сущности, является владельцем этой связи по умолчанию.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R29" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">30</div></th><td class="s12" rowspan="2">Что такое каскады?</td><td class="s4"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml">Каскадирование - это когда мы выполняем какое-то действие с целевой Entity, то же самое действие будет применено к связанной Entity.</a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="http://java-online.ru/concurrent.xhtml"><br>JPA CascadeType:<br>ALL -  гарантируют, что все персистентные события, которые происходят на родительском объекте, будут переданы дочернему объекту.<br>PERSIST -  означает, что операции save () или persist () каскадно передаются связанным объектам.<br>MERGE - означает, что связанные entity объединяются, когда объединяется entity-владелец.</a></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R30" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">31</div></th><td class="s13">REMOVE - удаляет все entity, связанные с удаляемой entity.<br>DETACH - отключает все связанные entity, если происходит «ручное отключение».<br>REFRESH - повторно считывают значение данного экземпляра и связанных сущностей из базы данных при вызове refresh().</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R31" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">32</div></th><td class="s12">Разница между PERSIST и MERGE?</td><td class="s13">persist(entity) следует использовать с совершенно новыми объектами, чтобы добавить их в БД (если объект уже существует в БД, будет выброшено исключение EntityExistsException).<br><br>Но в случае merge(entity) сущность, которая уже управляется в контексте персистентности, будет заменена новой сущностью (обновленной), и копия этой обновленной сущности вернется обратно. Но рекомендуется использовать для уже сохраненных сущностей.</td><td class="s20">orphanRemoval. Директива orphanRemoval объявляет, что связанные экземпляры сущностей должны быть удалены, когда они отсоединены от родителя, или эквивалентно, когда родитель удален</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R32" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">33</div></th><td class="s12">Какие два типа fetch стратегии в JPA вы знаете?</td><td class="s13">1) <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">LAZY </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Hibernate может загружать данные не сразу, а при первом обращении к ним</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, но так как это необязательное требование, то Hibernate имеет право изменить это поведение и загружать их сразу. Это поведение по умолчанию для полей, аннотированных @OneToMany, @ManyToMany и @ElementCollection. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">В объект загружается прокси lazy-поля.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>2) </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">EAGER</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">данные поля будут загруженны немедленно</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Это поведение по умолчанию для полей, аннотированных @Basic, @ManyToOne и @OneToOne.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R33" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">34</div></th><td class="s12">Какие четыре статуса жизненного цикла Entity объекта (Entity Instance’s Life Cycle) вы можете перечислить?</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Transient (New) — </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">свежесозданная оператором new() сущность не имеет связи с базой данных</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, не имеет данных в базе данных и не имеет сгенерированных первичных ключей.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- объект создан, сохранён в бд, имеет primary key, управляется JPA<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached </span><span style="font-size:10pt;font-family:Arial;color:#000000;">-объект создан, имеет primary key, не является (или больше не является) частью контекста персистентности (не управляется JPA);<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">-</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> </span><span style="font-size:10pt;font-family:Arial;">объект создан, у</span><span style="font-size:10pt;font-family:Arial;color:#000000;">правляется JPA, будет удален при commit-е и статус станет опять detached</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R34" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">35</div></th><td class="s12">Как влияет операция persist на Entity объекты каждого из четырех статусов?</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">new </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ managed, и объект будет сохранен в базу при commit-е транзакции или в результате flush операций<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ операция игнорируется, однако зависимые Entity могут поменять статус на managed, если у них есть аннотации каскадных изменений<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ exception сразу или на этапе commit-а транзакции<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ managed, но только в рамках одной транзакции. </span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R35" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">36</div></th><td class="s12">Как влияет операция remove на Entity объекты каждого из четырех статусов?</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">new </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ операция игнорируется, однако зависимые Entity могут поменять статус на removed, если у них есть аннотации каскадных изменений и они имели статус managed<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ removed и запись объект в базе данных будет удалена при commit-е транзакции (также произойдут операции remove для всех каскадно зависимых объектов)<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ exception сразу или на этапе commit-а транзакции<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ операция игнорируется</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R36" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">37</div></th><td class="s12">Как влияет операция merge на Entity объекты каждого из четырех статусов?</td><td class="s21">new → <span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#000000;">будет создана новая managed entity, в которую будут скопированы данные<br>объекта.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed → </span><span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#000000;">операция игнорируется, однако операция merge сработает на<br>каскадно зависимых entity, если их статус не managed.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed → </span><span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#000000;">exception сразу или на этапе commit-а транзакции.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached → </span><span style="font-size:10pt;font-family:Arial;font-weight:normal;color:#000000;">либо данные будут скопированы в существующую БД managed entity<br>с тем же пер</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R37" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">38</div></th><td class="s12">Как влияет операция refresh на Entity объекты каждого из четырех статусов?</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ будут восстановлены все изменения из базы данных данного Entity, также произойдет refresh всех каскадно зависимых объектов<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">new</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ exception<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R38" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">39</div></th><td class="s12">Как влияет операция detach на Entity объекты каждого из четырех статусов?</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">managed</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">removed </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ detached.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">new</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">detached </span><span style="font-size:10pt;font-family:Arial;color:#000000;">→ операция игнорируется<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R39" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">40</div></th><td class="s12" rowspan="2">Для чего нужна аннотация Basic?</td><td class="s13"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@Basic - указывает на простейший тип маппинга данных на колонку таблицы базы данных.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет. Может быть применена к полю любого из следующих типов:<br>1. Примитивы и их обертки.<br>2. java.lang.String<br>3. java.math.BigInteger<br>4. java.math.BigDecimal<br>5. java.util.Date<br>6. java.util.Calendar<br>7. java.sql.Date<br>8. java.sql.Time<br>9. java.sql.Timestamp<br>10. byte[] or Byte[]<br>11. char[] or Character[]<br>12. enums<br>13. любые другие типы, которые реализуют Serializable.<br></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Вообще, аннотацию @Basic можно не ставить, как это и происходит по умолчанию.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R40" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">41</div></th><td class="s13"> Аннотация @Basic определяет 2 атрибута:<br><br>1. optional - boolean (по умолчанию true) - определяет, может ли значение поля или свойства быть null. Игнорируется для примитивных типов. Но если тип поля не примитивного типа, то при попытке сохранения сущности будет выброшено исключение.<br><br>2. fetch - FetchType (по умолчанию EAGER) - определяет, должен ли этот атрибут извлекаться незамедлительно (EAGER) или лениво (LAZY). Однако, это необязательное требование JPA, и провайдерам разрешено незамедлительно загружать данные, даже для которых установлена ленивая загрузка.<br><br>Без аннотации @Basic при получении сущности из БД по умолчанию её поля базового типа загружаются принудительно (EAGER) и значения этих полей могут быть null</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R41" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">42</div></th><td class="s12" rowspan="2">Для чего нужна аннотация Column?</td><td class="s22">Через аннотацию @Column можно явно указать поведение столбца. Если откроете ее реализацию, то увидите, что столбцу можно задавать такие свойства, как уникальность, обновляемость и т.д.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R42" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">43</div></th><td class="s13">@Basic vs @Column:<br>1. Атрибуты @Basic применяются к сущностям JPA, тогда как атрибуты @Column применяются к столбцам базы данных.<br>2. @Basic имеет атрибут optional, который говорит о том, может ли поле объекта быть null или нет; с другой стороны атрибут nullable аннотации @Column указывает, может ли соответствующий столбец в таблице быть null.<br>3. Мы можем использовать @Basic, чтобы указать, что поле должно быть загружено лениво.<br>4. Аннотация @Column позволяет нам указать имя столбца в таблице и ряд других свойств:<br> a. insertable/updatable - можно ли добавлять/изменять данные в колонке, по умолчанию true;<br> b. length - длина, для строковых типов данных, по умолчанию 255.<br>Коротко, в Column (колум) мы задаем constraints (констрейнтс), а в Basic (бейсик) - ФЕТЧ ТАЙП</td><td class="s17">    @Column(name=&quot;STUDENT_NAME&quot;, length=50, nullable=false, unique=false)<br>    private String name;</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R43" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">44</div></th><td class="s12" rowspan="2">Для чего нужна аннотация Access?</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#000000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth">Она </a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#ff0000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth">определяет</a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#000000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth"> тип доступа (access type) для класса entity, Mapped Superclass, embeddable или отдельных атрибутов, то есть </a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#ff0000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth">как JPA будет обращаться к атрибутам entity, как к полям класса (FIELD) или как к свойствам класса (PROPERTY), имеющие гетеры (getter) и сетеры (setter).</a></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;font-style:italic;color:#000000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth"><br><br></a></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><a target="_blank" href="http://marcobehler.com/guides/spring-transaction-management-transactional-in-depth">Определяет тип доступа к полям сущности. Для чтения и записи этих полей есть два подхода:<br>1. Field access (доступ по полям). При таком способе аннотации маппинга (Id, Column,...) размещаются над полями, и Hibernate напрямую работает с полями сущности, читая и записывая их.<br>2. Property access (доступ по свойствам). При таком способе аннотации размещаются над методами-геттерами, но никак не над сеттерами. Hibernate использует их и сеттеры для чтения и записи полей сущности. </a></span></td><td class="s17"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Но есть требование - у сущности с property access</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> названия методов должны соответствовать требованиям JavaBeans. Например, если у сущности Customer есть поле с именем firstName, то у этой сущности должны быть определены методы getFirstName и setFirstName для чтения и записи поля firstName.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R44" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">45</div></th><td class="s13">По умолчанию тип доступа определяется местом, в котором находится аннотация @Id. Если она будет над полем - это будет AccessType.FIELD, если над геттером - это AccessType.PROPERTY.<br>Чтобы явно определить тип доступа у сущности, нужно использовать аннотацию @Access, которая может быть указана у сущности, Mapped Superclass и Embeddable class, а также над полями или методами.<br>Поля, унаследованные от суперкласса, имеют тип доступа этого суперкласса.<br>Когда у одной сущности определены разные типы доступа, то нужно использовать аннотацию @Transient для избежания дублирования маппинга.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R45" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">46</div></th><td class="s12">Для чего нужна аннотация @Cacheable?</td><td class="s13"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@Cacheable - необязательная аннотация JPA, используется для указания того, должна ли сущность храниться в кэше второго уровня.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> JPA говорит о пяти значениях shared-cache-mode из persistence.xml, который определяет как будет использоваться second-level cache:<br><br>❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ENABLE_SELECTIVE</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: (дефолтное и рекомендуемое значение):только сущности с аннотацией @Cacheable (равносильно значению по умолчанию @Cacheable(value=true)) будут сохраняться в кэше второго уровня.<br>❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">DISABLE_SELECTIVE</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: все сущности будут сохраняться в кэше второго уровня, за исключением сущностей, помеченных @Cacheable(value=false) как некэшируемые.<br>❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ALL</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: сущности всегда кэшируются, даже если они помечены как некэшируемые.<br>❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">NONE</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: ни одна сущность не кэшируется, даже если помечена как кэшируемая. При данной опции имеет смысл вообще отключить кэш второго уровня.<br>❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">UNSPECIFIED</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: применяются значения по умолчанию для кэша второго уровня, определенные Hibernate. Это эквивалентно тому, что вообще не используется shared-cache-mode, так как Hibernate не включает кэш второго уровня, если используется режим UNSPECIFIED.<br><br>Аннотация @Cacheable размещается над классом сущности. Её действие распространяется на эту сущность и её наследников, если они не определили другое поведение.</span></td><td class="s17">Как и большинство других полностью оснащенных платформ ORM, <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Hibernate имеет концепцию кэша первого уровня.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Это кэш с областью действия сеанса, который гарантирует, что каждый экземпляр сущности загружается только один раз в постоянном контексте. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">С другой стороны, кэш второго уровня имеет область SessionFactory </span><span style="font-size:10pt;font-family:Arial;color:#000000;">-, что означает, что он является общим для всех сеансов, созданных с помощью одной и той же фабрики сеансов. </span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R46" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">47</div></th><td class="s12">Для чего нужна аннотация @Cache?</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Это аннотация Hibernate, настраивающая тонкости кэширования объекта в кэше второго уровня Hibernate.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> @Cache принимает три параметра:<br>❖        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">include</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - имеет по умолчанию значение </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">all</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> и означающий кэширование всего объекта. Второе возможное значение - </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">non-lazy</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, запрещает кэширование лениво загружаемых объектов. Кэш первого уровня не обращает внимания на эту директиву и всегда кэширует лениво загружаемые объекты.<br>❖        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">region</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - позволяет задать имя региона кэша для хранения сущности. Регион можно представить как разные области кэша, имеющие разные настройки на уровне реализации кэша. Например, можно было бы создать в конфигурации ehcache два региона, один с краткосрочным хранением объектов, другой с долгосрочным и отправлять часто изменяющиеся объекты в первый регион, а все остальные - во второй. Ehcache по умолчанию создает регион для каждой сущности с именем класса этой сущности, соответственно в этом регионе хранятся только эти сущности. К примеру, экземпляры Foo хранятся в Ehcache в кэше с именем “com.baeldung.hibernate.cache.model.Foo”.<br>❖        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">usage</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - задаёт стратегию одновременного доступа к объектам.<br>transactional<br>read-write<br>nonstrict-read-write<br>read-only</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R47" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">48</div></th><td class="s12">Для чего нужны аннотации @Embedded и @Embeddable?</td><td class="s13"><a target="_blank" href="https://habr.com/ru/company/golovachcourses/blog/221133/">@Embeddable - аннотация JPA, размещается над классом для указания того, что класс является встраиваемым в другие классы.<br>@Embedded - аннотация JPA, используется для размещения над полем в классе-сущности для указания того, что мы внедряем встраиваемый класс.</a></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R48" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">49</div></th><td class="s12" rowspan="5">Как смапить составной ключ?</td><td class="s13">Составной первичный ключ, также называемый составным ключом, представляет собой комбинацию из двух или более столбцов для формирования первичного ключа таблицы.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R49" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">50</div></th><td class="s13"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@IdClass</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Допустим, у нас есть таблица с именем Account, и она имеет два столбца - accountNumber и accountType, которые формируют составной ключ. Чтобы обозначить оба этих поля как части составного ключа мы должны создать класс, например, ComplexKey с этими полями.<br><br>Затем нам нужно аннотировать сущность Account аннотацией @IdClass(ComplexKey.class). Мы также должны объявить поля из класса ComplexKey в сущности Account с такими же именами и аннотировать их с помощью @Id.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R50" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">51</div></th><td class="s13">public class ComplexKey implements Serializable {<br>     private String accountNumber;<br>     private String accountType;<br>     // default constructor<br>     public AccountId(String accountNumber, String accountType) {<br>        this.accountNumber = accountNumber;<br>        this.accountType = accountType;<br>     }<br>     // equals() and hashCode()<br>}<br><br>@Entity<br>@IdClass(ComplexKey.class)<br>public class Account {<br>    @Id<br>    private String accountNumber;<br>    @Id<br>    private String accountType;<br>    // other fields, getters and setters<br>}</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R51" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">52</div></th><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;"> @EmbeddedId</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Рассмотрим пример, в котором мы должны сохранить некоторую информацию о книге с заголовком и языком в качестве полей первичного ключа. В этом случае класс первичного ключа, BookId, должен быть аннотирован @Embeddable.<br>Затем нам нужно встроить этот класс в сущность Book, используя @EmbeddedId.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R52" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">53</div></th><td class="s13">@Embeddable<br>public class BookId implements Serializable {<br>    private String title;<br>    private String language;<br>    // default constructor<br>    public BookId(String title, String language) {<br>        this.title = title;<br>        this.language = language;<br>    }<br>    // getters, equals() and hashCode() methods<br>}<br>@Entity<br>public class Book {<br>    @EmbeddedId<br>    private BookId bookId;<br>    // constructors, other fields, getters and setters<br>}</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R53" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">54</div></th><td class="s12" rowspan="3">Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Аннотация @Id определяет простой (не составной) первичный ключ</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, состоящий из одного поля. В соответствии с JPA, допустимые типы атрибутов для первичного ключа:<br>1.        примитивные типы и их обертки;<br>2.        строки;<br>3.        BigDecimal и BigInteger;<br>4.        java.util.Date и java.sql.Date.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R54" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">55</div></th><td class="s4">Если мы хотим, чтобы значение первичного ключа генерировалось для нас автоматически, мы можем добавить первичному ключу, отмеченному аннотацией @Id, аннотацию @<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">GeneratedValue</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Аннотация @GeneratedValue предназначена для настройки способа приращения указанного столбца(поля).</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Возможно 4 варианта: <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">AUTO(default) - </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Указывает, что Hibernate должен выбрать подходящую стратегию для конкретной базы данных, учитывая её диалект, так как у разных БД разные способы по умолчанию. Поведение по умолчанию - исходить из типа поля идентификатора. <br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">IDENTITY - </span><span style="font-size:10pt;font-family:Arial;color:#000000;">для генерации значения первичного ключа будет использоваться столбец IDENTITY, имеющийся в базе данных. Значения в столбце автоматически увеличиваются вне текущей выполняемой транзакции(на стороне базы, так что этого столбца мы не увидим), что позволяет базе данных генерировать новое значение при каждой операции вставки. В промежутках транзакций сущность будет сохранена.</span></td><td class="s4">С версии Hibernate 5.0 для числовых значений генерация основана на SEQUENCE, и, если БД её не поддерживает, то на TABLE.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R55" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">56</div></th><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">SEQUENCE </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- тип генерации, рекомендуемый документацией Hibernate. Для получения значений первичного ключа Hibernate должен использовать имеющиеся в базе данных механизмы генерации последовательных значений (Sequence). В бд можно будет увидеть дополнительную таблицу. Но если наша БД не поддерживает тип SEQUENCE, то Hibernate автоматически переключится на тип TABLE. В промежутках транзакций сущность не будет сохранена, так как хибер возьмет из таблицы id hibernate-sequence и вернётся обратно в приложение.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">SEQUENCE </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">это объект базы данных, который генерирует инкрементные целые числа при каждом последующем запросе. </span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">TABLE </span><span style="font-size:10pt;font-family:Arial;color:#000000;">- </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Hibernate должен получать первичные ключи для сущностей из создаваемой для этих целей таблицы</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, способной содержать именованные сегменты значений для любого количества сущностей. Требует использования пессимистических блокировок, которые помещают все транзакции в последовательный порядок и замедляет работу приложения.</span></td><td class="s15"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R56" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">57</div></th><td class="s12" rowspan="5">Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;"> @JoinColumn используется для указания столбца FOREIGN KEY, используемого при установлении связей между сущностями или коллекциями.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Мы помним, что только сущность-владелец связи может иметь внешние ключи от другой сущности (владеемой). Однако, мы можем указать @JoinColumn как во владеющей таблице, так и во владеемой, но столбец с внешними ключами всё равно появится во владеющей таблице. <br>Особенности использования:</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R57" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">58</div></th><td class="s13">❖        @OneToOne: означает, что появится столбец в таблице сущности-владельца связи, который будет содержать внешний ключ, ссылающийся на первичный ключ владеемой сущности.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R58" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">59</div></th><td class="s13">❖        @OneToMany/@ManyToOne: если не указать на владеемой стороне связи атрибут mappedBy, создается joinTable с ключами обеих таблиц. Но при этом же у владельца создается столбец с внешними ключами.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R59" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">60</div></th><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> @JoinColumns</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> используется для группировки нескольких аннотаций @JoinColumn, которые используются при установлении связей между сущностями или коллекциями, у которых составной первичный ключ и требуется несколько колонок для указания внешнего ключа.<br>В каждой аннотации @JoinColumn должны быть указаны элементы name и referencedColumnName.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R60" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">61</div></th><td class="s22"> @JoinTable используется для указания связывающей (сводной, третьей) таблицы между двумя другими таблицами.                                <span style="font-size:10pt;font-family:Arial;font-weight:normal;font-style:italic;color:#ff0000;">@JoinTable(name = &quot;CATALOG&quot;, joinColumns = @JoinColumn(name = &quot;ID_BOOK&quot;), inverseJoinColumns = @JoinColumn(name = &quot;ID_STUDENT&quot;))<br> private Student student;</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R61" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">62</div></th><td class="s12" rowspan="4">Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?</td><td class="s13"> <span style="font-size:10pt;font-family:Arial;color:#ff0000;">@</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">OrderBy указывает порядок, в соответствии с которым должны располагаться элементы коллекций</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#000000;">сущностей, базовых или встраиваемых типов </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">при их извлечении из БД. Если в кэше есть нужные данные, то сортировки не будет</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Так как @OrderBy просто добавляет к sql-запросу Order By, а при получении данных из кэша, обращения к бд нет. Эта аннотация может использоваться с аннотациями @ElementCollection, @OneToMany, @ManyToMany.<br>При использовании с коллекциями базовых типов, которые имеют аннотацию </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@ElementCollection, элементы этой коллекции будут отсортированы в натуральном порядке, по значению базовых типов.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R62" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">63</div></th><td class="s23">Если это коллекция встраиваемых типов (@Embeddable), то используя точку (&quot;.&quot;) мы можем сослаться на атрибут внутри встроенного атрибута. <br>Если это коллекция сущностей, то у аннотации @OrderBy можно указать имя поля сущности, по которому сортировать эти самые сущности:<br>Если мы не укажем у @OrderBy параметр, то сущности будут упорядочены по первичному ключу.<br>В случае с сущностями доступ к полю по точке не работает. Попытка использовать вложенное свойство, например @OrderBy (&quot;supervisor.name&quot;) повлечет Runtime Exceprtion.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R63" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">64</div></th><td class="s13"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@OrderColumn создает в таблице столбец с индексами порядка элементов</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, который используется для поддержания постоянного порядка в списке, но этот столбец не считается частью состояния сущности или встраиваемого класса.<br>Hibernate отвечает за поддержание порядка как в базе данных при помощи столбца, так и при получении сущностей и элементов из БД. Hibernate отвечает за обновление порядка при записи в базу данных, чтобы отразить любое добавление, удаление или иное изменение порядка, влияющее на список в таблице.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R64" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">65</div></th><td class="s13"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@OrderBy vs @OrderColumn</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Порядок, указанный в @OrderBy, применяется только в рантайме при выполнении запроса к БД, То есть в контексте персистентности, в то время как при использовании @OrderColumn, порядок сохраняется в отдельном столбце таблицы и поддерживается при каждой вставке/обновлении/удалении элементов.<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R65" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">66</div></th><td class="s12">Для чего нужна аннотация Transient?</td><td class="s13"> <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">@Transient используется для объявления того, какие поля</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> у сущности, встраиваемого класса или Mapped SuperClass </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">не будут сохранены в базе данных.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Persistent fields (постоянные поля) - это поля, значения которых будут по умолчанию сохранены в БД. Ими являются любые не static и не final поля.<br>Transient fields (временные поля):<br>❖        static и final поля сущностей;<br>❖        иные поля, объявленные явно с использованием Java-модификатора transient, либо JPA-аннотации @Transient.<br></span></td><td class="s24">Initial user: User{firstName=&#39;Stefan&#39;, lastName=&#39;Smith&#39;<span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, email=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;ssmith@email.com&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, birthDate=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">1991</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">-</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">07</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">-</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">16</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, login=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;ssmith&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, </span><span style="font-size:11pt;font-family:Consolas,Arial;font-weight:bold;color:#ff0000;">password=&#39;gemma_arterton_4ever_in_my_heart91&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">} Loaded user from file: User{firstName=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;Stefan&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, lastName=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;Smith&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, email=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;ssmith@email.com&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, birthDate=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">1991</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">-</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">07</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">-</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#0026b3;">16</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, login=</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#008000;">&#39;ssmith&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">, </span><span style="font-size:11pt;font-family:Consolas,Arial;font-weight:bold;color:#ff0000;">password=&#39;null&#39;</span><span style="font-size:11pt;font-family:Consolas,Arial;color:#000000;">}</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R66" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">67</div></th><td class="s12" rowspan="4">Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?</td><td class="s13">В порядке от самого ненадежного и быстрого, до самого надежного и медленного:<br>1.        <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">NONE </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— без блокировки.<br>2.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">OPTIMISTIC </span><span style="font-size:10pt;font-family:Arial;color:#000000;">(синоним READ в JPA 1) — оптимистическая  блокировка, которая работает, как описано ниже: если при завершении транзакции кто-то извне изменит поле @Version, то будет сделан RollBack транзакции и будет выброшено OptimisticLockException.<br>3.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">OPTIMISTIC_FORCE_INCREMENT </span><span style="font-size:10pt;font-family:Arial;color:#000000;">(синоним WRITE в JPA 1) — работает по тому же алгоритму, что и LockModeType.OPTIMISTIC за тем исключением, что после commit значение поле Version принудительно увеличивается на 1. В итоге окончательно после каждого коммита поле увеличится на 2(увеличение, которое можно увидеть в Post-Update + принудительное увеличение).<br>4.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">PESSIMISTIC_READ </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— данные блокируются в момент чтения и это гарантирует, что никто в ходе выполнения транзакции не сможет их изменить. Остальные транзакции, тем не менее, смогут параллельно читать эти данные. Использование этой блокировки может вызывать долгое ожидание блокировки или даже выкидывание PessimisticLockException.<br>5.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">PESSIMISTIC_WRITE</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> — данные блокируются в момент записи и никто с момента захвата блокировки </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">не может в них писать и не может их читать</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> до окончания транзакции, владеющей блокировкой. Использование этой блокировки может вызывать долгое ожидание блокировки.<br>6.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">PESSIMISTIC_FORCE_INCREMENT </span><span style="font-size:10pt;font-family:Arial;color:#000000;">— ведёт себя как PESSIMISTIC_WRITE, но в конце транзакции увеличивает значение поля @Version, даже если фактически сущность не изменилась.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Блокировка - в реляционных базах данных это установка метки на запись, что запись заблокирована для изменений.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R67" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">68</div></th><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Оптимистичное блокирование</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - подход предполагает, </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">что параллельно выполняющиеся транзакции редко обращаются к одним и тем же данным и позволяет им свободно выполнять любые чтения и обновления данных.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Но при окончании транзакции производится проверка, изменились ли данные в ходе выполнения данной транзакции и, если да, транзакция обрывается и выбрасывается OptimisticLockException. Оптимистичное блокирование в JPA реализовано путём внедрения в сущность специального поля версии:<br>    @Version<br>    private long version;<br>Поле, аннотирование @Version, может быть целочисленным или временнЫм. При завершении транзакции, если сущность была заблокирована оптимистично, будет проверено, не изменилось ли значение @Version кем-либо ещё, после того как данные были прочитаны, и, если изменилось, будет выкинуто OptimisticLockException. Использование этого поля позволяет отказаться от блокировок на уровне базы данных и сделать всё на уровне JPA, улучшая уровень конкурентности.<br></span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Позволяет отказатьсь от блокировок на уровне БД и делать всё с JPA.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R68" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">69</div></th><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Пессимистичное блокирование</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> - подход напротив, ориентирован на транзакции, которые часто конкурируют за одни и те же данные и поэтому блокирует доступ к данным в тот момент когда читает их. Другие транзакции останавливаются, когда пытаются обратиться к заблокированным данным и ждут снятия блокировки (или кидают исключение). </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Пессимистичное блокирование выполняется на уровне базы и поэтому не требует вмешательств в код сущности.</span></td><td class="s1"></td><td class="s4">Filter vs. Interceptor ❖ Перехватчик основан на механизме Reflection, а фильтр основан на обратном вызове функции. ❖ Фильтр зависит от контейнера сервлета, тогда как перехватчик не зависит от него. ❖ Перехватчики могут работать только с запросами к контроллерам, в то время как фильтры могут работать почти со всеми запросами (например, js, .css и т.д.). ❖ Перехватчики в отличии от фильтров могут обращаться к объектам в контейнере Spring, что даёт им более изощренный функционал</td></tr><tr style="height: 20px"><th id="0R69" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">70</div></th><td class="s13">Блокировки ставятся путём вызова метода lock() у EntityManager, в который передаётся сущность, требующая блокировки и уровень блокировки:<br>EntityManager em = entityManagerFactory.createEntityManager();<br>em.lock(company1, LockModeType.OPTIMISTIC);</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R70" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">71</div></th><td class="s12" rowspan="4">Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?</td><td class="s13">1. first-level cache (кэш первого уровня) — кэширует данные одной транзакции;<br>2. second-level cache (кэш второго уровня) —<span style="font-size:10pt;font-family:Arial;color:#ff0000;"> кэширует данные транзакций от одной фабрики сессий.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Провайдер JPA может, но не обязан реализовывать работу с кэшем второго уровня.<br>3. Кэш запросов.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R71" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">72</div></th><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Кэш первого уровня</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> – </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">это кэш сессии (Session), который является обязательным, это и есть PersistenceContext</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Через него проходят все запросы.<br>В том случае, если мы выполняем несколько обновлений объекта, Hibernate старается отсрочить (насколько это возможно) обновление этого объекта для того, чтобы сократить количество выполненных запросов в БД. Например, при пяти истребованиях одного и того же объекта из БД в рамках одного persistence context, запрос в БД будет выполнен один раз, а остальные четыре загрузки будут выполнены из кэша. Если мы закроем сессию, то все объекты, находящиеся в кэше, теряются, а далее – либо сохраняются в БД, либо обновляются.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R72" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">73</div></th><td class="s13">Особенности кэша первого уровня:<br>❖        включен по умолчанию, его нельзя отключить;<br>❖        связан с сессией (контекстом персистентности), то есть разные сессии видят только объекты из своего кэша, и не видят объекты, находящиеся в кэшах других сессий;<br>❖        при закрытии сессии PersistenceContext очищается - кэшированные объекты, находившиеся в нем, удаляются;<br>❖        при первом запросе сущности из БД, она загружается в кэш, связанный с этой сессией;<br>❖        если в рамках этой же сессии мы снова запросим эту же сущность из БД, то она будет загружена из кэша, и никакого второго SQL-запроса в БД сделано не будет;<br>❖        сущность можно удалить из кэша сессии методом evict(), после чего следующая попытка получить эту же сущность повлечет обращение к базе данных;<br>❖        метод clear() очищает весь кэш сессии.</td><td class="s4"><span style="font-size:10pt;font-family:Arial;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#000000;">load() или объекта с лениво загружаемыми полями</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, лениво загружаемые данные в кэш не попадут, а вместо этих данных</span><span style="font-size:10pt;font-family:Arial;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#000000;"> Hibernate создаст объект Proxy</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. Однако, </span><span style="font-size:10pt;font-family:Arial;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#000000;">как только мы обратимся к этому прокси-объекту в рамках этого же открытого контекста персистентности, Hibernate всё-таки выполнит запрос в базу и данные будут загружены и в объект и в кэш</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. А вот следующая попытка лениво загрузить объект приведёт к тому, что объект сразу вернут из кэша уже полностью загруженным, без обращения в БД.</span></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R73" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">74</div></th><td class="s13">Если кэш первого уровня привязан к объекту сессии, то <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">кэш второго уровня</span><span style="font-size:10pt;font-family:Arial;color:#ff0000;"> привязан к объекту-фабрике сессий</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">(Session Factory object) и, следовательно, кэш второго уровня доступен одновременно в нескольких сессиях или контекстах персистентности.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Кэш второго уровня требует некоторой настройки и поэтому не включен по умолчанию. Настройка кэша заключается в конфигурировании реализации кэша и разрешения сущностям быть закэшированными.<br>Hibernate не реализует сам никакого in-memory сache, а использует существующие реализации кэшей.<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R74" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">75</div></th><td class="s12" rowspan="3">Как работать с кешем 2 уровня?</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R75" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">76</div></th><td class="s13"><span style="font-size:10pt;font-family:Arial;color:#ff0000;">В Hibernate кэширование второго уровня реализовано в виде абстракции, то есть мы должны предоставить любую её реализацию, вот несколько провайдеров: Ehcache</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, OSCache, SwarmCache, JBoss TreeCache. </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">Для Hibernate требуется только реализация интерфейса org.hibernate.cache.spi.RegionFactory, который инкапсулирует все детали, относящиеся к конкретным провайдерам. По сути, RegionFactory действует как мост между Hibernate и поставщиками кэша. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">В примерах будем использовать Ehcache. Что нужно сделать: ❖ добавить мавен-зависимость кэш-провайдера нужной версии ❖ включить кэш второго уровня и определить конкретного провайдера hibernate.cache.use_second_level_cache=true hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory ❖ установить у нужных сущностей JPA-аннотацию @Cacheable, обозначающую, что сущность нужно кэшировать, и Hibernate-аннотацию @Cache, настраивающую детали кэширования, у которой в качестве параметра указать стратегию параллельного доступа&quot; на &quot;Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня. Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Shared Cache Mode</span><span style="font-size:10pt;font-family:Arial;color:#000000;">  </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">ENABLE_SELECTIVE,  ALL, NONE, UNSPECIFIED</span></td><td class="s1"></td><td class="s17">Процесс аутентификации: 1. UsernamePasswordAuthenticationFilter получают имя пользователя и пароль и создает экземпляр класса UsernamePasswordAuthenticationToken (экземпляр интерфейса Authentication). 2. Токен передается экземпляру AuthenticationManager для проверки. 3. AuthenticationManager возвращает полностью заполненный экземпляр Authentication в случае успешной аутентификации. 4. Устанавливается контекст безопасности путем вызова SecurityContextHolder.getContext().setAuthentication(...), куда передается вернувшийся экземпляр Authentication. 5. При успешной аутентификации можно использовать successHandler</td></tr><tr style="height: 20px"><th id="0R76" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">77</div></th><td class="s13">Стратегии параллельного доступа к объектам Проблема заключается в том, что кэш второго уровня доступен из нескольких сессий сразу и несколько потоков программы могут одновременно в разных транзакциях работать с одним и тем же объектом. Следовательно надо как-то обеспечивать их одинаковым представлением этого объекта. ❖<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> READ_ONLY: Используется только для сущностей, которые никогда не изменяются</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> (будет выброшено исключение, если попытаться обновить такую сущность). Очень просто и производительно. Подходит для некоторых статических данных, которые не меняются. ❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">NONSTRICT_READ_WRITE</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: К</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">эш обновляется после совершения транзакции, которая изменила данные в БД и закоммитила их.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Таким образом, строгая согласованность не гарантируется, и существует небольшое временное окно между обновлением данных в БД и обновлением тех же данных в кэше, во время которого параллельная транзакция может получить из кэша устаревшие данные. ❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">READ_WRITE</span><span style="font-size:10pt;font-family:Arial;color:#000000;">: Эта стратегия гарантирует строгую согласованность, которую она достигает, используя «мягкие» блокировки: </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">когда обновляется кэшированная сущность, на нее накладывается мягкая блокировка, которая снимается после коммита транзакции.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Все параллельные транзакции, которые пытаются получить доступ к записям в кэше с наложенной мягкой блокировкой, не смогут их прочитать или записать и отправят запрос в БД. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Ehcache использует эту стратегию по умолчанию. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">❖ </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">TRANSACTIONAL: полноценное разделение транзакций. Каждая сессия и каждая транзакция видят объекты, словно они работали с ними последовательно одна транзакция за другой. Плата за это — блокировки и потеря производительности</span></td><td class="s25 softmerge"><div class="softmerge-inner" style="width:657px;left:-1px">Hibernate Proxy используется для замены реальной сущности POJO (Plain Old Java Object).</div></td><td class="s19"></td></tr><tr style="height: 20px"><th id="0R77" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">78</div></th><td class="s12" rowspan="3">Что такое JPQL/HQL и чем он отличается от SQL?</td><td class="s13">Hibernate Query Language (HQL) и Java Persistence Query Language (JPQL) - оба являются объектно-ориентированными языками запросов, схожими по природе с SQL. <br><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">JPQL - это подмножество HQL.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R78" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">79</div></th><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">HQL - это язык запросов, практически такой же как SQL,</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;color:#ff0000;">однако, вместо имен и колонок таблиц базы данных, он использует имена классов Entity и их атрибуты.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> В качестве параметров запросов также используются типы данных атрибутов Entity, а не полей баз данных. В отличии от SQL в JPQL есть автоматический полиморфизм, то есть к</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">аждый запрос к Entity возвращает не только объекты этого Entity, но также объекты всех его классов-потомков</span><span style="font-size:10pt;font-family:Arial;color:#000000;">, независимо от стратегии наследования. В JPA запрос представлен в виде javax.persistence.Query или javax.persistence.TypedQuery, полученных из EntityManager. </span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R79" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">80</div></th><td class="s13">В Hibernate HQL-запрос представлен org.hibernate.query.Query, полученный из Session. Если HQL является именованным запросом, то будет использоваться Session#getNamedQuery, в противном случае требуется Session#createQuery.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R80" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">81</div></th><td class="s12" rowspan="2">Что такое Criteria API и для чего он используется?</td><td class="s13"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">JPA Criteria API - это API, который позволяет делать WHERE (SELECT) запросы гораздо проще. (Динамические запросы). </span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Основные преимущества JPA Criteria API:<br>❖        ошибки могут быть обнаружены во время компиляции;<br>❖        позволяет динамически формировать запросы на этапе выполнения приложения.<br>Основные недостатки:<br>❖        нет контроля над запросом, сложно отловить ошибку<br>❖        влияет на производительность, множество классов<br><br>Для динамических запросов - фрагменты кода создаются во время выполнения - JPA Criteria API является предпочтительней. </span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R81" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">82</div></th><td class="s13">Вот некоторые области применения Criteria API:<br>Criteria API поддерживает проекцию, которую мы можем использовать для агрегатных функций вроде sum(), min(), max() и т.д.<br>Criteria API может использовать ProjectionList для извлечения данных только из выбранных колонок.<br>Criteria API может быть использована для join запросов с помощью соединения нескольких таблиц, используя методы createAlias(), setFetchMode() и setProjection().<br>Criteria API поддерживает выборку результатов согласно условиям (ограничениям). Для этого используется метод add() с помощью которого добавляются ограничения (Restrictions).<br>Criteria API позволяет добавлять порядок (сортировку) к результату с помощью метода addOrder().        </td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R82" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">83</div></th><td class="s12" rowspan="6">Расскажите про проблему N+1 Select и путях ее решения.</td><td class="s13">Проблема N+1 запросов возникает, <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#ff0000;">когда получение данных из БД выполняется за N дополнительных SQL-запросов для извлечения тех же данных, которые могли быть получены при выполнении основного SQL-запроса</span><span style="font-size:10pt;font-family:Arial;color:#000000;">.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Проблема N + 1 возникает, когда фреймворк доступа к данным выполняет N дополнительных SQL-запросов для получения тех же данных, которые можно получить при выполнении одного SQL-запроса.<br>Чем больше значение N, тем больше запросов будет выполнено и тем больше влияние на производительность. И хотя лог медленных запросов может вам помочь найти медленные запросы, но проблему N + 1 он не обнаружит, так как каждый отдельный дополнительный запрос выполняется достаточно быстро. <br>Проблема заключается в выполнении множества дополнительных запросов, которые в сумме выполняются уже существенное время, влияющее на быстродействие.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R83" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">84</div></th><td class="s13"><span style="font-size:10pt;font-family:Arial;color:#000000;">1. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">       JOIN FETCH</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>И при FetchType.EAGER и при FetchType.LAZY нам поможет JPQL-запрос с JOIN FETCH. Опцию «FETCH» можно использовать в JOIN (INNER JOIN или LEFT JOIN) для выборки связанных объектов в одном запросе вместо дополнительных запросов для каждого доступа к ленивым полям объекта.<br>Лучший вариант решения для простых запросов (1-3 уровня вложенности связанных объектов).<br><br>select pc<br>    from PostComment pc<br>    join fetch pc.post p</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R84" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">85</div></th><td class="s13"><span style="font-size:10pt;font-family:Arial;color:#000000;">2.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">EntityGraph</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>В случаях, когда нам нужно получить по-настоящему много данных, и у нас jpql запрос - лучше всего использовать EntityGraph.<br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R85" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">86</div></th><td class="s13"><span style="font-size:10pt;font-family:Arial;color:#000000;">3.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@Fetch(FetchMode.SUBSELECT)</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Аннотация Hibernate. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Можно использовать только с коллекциями.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций:<br><br>@Fetch(value = FetchMode.SUBSELECT)<br>    private Set&lt;Order&gt; orders = new HashSet&lt;&gt;();</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R86" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">87</div></th><td class="s13"><span style="font-size:10pt;font-family:Arial;color:#000000;">4.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Batch fetching</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Это Аннотация Hibernate, в JPA её нет. Указывается над классом сущности или над полем коллекции с ленивой загрузкой. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций. Количество загружаемых сущностей указывается в аннотации.<br><br>@BatchSize(size=5)<br>private Set&lt;Order&gt; orders = new HashSet&lt;&gt;();</span></td><td class="s17">Хотя использовать @BatchSize лучше, чем столкнуться с проблемой запроса N+1, в большинстве случаев гораздо лучшей альтернативой является использование DTO или JOIN FETCH, поскольку они позволяют получать все необходимые данные одним запросом.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R87" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">88</div></th><td class="s13"><span style="font-size:10pt;font-family:Arial;color:#000000;">5.        </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">HibernateSpecificMapping, SqlResultSetMapping</span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br>Для нативных запросов рекомендуется использовать именно их.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R88" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">89</div></th><td class="s12" rowspan="2">Что такое Entity Graph</td><td class="s26"><span style="font-size:10pt;font-family:Arial;text-decoration:underline;text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#000000;">Он позволяет определить шаблон путем группировки связанных полей, которые мы хотим получить, и позволяет нам выбирать тип графа во время выполнения</span><span style="font-size:10pt;font-family:Arial;color:#000000;">.Основная цель JPA Entity Graph - улучшить производительность в рантайме при<br>загрузке базовых полей сущности и связанных сущностей и коллекций. </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Вкратце, Hibernate загружает весь граф в одном SELECT-запросе, то есть все<br>указанные связи от нужной нам сущности. . Работа с EntityGraph: createEntityGraph, getEntityGraph.<br></span><span style="font-size:10pt;font-family:Arial;color:#000000;"><br></span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R89" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">90</div></th><td class="s14"></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R90" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">91</div></th><td class="s27"></td><td class="s17">4.        Логика при регистрации бинов управляется набором @ConditionalOn* аннотаций. Можно указать, чтобы бин создавался при наличии класса в classpath (@ConditionalOnClass), наличии существующего бина (@ConditionalOnBean), отсуствии бина (@ConditionalOnMissingBean) и т.п. Таким образом наличие конфигурации не значит, что бин будет создан и зачастую конфигурация ничего делать и создавать не будет.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R91" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">92</div></th><td class="s27"></td><td class="s17">5.        Созданный в итоге <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">AnnotationConfig</span><span style="font-size:10pt;font-family:Arial;color:#000000;">EmbeddedWeb</span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">ApplicationContext</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> ищет в том же DI контейнере фабрику для запуска embedded servlet container.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R92" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">93</div></th><td class="s28"></td><td class="s26">6.        Servlet container запускается, приложение готово к работе</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R93" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">94</div></th><td class="s28">Расскажите про нововведения Spring 5.</td><td class="s26">●        Используется JDK 8+ (Optional, CompletableFuture, Time API, java.util.function, default methods)<br>●        Поддержка Java 9 (Automatic-Module-Name in 5.0, module-info in 6.0+, ASM 6)<br>●        Поддержка HTTP/2 (TLS, Push), NIO/NIO.2<br>●        Поддержка Kotlin<br>●        Реактивность (веб-инфраструктура с реактивным стеком, «Spring WebFlux»)<br>●        Null-safety аннотации(@Nullable), новая документация<br>●        Совместимость с Java EE 8 (Servlet 4.0, Bean Validation 2.0, JPA 2.2, JSON Binding API 1.0)<br>●        Поддержка JUnit 5 + Testing Improvements (conditional and concurrent)<br>●        Удалена поддержка: Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R94" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">95</div></th><td class="s28"> Расскажите про аннотацию @ComponentScan</td><td class="s17"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Аннотация @ComponentScan используется вместе с аннотацией @Configuration для указания пакетов, которые мы хотим сканировать на наличие компонентов, из которых нужно сделать бины.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> </span><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">@ComponentScan без аргументов указывает Spring по умолчанию сканировать текущий пакет и все его подпакеты.</span><span style="font-size:10pt;font-family:Arial;color:#000000;"> Текущий пакет - тот, в котором находится файл конфигурации с этой самой аннотацией @ComponentScan. В данном случае в контейнер попадут: ❖ бин конфигурационного класса; ❖ бины, объявленные в конфигурационном классе с помощью @Bean; ❖ все бины из пакета и его подпакетов. Аннотация @SpringBootApplication включает в себя аннотации @ComponentScan, @SpringBootConfiguration и @EnableAutoConfiguration, но это не мешает разместить её ещё раз отдельно для указания конкретного пакета. Если указать @ComponentScan с атрибутом basePackages, то это изменит пакет по умолчанию на указанный</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R95" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">96</div></th><td class="s1"></td><td class="s6">Java Servlet API — стандартизированный API, предназначенный для реализации на сервере и работе с клиентом по схеме запрос-ответ. Сервлет — это класс, который умеет получать запросы от клиента и возвращать ему ответы. Да, сервлеты в Java — именно те элементы, с помощью которых строится клиент-серверная архитектура.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R96" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">97</div></th><td class="s29">Что делает аннотация @RequestMapping?</td><td class="s30"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#111111;">Используется только для указания URI до класса-контроллера.</span><span style="font-size:10pt;font-family:Arial;color:#111111;"> @RestController<br>@RequestMapping(&quot;/api/coupon&quot;)</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R97" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">98</div></th><td class="s29">Аннотация @RequestParam?</td><td class="s17"><span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">Эта аннотация используется для того, чтобы методы обработчики могли получить параметры из http-запроса. </span><span style="font-size:10pt;font-family:Arial;color:#000000;">Запрос с параметрами: http://localhost:8080/getByName/name=Ivan. Следующий код поместит в переменную name строку Ivan.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R98" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">99</div></th><td class="s29">Аннотация @PathVariable?</td><td class="s17">Эта <span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;">аннотация получает определенную часть из URI</span><span style="font-size:10pt;font-family:Arial;color:#000000;">. URI: http://localhost:8080/getById/23 Следующий код поместит в переменную id значение 23.</span></td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R99" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">100</div></th><td class="s29">@RequestBody?</td><td class="s17">@RequestBody, Spring на лету попытается преобразовать содержимое тела входящего запроса в ваш объект параметра.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R100" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">101</div></th><td class="s29">Аннотация @ResponseStatus?</td><td class="s30">Она позволяет устанавливать код ответа. Обычно Spring сам устанавливает нужный код ответа, но бывают моменты, когда это нужно переопределить.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R101" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">102</div></th><td class="s29">RestTemplate? Какие у него преимущества?</td><td class="s17">RestTemplate это специальный клиент в Spring для отправки http-запросов. Он предоставляет удобные API для легкого вызова конечных точек REST’а в одну строку.</td><td class="s1"></td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R102" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">103</div></th><td class="s29">GET_POST_PUT_DELETE_PATCH</td><td class="s17">@GetMapping — Обрабатывает get-запросы(чтение) @PostMapping — Обрабатывает post-запросы (создание)@DeleteMapping — Обрабатывает delete-запросы @PutMapping — Обрабатывает put-запросы(обновление) @PatchMapping — Обрабатывает patch-запросы</td><td class="s17">PUT — изначально существовавший в стандарте метод, предполагающий полную замену изменяемого объекта. Соответственно в методе PUT, как я и писал выше, придётся указать даже те атрибуты объекта, которые не меняются.</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R103" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">104</div></th><td class="s29">@GetMapping</td><td class="s17">Аннотация @GetMapping — это просто аннотация которая содержит @RequestMapping(method = RequestMethod.GET). Она также позволяет более глубоко настроить метод-обработчик. Ее параметры(они конвертируются в аналогичные параметры @RequestMapping):<span style="font-size:10pt;font-family:Arial;font-weight:bold;color:#000000;"> path — URI, headers — заголовки, name — имя обработчика params — параметры , produces — тип возвращаемых данных(JSON, XML, текст). Используется в REST, consumes — тип принимаемых данных. Используется в REST</span></td><td class="s1">@ApiOperation — описывает метод контроллера</td><td class="s1"></td></tr><tr style="height: 20px"><th id="0R104" style="height: 20px;" class="row-headers-background"><div class="row-header-wrapper" style="line-height: 20px">105</div></th><td class="s29">Что обозначают разные коды для http-ответов?</td><td class="s17">GET — 200 OK POST — 200 OK, 201 Created, 204 No Content PUT — 200 OK, 201 Created, 204 No Content DELETE — 204 No Content, 202 Accepted</td><td class="s1"></td><td class="s1"></td></tr></tbody></table></div>